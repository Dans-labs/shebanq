{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Technical Home \u00b6 What it is, how it is designed, how it works and how it can be installed and maintained. About \u00b6 SHEBANQ is a website built as an application in the Web2Py framework. It uses MySQL databases to store its dynamic data, which is generated by users, and its static data, which consists of the text of the hebrew Bible and linguistic annotations of the ETCBC . The static data is delivered via the BHSA repository, where it arrived through a pipeline ) from the source data as it sits on ETCBC servers. The specialty of SHEBANQ is that it offers users the facility to run queries against the data and to store those queries so theat they can be shared and published. The query engine for this is Emdros which sits on top of MySQL and speaks with it. Shebanq and the pipeline have been constructed using Text-Fabric as the main tool. There are several kinds of documentation of SHEBANQ, see documentation where it is decribed how to maintain that information. Quickly jump to a topic below, or use the navigation controls. Conventions \u00b6 Code references \u00b6 This documentation contains many references to code. These references have shapes that help you recognize to what code they refer: [M:XXX.yyy] refers to Python code for yyy in module modules/xxx.py [C:xxx.yyy] refers to Python controller yyy() in file controllers/xxx.py [{xxx.yyy}] refers to Javascript code for yyy in file static/js/app/xxx.js Topics \u00b6 Elements of the page Installation on personal computers and servers Maintenance","title":"Technical Home"},{"location":"#technical-home","text":"What it is, how it is designed, how it works and how it can be installed and maintained.","title":"Technical Home"},{"location":"#about","text":"SHEBANQ is a website built as an application in the Web2Py framework. It uses MySQL databases to store its dynamic data, which is generated by users, and its static data, which consists of the text of the hebrew Bible and linguistic annotations of the ETCBC . The static data is delivered via the BHSA repository, where it arrived through a pipeline ) from the source data as it sits on ETCBC servers. The specialty of SHEBANQ is that it offers users the facility to run queries against the data and to store those queries so theat they can be shared and published. The query engine for this is Emdros which sits on top of MySQL and speaks with it. Shebanq and the pipeline have been constructed using Text-Fabric as the main tool. There are several kinds of documentation of SHEBANQ, see documentation where it is decribed how to maintain that information. Quickly jump to a topic below, or use the navigation controls.","title":"About"},{"location":"#conventions","text":"","title":"Conventions"},{"location":"#code-references","text":"This documentation contains many references to code. These references have shapes that help you recognize to what code they refer: [M:XXX.yyy] refers to Python code for yyy in module modules/xxx.py [C:xxx.yyy] refers to Python controller yyy() in file controllers/xxx.py [{xxx.yyy}] refers to Javascript code for yyy in file static/js/app/xxx.js","title":"Code references"},{"location":"#topics","text":"Elements of the page Installation on personal computers and servers Maintenance","title":"Topics"},{"location":"news/","text":"News \u00b6 2021-10-05 Big update is due. New ETCBC dataversion 2021 Migration to Python3 New versions of Emdros and Web2Py and MySQL Completely refactored codebase: all Python, Javascript and CSS code chopped up in managable chunks. Install and maintenance scripts Mkdocs framework for technical documentation Maintenance documentation written Shebanq software documentation just started See also older news","title":"News"},{"location":"news/#news","text":"2021-10-05 Big update is due. New ETCBC dataversion 2021 Migration to Python3 New versions of Emdros and Web2Py and MySQL Completely refactored codebase: all Python, Javascript and CSS code chopped up in managable chunks. Install and maintenance scripts Mkdocs framework for technical documentation Maintenance documentation written Shebanq software documentation just started See also older news","title":"News"},{"location":"client/","text":"Client \u00b6 This is the part of SHEBANQ that works in the browser. Its main parts are the CSS files Javascript files","title":"Client"},{"location":"client/#client","text":"This is the part of SHEBANQ that works in the browser. Its main parts are the CSS files Javascript files","title":"Client"},{"location":"client/css/","text":"CSS organization \u00b6 The styling of SHEBANQ is organized in a bunch of CSS files that each take care of a certain aspect of the layout.","title":"CSS organization"},{"location":"client/css/#css-organization","text":"The styling of SHEBANQ is organized in a bunch of CSS files that each take care of a certain aspect of the layout.","title":"CSS organization"},{"location":"client/js/","text":"Javascript organization \u00b6 The interaction with SHEBANQ is taken care of by a modern Javascript app. SHEBANQ uses vanilla Javascript (ES6 and higher), without any code preprocessing. The Javascript source is directly included by the HTML. We only use a few Javascript libraries: fancytree for the overview pages of notes and queries; jQuery almost everywhere. Most of the code is organized in modules under static/js/app . The modules are individually documented by jsdocstrings in the code. Entry point \u00b6 The entry point is main.js . It has the following responsibilities: Pick up a bunch of settings from the server Set up LocalStorage in the browser to remember those settings Make the settings available in an ViewState object that is globally accessible Construct a Page object Start the dynamics of the Page object Objects in general \u00b6 Most of the objects defined in the javascript app share a general way of working: Constructor \u00b6 Object constructors do simple work, and do not depend on the outcomes of asynchronous actions of other objects. So it is always safe to construct an object. Initialization \u00b6 If objects need initialization that depends on asynchronous work of other objects, it should be put in an init() method. These can be triggered by the process() methods of other objects. Fetch \u00b6 If objects need to interact with the server, they use AJAX to send/fetch data. When the response from the server has come back, a callback is executed in wich the method process() is called. Process \u00b6 Everything that needs to be done with data that has been fetched from the server, is done in this method. Things to do are typically: generate HTML out of JSON dress up the DOM with events Apply \u00b6 Whenever the ViewState changes, objects maybe affected. Objects do not listen to the state themselves. Whichever object changes the state must trigger the apply() method of affected objects.","title":"Javascript organization"},{"location":"client/js/#javascript-organization","text":"The interaction with SHEBANQ is taken care of by a modern Javascript app. SHEBANQ uses vanilla Javascript (ES6 and higher), without any code preprocessing. The Javascript source is directly included by the HTML. We only use a few Javascript libraries: fancytree for the overview pages of notes and queries; jQuery almost everywhere. Most of the code is organized in modules under static/js/app . The modules are individually documented by jsdocstrings in the code.","title":"Javascript organization"},{"location":"client/js/#entry-point","text":"The entry point is main.js . It has the following responsibilities: Pick up a bunch of settings from the server Set up LocalStorage in the browser to remember those settings Make the settings available in an ViewState object that is globally accessible Construct a Page object Start the dynamics of the Page object","title":"Entry point"},{"location":"client/js/#objects-in-general","text":"Most of the objects defined in the javascript app share a general way of working:","title":"Objects in general"},{"location":"client/js/#constructor","text":"Object constructors do simple work, and do not depend on the outcomes of asynchronous actions of other objects. So it is always safe to construct an object.","title":"Constructor"},{"location":"client/js/#initialization","text":"If objects need initialization that depends on asynchronous work of other objects, it should be put in an init() method. These can be triggered by the process() methods of other objects.","title":"Initialization"},{"location":"client/js/#fetch","text":"If objects need to interact with the server, they use AJAX to send/fetch data. When the response from the server has come back, a callback is executed in wich the method process() is called.","title":"Fetch"},{"location":"client/js/#process","text":"Everything that needs to be done with data that has been fetched from the server, is done in this method. Things to do are typically: generate HTML out of JSON dress up the DOM with events","title":"Process"},{"location":"client/js/#apply","text":"Whenever the ViewState changes, objects maybe affected. Objects do not listen to the state themselves. Whichever object changes the state must trigger the apply() method of affected objects.","title":"Apply"},{"location":"client/bymodule/","text":"About modules \u00b6 Modules support the dynamic aspects of widgets on the SHEBANQ pages. Use the navigation menu to jump to the individual modules.","title":"About modules"},{"location":"client/bymodule/#about-modules","text":"Modules support the dynamic aspects of widgets on the SHEBANQ pages. Use the navigation menu to jump to the individual modules.","title":"About modules"},{"location":"client/bymodule/chart/","text":"chart \u00b6 chart .Chart .apply() .fetch() chart.Chart \u00b6 Class for chart slection and generation Kind : static class of chart See : also the server code M:CHART . .Chart .apply() .fetch() chart.apply() \u00b6 Method for chart slection and generation Kind : instance method of Chart chart.fetch() \u00b6 get the material by AJAX if needed, and process the material afterward Kind : instance method of Chart See : Triggers C:hebrew.chart","title":"Chart"},{"location":"client/bymodule/chart/#chart","text":"chart .Chart .apply() .fetch()","title":"chart"},{"location":"client/bymodule/chart/#chartchart","text":"Class for chart slection and generation Kind : static class of chart See : also the server code M:CHART . .Chart .apply() .fetch()","title":"chart.Chart"},{"location":"client/bymodule/chart/#chartapply","text":"Method for chart slection and generation Kind : instance method of Chart","title":"chart.apply()"},{"location":"client/bymodule/chart/#chartfetch","text":"get the material by AJAX if needed, and process the material afterward Kind : instance method of Chart See : Triggers C:hebrew.chart","title":"chart.fetch()"},{"location":"client/bymodule/colorpicker/","text":"colorpicker \u00b6","title":"Colorpicker"},{"location":"client/bymodule/colorpicker/#colorpicker","text":"","title":"colorpicker"},{"location":"client/bymodule/diagnostics/","text":"diagnostics \u00b6","title":"Diagnostics"},{"location":"client/bymodule/diagnostics/#diagnostics","text":"","title":"diagnostics"},{"location":"client/bymodule/featuresettings/","text":"featuresettings \u00b6","title":"Featuresettings"},{"location":"client/bymodule/featuresettings/#featuresettings","text":"","title":"featuresettings"},{"location":"client/bymodule/helpers/","text":"helpers \u00b6","title":"Helpers"},{"location":"client/bymodule/helpers/#helpers","text":"","title":"helpers"},{"location":"client/bymodule/localstorage/","text":"localstorage \u00b6","title":"Localstorage"},{"location":"client/bymodule/localstorage/#localstorage","text":"","title":"localstorage"},{"location":"client/bymodule/main/","text":"main \u00b6","title":"Main"},{"location":"client/bymodule/main/#main","text":"","title":"main"},{"location":"client/bymodule/material/","text":"material \u00b6 material .Material .fetch() .addVerseRefs() material.Material \u00b6 Controls the main area of the page. Kind : static class of material .Material .fetch() .addVerseRefs() material.fetch() \u00b6 get the material by AJAX if needed, and process the material afterward Kind : instance method of Material See : Triggers C:hebrew.material material.addVerseRefs() \u00b6 add a click event to the verse number by which linguistic features for the words in that verse can be retrieved from the server. Kind : instance method of Material See : Triggers C:hebrew.verse .","title":"Material"},{"location":"client/bymodule/material/#material","text":"material .Material .fetch() .addVerseRefs()","title":"material"},{"location":"client/bymodule/material/#materialmaterial","text":"Controls the main area of the page. Kind : static class of material .Material .fetch() .addVerseRefs()","title":"material.Material"},{"location":"client/bymodule/material/#materialfetch","text":"get the material by AJAX if needed, and process the material afterward Kind : instance method of Material See : Triggers C:hebrew.material","title":"material.fetch()"},{"location":"client/bymodule/material/#materialaddverserefs","text":"add a click event to the verse number by which linguistic features for the words in that verse can be retrieved from the server. Kind : instance method of Material See : Triggers C:hebrew.verse .","title":"material.addVerseRefs()"},{"location":"client/bymodule/materialcontent/","text":"materialcontent \u00b6","title":"Materialcontent"},{"location":"client/bymodule/materialcontent/#materialcontent","text":"","title":"materialcontent"},{"location":"client/bymodule/materialsettings/","text":"materialsettings \u00b6","title":"Materialsettings"},{"location":"client/bymodule/materialsettings/#materialsettings","text":"","title":"materialsettings"},{"location":"client/bymodule/message/","text":"message \u00b6","title":"Message"},{"location":"client/bymodule/message/#message","text":"","title":"message"},{"location":"client/bymodule/notes/","text":"notes \u00b6 notes static .Notes inner ~NoteVerse .fetch() .sendnotes() notes.Notes \u00b6 Controls notes on text pages Kind : static class of notes See : [notetree] for the notes overview page. notes~NoteVerse \u00b6 Controls the notes belonging to a single verse. Kind : inner class of notes ~NoteVerse .fetch() .sendnotes() noteVerse.fetch() \u00b6 get the notes belonging to the current verse. Kind : instance method of NoteVerse See : Triggers C:hebrew.getversenotes noteVerse.sendnotes() \u00b6 sends edited notes to the server in order to be saved. Kind : instance method of NoteVerse See : Triggers C:hebrew.putversenotes","title":"Notes"},{"location":"client/bymodule/notes/#notes","text":"notes static .Notes inner ~NoteVerse .fetch() .sendnotes()","title":"notes"},{"location":"client/bymodule/notes/#notesnotes","text":"Controls notes on text pages Kind : static class of notes See : [notetree] for the notes overview page.","title":"notes.Notes"},{"location":"client/bymodule/notes/#notesnoteverse","text":"Controls the notes belonging to a single verse. Kind : inner class of notes ~NoteVerse .fetch() .sendnotes()","title":"notes~NoteVerse"},{"location":"client/bymodule/notes/#noteversefetch","text":"get the notes belonging to the current verse. Kind : instance method of NoteVerse See : Triggers C:hebrew.getversenotes","title":"noteVerse.fetch()"},{"location":"client/bymodule/notes/#noteversesendnotes","text":"sends edited notes to the server in order to be saved. Kind : instance method of NoteVerse See : Triggers C:hebrew.putversenotes","title":"noteVerse.sendnotes()"},{"location":"client/bymodule/notetree/","text":"notetree \u00b6 notetree ~Tree new Tree() ~Upload .submit() notetree~Tree \u00b6 Handles the tree of note sets Kind : inner class of notetree See : Triggers C:hebrew.notetree new Tree() \u00b6 Initializes the notes tree Stores a url to fetch content from the server. notetree~Upload \u00b6 Controls the bulk-uploading of notes Kind : inner class of notetree upload.submit() \u00b6 Submits a csv file with notes to the server Kind : instance method of Upload See : Triggers C:hebrew.noteupload .","title":"Notetree"},{"location":"client/bymodule/notetree/#notetree","text":"notetree ~Tree new Tree() ~Upload .submit()","title":"notetree"},{"location":"client/bymodule/notetree/#notetreetree","text":"Handles the tree of note sets Kind : inner class of notetree See : Triggers C:hebrew.notetree","title":"notetree~Tree"},{"location":"client/bymodule/notetree/#new-tree","text":"Initializes the notes tree Stores a url to fetch content from the server.","title":"new Tree()"},{"location":"client/bymodule/notetree/#notetreeupload","text":"Controls the bulk-uploading of notes Kind : inner class of notetree","title":"notetree~Upload"},{"location":"client/bymodule/notetree/#uploadsubmit","text":"Submits a csv file with notes to the server Kind : instance method of Upload See : Triggers C:hebrew.noteupload .","title":"upload.submit()"},{"location":"client/bymodule/page/","text":"page \u00b6","title":"Page"},{"location":"client/bymodule/page/#page","text":"","title":"page"},{"location":"client/bymodule/queryrecent/","text":"queryrecent \u00b6 queryrecent .QueryRecent .fetch() queryrecent.QueryRecent \u00b6 Controls the widget for recent queries on the query overview page. Kind : static class of queryrecent queryRecent.fetch() \u00b6 get the material by AJAX if needed, and process the material afterward Kind : instance method of QueryRecent See : Triggers C:hebrew.queriesr","title":"Queryrecent"},{"location":"client/bymodule/queryrecent/#queryrecent","text":"queryrecent .QueryRecent .fetch()","title":"queryrecent"},{"location":"client/bymodule/queryrecent/#queryrecentqueryrecent","text":"Controls the widget for recent queries on the query overview page. Kind : static class of queryrecent","title":"queryrecent.QueryRecent"},{"location":"client/bymodule/queryrecent/#queryrecentfetch","text":"get the material by AJAX if needed, and process the material afterward Kind : instance method of QueryRecent See : Triggers C:hebrew.queriesr","title":"queryRecent.fetch()"},{"location":"client/bymodule/querytree/","text":"querytree \u00b6 querytree ~Tree new Tree() .record() querytree~Tree \u00b6 Handles the tree of queries Kind : inner class of querytree See : Triggers C:hebrew.querytree ~Tree new Tree() .record() new Tree() \u00b6 Initializes the query tree Stores a url to fetch content from the server. tree.record() \u00b6 Sends a record to the database to be saved Kind : instance method of Tree See : Triggers C:hebrew.itemrecord","title":"Querytree"},{"location":"client/bymodule/querytree/#querytree","text":"querytree ~Tree new Tree() .record()","title":"querytree"},{"location":"client/bymodule/querytree/#querytreetree","text":"Handles the tree of queries Kind : inner class of querytree See : Triggers C:hebrew.querytree ~Tree new Tree() .record()","title":"querytree~Tree"},{"location":"client/bymodule/querytree/#new-tree","text":"Initializes the query tree Stores a url to fetch content from the server.","title":"new Tree()"},{"location":"client/bymodule/querytree/#treerecord","text":"Sends a record to the database to be saved Kind : instance method of Tree See : Triggers C:hebrew.itemrecord","title":"tree.record()"},{"location":"client/bymodule/select/","text":"select \u00b6","title":"Select"},{"location":"client/bymodule/select/#select","text":"","title":"select"},{"location":"client/bymodule/share/","text":"share \u00b6","title":"Share"},{"location":"client/bymodule/share/#share","text":"","title":"share"},{"location":"client/bymodule/sidebars/","text":"sidebars \u00b6","title":"Sidebars"},{"location":"client/bymodule/sidebars/#sidebars","text":"","title":"sidebars"},{"location":"client/bymodule/sidecontent/","text":"sidecontent \u00b6 sidecontent .SideContent .sendVal() .sendVals() .fetch() sidecontent.SideContent \u00b6 Controls the content of a side bar Kind : static class of sidecontent .SideContent .sendVal() .sendVals() .fetch() sideContent.sendVal() \u00b6 Updates a single field of a query. Meant for is_shared and is_published . Note is_shared is a field of a query record. is_published is a field of a query_exe record. Kind : instance method of SideContent See : Triggers C:hebrew.querysharing . sideContent.sendVals() \u00b6 Sends un updated record to the database. Kind : instance method of SideContent See : Triggers C:hebrew.queryupdate . sideContent.fetch() \u00b6 get the material by AJAX if needed, and process the material afterward This method takes into account what kind of sidebar this is: Kind : instance method of SideContent See Triggers C:hebrew.sidematerial Triggers C:hebrew.sideword Triggers C:hebrew.sidequery Triggers C:hebrew.sidenote","title":"Sidecontent"},{"location":"client/bymodule/sidecontent/#sidecontent","text":"sidecontent .SideContent .sendVal() .sendVals() .fetch()","title":"sidecontent"},{"location":"client/bymodule/sidecontent/#sidecontentsidecontent","text":"Controls the content of a side bar Kind : static class of sidecontent .SideContent .sendVal() .sendVals() .fetch()","title":"sidecontent.SideContent"},{"location":"client/bymodule/sidecontent/#sidecontentsendval","text":"Updates a single field of a query. Meant for is_shared and is_published . Note is_shared is a field of a query record. is_published is a field of a query_exe record. Kind : instance method of SideContent See : Triggers C:hebrew.querysharing .","title":"sideContent.sendVal()"},{"location":"client/bymodule/sidecontent/#sidecontentsendvals","text":"Sends un updated record to the database. Kind : instance method of SideContent See : Triggers C:hebrew.queryupdate .","title":"sideContent.sendVals()"},{"location":"client/bymodule/sidecontent/#sidecontentfetch","text":"get the material by AJAX if needed, and process the material afterward This method takes into account what kind of sidebar this is: Kind : instance method of SideContent See Triggers C:hebrew.sidematerial Triggers C:hebrew.sideword Triggers C:hebrew.sidequery Triggers C:hebrew.sidenote","title":"sideContent.fetch()"},{"location":"client/bymodule/sidesettings/","text":"sidesettings \u00b6","title":"Sidesettings"},{"location":"client/bymodule/sidesettings/#sidesettings","text":"","title":"sidesettings"},{"location":"client/bymodule/viewstate/","text":"viewstate \u00b6 viewstate .ViewState .csvUrl() viewstate.ViewState \u00b6 Handles settings that cusomise the view of the page Kind : static class of viewstate See : Corresponds to M:VIEWSETTINGS.page . viewState.csvUrl() \u00b6 Sets the precise url by which the user can request a csv download from the server. Kind : instance method of ViewState See : Triggers C:hebrew.item .","title":"Viewstate"},{"location":"client/bymodule/viewstate/#viewstate","text":"viewstate .ViewState .csvUrl()","title":"viewstate"},{"location":"client/bymodule/viewstate/#viewstateviewstate","text":"Handles settings that cusomise the view of the page Kind : static class of viewstate See : Corresponds to M:VIEWSETTINGS.page .","title":"viewstate.ViewState"},{"location":"client/bymodule/viewstate/#viewstatecsvurl","text":"Sets the precise url by which the user can request a csv download from the server. Kind : instance method of ViewState See : Triggers C:hebrew.item .","title":"viewState.csvUrl()"},{"location":"client/bymodule/words/","text":"words \u00b6","title":"Words"},{"location":"client/bymodule/words/#words","text":"","title":"words"},{"location":"deploy/computer/","text":"Computer \u00b6 This article describes the installation of SHEBANQ on your computer. This guide is written for macos computers! Linux The macos system offers a unix system under the hood, which is much like linux . Certain elements of the installation are the same under macos , linux PC, and linux server. Windows Although everything that SHEBANQ depends on also runs on Windows, I have never taken the trouble to put the whole process together in a guide, hindered as I am by not having a Windos computer. Especially the step of compiling Emdros might be a serious thing to get going. In the context of your own computer some things will be simpler than on a server. Your computer will serve SHEBANQ in your own browser, not over the internet. Motivation \u00b6 When developing SHEBANQ, the best way to inspect what happens behind the screens is to have it running on your local computer. So it is an integral part of the maintainability of SHEBANQ that you can install it locally. Preparation and information \u00b6 Before the actual installation of SHEBANQ, we need several software components. We describe what they are and what you have to do first. After that we point you to a script that completes the installation. Computer and operating system \u00b6 You have a modern Mac, running Catalina or higher. Commandline tools \u00b6 The key asset is the command-line, and on macos that is offered by the Terminal app. If you are not familiar with that, here is some reading . However, you will be doing deep system things, such as compiling software. For that, you need to boost your command-line by tools provided by Apple. It is easy but not obvious how to get those commandline tools on your computer. Here is a guide . Even here several options are given. From all those options, choose the following: From a command prompt Open the Terminal app on your mac. Give the following command: git This is an advance command, and it will trigger a prompt offering you to download and istall the commandline tools. Do it! It may take 5-10 minutes. After this, you have commands to interact with GitHub, to compile software, etc. Homebrew \u00b6 We need a package manager for macos, in order to install a mysql client later on. Install Homebrew by following the instructions on its home page and then do brew install mysql-client Python \u00b6 You need Python installed, at least 3.6.3. Preferably from python.org . After that, install the markdown module: pip3 install markdown Database \u00b6 We need the MySQL database system. We are very particular about the details of installing and configuring MySQL here. No previous MySQL on your Mac Preferably you do not have already MySQL installed. If you already have MySQL on your computer, backup your databases and remove it. After the install procedure for MySQL, you can import these backups into the new MySQL system. There are several ways to get MySQL, but only one of them works with Emdros , as I found out the hard way! You need to download the community edition . Take care to pick the download that matches the architecture of your mac ( arm64 for the newer macs, x86_64 for the usual Intel macs). and install it in the macos way (clicking on the package in your downloads folder and following instructions). Do not customise anything! And leave the root password empty. The installation process is described here , and it shows where you can control your databases. Shebanq repository \u00b6 The installation script is in the Shebanq repository, so you have to clone the repo first. We assume you do that under a directory github in your home folder. If you do not want that, you can do it somewhere else, but then you have to tweak a setting in a configuration script later. mkdir -p ~/github/etcbc cd ~/github/etcbc git clone https://github.com/etcbc/shebanq cd shebanq/scripts/computer Now we can do work. Finish MySQL configuration \u00b6 In a terminal, do this (still in the same directory as above): ./mysql.sh Then restart the terminal. Then restart the MySQL (via its preference pane in System Preferences). Now your database is fully functional for the purposes of SHEBANQ. Components \u00b6 Before you run the installation script, here is some information about what gets installed. Emdros \u00b6 Emdros is the software that makes the MQL queries possible which are so typical for SHEBANQ. It sits in the middle of your MQL queries and the MySQL database. The software is already packaged in the SHEBANQ repo. The install script will take it out, unpack it, and compile it, a lengthy process. Dynamic data \u00b6 Dynamic data is the data that is accumulated in the database of the website as a consequence of the actions of the users. Think of the user accounts and the saved queries and notes. For the local install of SHEBANQ we start fill the relevant databases with empty data. Static data \u00b6 Static data is the fixed data offered by the ETCBC: the text and linguistic features of the Hebrew Bible in several versions. That data is in the BHSA repository that we clone, and will be imported from there, a lengthy process. Web2py \u00b6 Our web framework is web2py , a Python based system to build web applications. We install it from GitHub, and after that we plug SHEBANQ into it. Web2Py comes with its own local webserver, so we do not have to set up complicated webservers such as Apache. Instead, we can rely on the built-in webserver that comes with Web2py . Run install script \u00b6 In a terminal, do this): cd ~/github/etcbc/shebanq/scripts/computer ./installmacos.sh At the end, the SHEBANQ web server will be started and a first visit to the local SHEBANQ website will be made. Starting and stopping SHEBANQ \u00b6 You stop SHEBANQ by pressing Ctrl + C in the terminal from where you started SHEBANQ. You start SHEBANQ by double-clicking on the file shebanq.command in your home folder, under Applications/SHEBANQ . not the system-wide applications folder Go to your home folder and find an applications folder in it. That is the one that contains SHEBANQ and there you find shebanq.command . shortcut You can drag this file into the side bar of the Finder. That way you have an easy shortcut to the shebanq webapp. Debugging \u00b6 When you browse shebanq, you might see messages in the terminal window, and when you change the Python code in SHEBANQ and add statements that print messages, they will show up here. Updating \u00b6 You can update SHEBANQ by doing this in a terminal cd ~/Applications/SHEBANQ ./update.sh Selective installation \u00b6 You can install individual pieces. View the options of the install script. cd ~/github/etcbc/shebanq/scripts/computer ./installmacos --help","title":"Computer"},{"location":"deploy/computer/#computer","text":"This article describes the installation of SHEBANQ on your computer. This guide is written for macos computers! Linux The macos system offers a unix system under the hood, which is much like linux . Certain elements of the installation are the same under macos , linux PC, and linux server. Windows Although everything that SHEBANQ depends on also runs on Windows, I have never taken the trouble to put the whole process together in a guide, hindered as I am by not having a Windos computer. Especially the step of compiling Emdros might be a serious thing to get going. In the context of your own computer some things will be simpler than on a server. Your computer will serve SHEBANQ in your own browser, not over the internet.","title":"Computer"},{"location":"deploy/computer/#motivation","text":"When developing SHEBANQ, the best way to inspect what happens behind the screens is to have it running on your local computer. So it is an integral part of the maintainability of SHEBANQ that you can install it locally.","title":"Motivation"},{"location":"deploy/computer/#preparation-and-information","text":"Before the actual installation of SHEBANQ, we need several software components. We describe what they are and what you have to do first. After that we point you to a script that completes the installation.","title":"Preparation and information"},{"location":"deploy/computer/#computer-and-operating-system","text":"You have a modern Mac, running Catalina or higher.","title":"Computer and operating system"},{"location":"deploy/computer/#commandline-tools","text":"The key asset is the command-line, and on macos that is offered by the Terminal app. If you are not familiar with that, here is some reading . However, you will be doing deep system things, such as compiling software. For that, you need to boost your command-line by tools provided by Apple. It is easy but not obvious how to get those commandline tools on your computer. Here is a guide . Even here several options are given. From all those options, choose the following: From a command prompt Open the Terminal app on your mac. Give the following command: git This is an advance command, and it will trigger a prompt offering you to download and istall the commandline tools. Do it! It may take 5-10 minutes. After this, you have commands to interact with GitHub, to compile software, etc.","title":"Commandline tools"},{"location":"deploy/computer/#homebrew","text":"We need a package manager for macos, in order to install a mysql client later on. Install Homebrew by following the instructions on its home page and then do brew install mysql-client","title":"Homebrew"},{"location":"deploy/computer/#python","text":"You need Python installed, at least 3.6.3. Preferably from python.org . After that, install the markdown module: pip3 install markdown","title":"Python"},{"location":"deploy/computer/#database","text":"We need the MySQL database system. We are very particular about the details of installing and configuring MySQL here. No previous MySQL on your Mac Preferably you do not have already MySQL installed. If you already have MySQL on your computer, backup your databases and remove it. After the install procedure for MySQL, you can import these backups into the new MySQL system. There are several ways to get MySQL, but only one of them works with Emdros , as I found out the hard way! You need to download the community edition . Take care to pick the download that matches the architecture of your mac ( arm64 for the newer macs, x86_64 for the usual Intel macs). and install it in the macos way (clicking on the package in your downloads folder and following instructions). Do not customise anything! And leave the root password empty. The installation process is described here , and it shows where you can control your databases.","title":"Database"},{"location":"deploy/computer/#shebanq-repository","text":"The installation script is in the Shebanq repository, so you have to clone the repo first. We assume you do that under a directory github in your home folder. If you do not want that, you can do it somewhere else, but then you have to tweak a setting in a configuration script later. mkdir -p ~/github/etcbc cd ~/github/etcbc git clone https://github.com/etcbc/shebanq cd shebanq/scripts/computer Now we can do work.","title":"Shebanq repository"},{"location":"deploy/computer/#finish-mysql-configuration","text":"In a terminal, do this (still in the same directory as above): ./mysql.sh Then restart the terminal. Then restart the MySQL (via its preference pane in System Preferences). Now your database is fully functional for the purposes of SHEBANQ.","title":"Finish MySQL configuration"},{"location":"deploy/computer/#components","text":"Before you run the installation script, here is some information about what gets installed.","title":"Components"},{"location":"deploy/computer/#emdros","text":"Emdros is the software that makes the MQL queries possible which are so typical for SHEBANQ. It sits in the middle of your MQL queries and the MySQL database. The software is already packaged in the SHEBANQ repo. The install script will take it out, unpack it, and compile it, a lengthy process.","title":"Emdros"},{"location":"deploy/computer/#dynamic-data","text":"Dynamic data is the data that is accumulated in the database of the website as a consequence of the actions of the users. Think of the user accounts and the saved queries and notes. For the local install of SHEBANQ we start fill the relevant databases with empty data.","title":"Dynamic data"},{"location":"deploy/computer/#static-data","text":"Static data is the fixed data offered by the ETCBC: the text and linguistic features of the Hebrew Bible in several versions. That data is in the BHSA repository that we clone, and will be imported from there, a lengthy process.","title":"Static data"},{"location":"deploy/computer/#web2py","text":"Our web framework is web2py , a Python based system to build web applications. We install it from GitHub, and after that we plug SHEBANQ into it. Web2Py comes with its own local webserver, so we do not have to set up complicated webservers such as Apache. Instead, we can rely on the built-in webserver that comes with Web2py .","title":"Web2py"},{"location":"deploy/computer/#run-install-script","text":"In a terminal, do this): cd ~/github/etcbc/shebanq/scripts/computer ./installmacos.sh At the end, the SHEBANQ web server will be started and a first visit to the local SHEBANQ website will be made.","title":"Run install script"},{"location":"deploy/computer/#starting-and-stopping-shebanq","text":"You stop SHEBANQ by pressing Ctrl + C in the terminal from where you started SHEBANQ. You start SHEBANQ by double-clicking on the file shebanq.command in your home folder, under Applications/SHEBANQ . not the system-wide applications folder Go to your home folder and find an applications folder in it. That is the one that contains SHEBANQ and there you find shebanq.command . shortcut You can drag this file into the side bar of the Finder. That way you have an easy shortcut to the shebanq webapp.","title":"Starting and stopping SHEBANQ"},{"location":"deploy/computer/#debugging","text":"When you browse shebanq, you might see messages in the terminal window, and when you change the Python code in SHEBANQ and add statements that print messages, they will show up here.","title":"Debugging"},{"location":"deploy/computer/#updating","text":"You can update SHEBANQ by doing this in a terminal cd ~/Applications/SHEBANQ ./update.sh","title":"Updating"},{"location":"deploy/computer/#selective-installation","text":"You can install individual pieces. View the options of the install script. cd ~/github/etcbc/shebanq/scripts/computer ./installmacos --help","title":"Selective installation"},{"location":"deploy/documentation/","text":"Documentation \u00b6 User documentation \u00b6 User guide of SHEBANQ \u00b6 How to use SHEBANQ is documented on the wiki of the SHEBANQ repository on Github . People with access can edit those pages directly in the browser, if they are logged in with GitHub. You can also clone the wiki: cd ~/github/etcbc git clone https://github.com/ETCBC/shebanq/wiki Then you can make as many edits as you like, in whatever tool you like, and save it back to the online version by cd ~/github/etcbc/shebanq.wiki git add --all . git commit \"updated docs\" git push origin master Feature documentation of the BHSA \u00b6 This is stored in the BHSA repository and published via its GitHub pages method. The source docs are in its docs directory. If you have cloned you can edit the docs locally, and then build the docs via mkdocs . You install mkdocs by pip3 install mkdocs pip3 install mkdocs-material In order to build the documentation you do cd ~/github/etcbc/bhsa mkdocs build In order to publish it, you do cd ~/github/etcbc/bhsa mkdocs gh-deploy Note that publishing will trigger a build, so if you want to publish, you can leave out the build step. Finally, you can commit the changes to the doc sources by: cd ~/github/etcbc/bhsa git add --all . git commit \"updated feature docs\" git push origin master Technical documentation \u00b6 The technical documentation of SHEBANQ is also by means of mkdocs. In order to modify it, you have to install it, and a plugin: pip3 install mkdocs pip3 install mkdocs-material pip3 install mkdocstrings You need an extra tool for Javascript documentation: npm install -g jsdoc npm install -g jsdoc-to-markdown Apart from a nest of markdown files, the documentation consists also of special comments extract from the Python and Javascript code. We get the Python docstrings by means of the mkdocs plugin mkdocstrings. We get the Javascript docstrings by means of jsdoc and jsdoc-to-markdown. We have build script to automate the maintenance steps, and it also takes care of documentation handling. Just do cd ~/github/etcbc/shebanq python3 build.py --help to look at the options, or inspect the source code . Why mkdocs? \u00b6 One of the advantages of mkdocs is that you can 'invoke' docstring documentation from within markdown files. It will then inject the formatted docstrings at that place in the documentation. That is handy, because this SHEBANQ is not a usual Python package, such as Text-Fabric is. For example, automatically building documentation for the whole SHEBANQ using pdoc3 is not possible, in contrast to Text-Fabric. A second good point is that mkdocstrings is potentially capable of doing Javascript as well. At the moment, there is not yet a handler for Javascript, so this advantage does not yet materialize. But still ... We extract the Javascript documentation using jsdoc(to markdown) and dump it into our source docs folder. From there it will be seen by mkdocs, and formatted with the other stuff. And the excellent thing is the autorefs plugin of mkdocs, by which we can easily cross-reference between all doc sources. That means that we can put a reference to a Javascript class right in the docstring of a Python class, and vice versa .","title":"Documentation"},{"location":"deploy/documentation/#documentation","text":"","title":"Documentation"},{"location":"deploy/documentation/#user-documentation","text":"","title":"User documentation"},{"location":"deploy/documentation/#user-guide-of-shebanq","text":"How to use SHEBANQ is documented on the wiki of the SHEBANQ repository on Github . People with access can edit those pages directly in the browser, if they are logged in with GitHub. You can also clone the wiki: cd ~/github/etcbc git clone https://github.com/ETCBC/shebanq/wiki Then you can make as many edits as you like, in whatever tool you like, and save it back to the online version by cd ~/github/etcbc/shebanq.wiki git add --all . git commit \"updated docs\" git push origin master","title":"User guide of SHEBANQ"},{"location":"deploy/documentation/#feature-documentation-of-the-bhsa","text":"This is stored in the BHSA repository and published via its GitHub pages method. The source docs are in its docs directory. If you have cloned you can edit the docs locally, and then build the docs via mkdocs . You install mkdocs by pip3 install mkdocs pip3 install mkdocs-material In order to build the documentation you do cd ~/github/etcbc/bhsa mkdocs build In order to publish it, you do cd ~/github/etcbc/bhsa mkdocs gh-deploy Note that publishing will trigger a build, so if you want to publish, you can leave out the build step. Finally, you can commit the changes to the doc sources by: cd ~/github/etcbc/bhsa git add --all . git commit \"updated feature docs\" git push origin master","title":"Feature documentation of the BHSA"},{"location":"deploy/documentation/#technical-documentation","text":"The technical documentation of SHEBANQ is also by means of mkdocs. In order to modify it, you have to install it, and a plugin: pip3 install mkdocs pip3 install mkdocs-material pip3 install mkdocstrings You need an extra tool for Javascript documentation: npm install -g jsdoc npm install -g jsdoc-to-markdown Apart from a nest of markdown files, the documentation consists also of special comments extract from the Python and Javascript code. We get the Python docstrings by means of the mkdocs plugin mkdocstrings. We get the Javascript docstrings by means of jsdoc and jsdoc-to-markdown. We have build script to automate the maintenance steps, and it also takes care of documentation handling. Just do cd ~/github/etcbc/shebanq python3 build.py --help to look at the options, or inspect the source code .","title":"Technical documentation"},{"location":"deploy/documentation/#why-mkdocs","text":"One of the advantages of mkdocs is that you can 'invoke' docstring documentation from within markdown files. It will then inject the formatted docstrings at that place in the documentation. That is handy, because this SHEBANQ is not a usual Python package, such as Text-Fabric is. For example, automatically building documentation for the whole SHEBANQ using pdoc3 is not possible, in contrast to Text-Fabric. A second good point is that mkdocstrings is potentially capable of doing Javascript as well. At the moment, there is not yet a handler for Javascript, so this advantage does not yet materialize. But still ... We extract the Javascript documentation using jsdoc(to markdown) and dump it into our source docs folder. From there it will be seen by mkdocs, and formatted with the other stuff. And the excellent thing is the autorefs plugin of mkdocs, by which we can easily cross-reference between all doc sources. That means that we can put a reference to a Javascript class right in the docstring of a Python class, and vice versa .","title":"Why mkdocs?"},{"location":"deploy/maintenance/","text":"Installation and maintenance \u00b6 Motivation \u00b6 The promise of SHEBANQ to its users is that the queries and notes they have saved on SHEBANQ will be accessible by a fixed URL for the indefinite future. Therefore it is vitally important to backup this data and store those backups in a variety of places, not only on the server that hosts SHEBANQ, however well that server is being managed. The following tasks must be addressed: Server migration Servers do not have eternal life, so every now and then SHEBANQ has to migrate from one server to another. 'Foreign' servers We encourage people to host their own SHEBANQ, so we must support new installations on third party servers. Those servers must be equally maintainable as the offical servers. Software updates In order to keep SHEBANQ alive over the years, software updates must be carried out, not only of the webapp, but also of its supporting systems, Emdros , Web2Py , Python , and MariaDB (a replacement of MySQL ). Data updates The ETCBC , as the provider of the textual and linguistic data of the Hebrew Bible, produces data updates through its BHSA repository. These data updates must be applied to the servers that host SHEBANQ. There are some additional requirements which are vital for the long-term support of SHEBANQ. Security SHEBANQ servers should be secure. They must be hardened against attacks, and the user data must be kept safe, even if only the bare minimum of personal data is stored (names, email addresses, password hashes). Automation Maintaining a server requires countless nitty-gritty steps, which are easily forgotten. That is the prime reason to automate all these steps. People that are new to SHEBANQ should be able to maintain SHEBANQ in a straightforward way. Documentation The maintenance of SHEBANQ should be well documented . Together with automation it is the best help we can offer to the maintainers of SHEBANQ in the years to come. Operation \u00b6 SHEBANQ has a build script by which you can take care of a few standard maintenance tasks: documentation building and publishing committing changes to GitHub Just do cd ~/github/etcbc/shebanq python3 build.py --help to look at the options, or inspect the source code . Shell function Write a shell function and put it into your .zshrc or bashrc like this function shb { cd ~/github/etcbc/shebanq python3 build.py \"$@\" } now you can run shb (i.e. shebanq-build) from any directory.","title":"Installation and maintenance"},{"location":"deploy/maintenance/#installation-and-maintenance","text":"","title":"Installation and maintenance"},{"location":"deploy/maintenance/#motivation","text":"The promise of SHEBANQ to its users is that the queries and notes they have saved on SHEBANQ will be accessible by a fixed URL for the indefinite future. Therefore it is vitally important to backup this data and store those backups in a variety of places, not only on the server that hosts SHEBANQ, however well that server is being managed. The following tasks must be addressed: Server migration Servers do not have eternal life, so every now and then SHEBANQ has to migrate from one server to another. 'Foreign' servers We encourage people to host their own SHEBANQ, so we must support new installations on third party servers. Those servers must be equally maintainable as the offical servers. Software updates In order to keep SHEBANQ alive over the years, software updates must be carried out, not only of the webapp, but also of its supporting systems, Emdros , Web2Py , Python , and MariaDB (a replacement of MySQL ). Data updates The ETCBC , as the provider of the textual and linguistic data of the Hebrew Bible, produces data updates through its BHSA repository. These data updates must be applied to the servers that host SHEBANQ. There are some additional requirements which are vital for the long-term support of SHEBANQ. Security SHEBANQ servers should be secure. They must be hardened against attacks, and the user data must be kept safe, even if only the bare minimum of personal data is stored (names, email addresses, password hashes). Automation Maintaining a server requires countless nitty-gritty steps, which are easily forgotten. That is the prime reason to automate all these steps. People that are new to SHEBANQ should be able to maintain SHEBANQ in a straightforward way. Documentation The maintenance of SHEBANQ should be well documented . Together with automation it is the best help we can offer to the maintainers of SHEBANQ in the years to come.","title":"Motivation"},{"location":"deploy/maintenance/#operation","text":"SHEBANQ has a build script by which you can take care of a few standard maintenance tasks: documentation building and publishing committing changes to GitHub Just do cd ~/github/etcbc/shebanq python3 build.py --help to look at the options, or inspect the source code . Shell function Write a shell function and put it into your .zshrc or bashrc like this function shb { cd ~/github/etcbc/shebanq python3 build.py \"$@\" } now you can run shb (i.e. shebanq-build) from any directory.","title":"Operation"},{"location":"deploy/server/","text":"Server \u00b6 This article describes the installation and maintenance of SHEBANQ of a secure RedHat Fedora linux server. Ubuntu If you prefer Ubuntu, that should be easier. You need to change a few things: yum becomes apt-get , the names of installation packages might be slightly different. You can leave out typical selinux commands such as chcon and setsebool . Various locations maybe a little bit different. Tools \u00b6 This repository contains a set of shell scripts to perform installation and maintenance tasks on SHEBANQ servers. It also has most of the assets needed for installation. The remaining assets are available through the BHSA repository. Requirements Read first to the end of this document, and take note of the requirements . SELINUX might not be the most obvious choice to host SHEBANQ on, because it is considerably more difficult to work with than Ubuntu. However, there are a few key advantages you enjoy after the installation: prime security You have SHEBANQ running on a top-notch secure system. head-ache-free software updates Much of supporting software (Python, MySQL, Apache) can be updated without the risk of breaking things, because the current versions of them are supported for an extra long time. Often, new security updates are back-ported to older versions, so that you can avoid upgrading to newer but incompatible versions. The latter advantage is quite convenient for SHEBANQ, because the Emdros software is compiled against de MySQL libraries. So when MySQL is upgraded to a new version, Emdros has to be recompiled. And that is something we do not want to do too often. Requirements \u00b6 Server \u00b6 The server on which SHEBANQ is installed is a Security Enhanced Linux Server (SELINUX) . You must be able to access this server by means of ssh and scp , using a certificate , so that you are not prompted for passwords. You must have sudo rights on this server. We assume that the Apache webserver is already installed and: its config files reside in /etc/httpd ; the relevant certificates are installed in /etc/pki/tls/certs and /etc/pki/tls/private mod_wsgi is not yet installed. We assume that the following packages can be installed with yum . That means that you must have the right package repositories enabled. python36 python36-devel python3-markdown mod_wsgi mariadb mariadb-devel mariadb-server Local computer \u00b6 You have cloned the shebanq and bhsa repositories from Github to your local computer: cd ~/github/etcbc git clone https://github.com/etcbc/shebanq git clone https://github.com/etcbc/bhsa If you have cloned these long ago, you can make them up to date by pulling them again: cd ~/github/etcbc/shebanq git pull origin master cd ~/github/etcbc/bhsa git pull origin master You can choose to place the github directory somewhere else, see below, but the structure within the github directory must be as prescribed. The _local directory \u00b6 The scripts in ~/github/etcbc/scripts/maintenance have generic content. Before working with it, the file configtemplate must be edited to reflect your actual situation. Do this as follows: cd ~/github/etcbc/shebanq/scripts/maintenance ./localize.sh Now you have a directory ~/github/etcbc/shebanq/_local And the command tells you what to do next: copy configtemplate.sh to config.sh edit config.sh What needs to be done is: adapt the serverOther variables to your situation: provide the name of the database host server (typically: localhost) provide passwords for mysql users named shebanq and shebanq_admin ; these users will be created and later in the installation process shebanq_admin is used for importing data, and after installation the webapp will use shebanq to fetch data in response to requests by web users. provide the locations where the https-certificates are installed in Apache; these will be used in in the httpd config file for the webapp. The _local directory is never pushed online (because of the .gitignore file in the shebanq repo), so your local setup remains private. Also, when you tweak files in your _local directory, you can still pull new versions of the shebanq repository without overwriting your local changes. When you run a maintenance script, you should run them from this _local directory, to be sure that you run your adapted version. These local files are also the ones that are sent to the server in the provisioning step below. The scripts can be run from any directory, because they do not depend on the current working directory. The scripts \u00b6 The originals of the maintenance scripts are in the shebanq repository in the scripts/maintenance directory. In the previous step you have copied them to the _local directory. You can run all scripts with --help to view the options and arguments it accepts. backup.sh Run it on the server. Backs up the databases that have dynamic web data: shebanq_web shebanq_note save.sh Run it on your local computer. It will retrieve data from the server. Saves backups of dynamic web data from the shebanq server to a directory on your local computer where you hold backups. The backup is saved in a subfolder yyyy-mm-ddT-hh-mm-ss (the datetime of the backup). provision.sh Run it on your local computer. It will send data to the server. Copies all files needed for installation from your local computer to the shebanq server. These files end up in shebanq-install under your home directory there. The maintenance scripts themselves will be copied over from your _local directory to your home directory on the server. The latest backup of dynamic data from will be taken from your local computer and copied over to the server. You can run this script in single steps by passing an option. install.sh Run it on the server. Installs required software (MySQL, Python, ModWsgi, Emdros, Web2py, and Shebanq itself) and loads data into the databases. You can run this script in single steps by passing an option. uninstall.sh Run it on the server. Uninstalls what install.sh has installed. You can run this script in single steps by passing an option. restore.sh Run it on the server. Restores the databases that have dynamic web data: shebanq_web shebanq_note They are restored from a previous backup. update.sh Run it on the server. Updates the shebanq webapp, i.e. the web-app as it is hung into the web2py framework. The situations \u00b6 There are several situations, depending on the server that hosts SHEBANQ: Production p url: shebanq.ancient-data.org hosted by DANS on a KNAW server publicly accessible, the one and only offical shebanq website Production (new) pn url: not yet shebanq.ancient-data.org hosted by DANS on a KNAW server, as a successor of the current production server not yet publicly accessible, not yet the one and only offical shebanq website Test t url: test.shebanq.ancient-data.org hosted by DANS on a KNAW server only accessible from within the DANS-KNAW network the one and only offical shebanq test website Other o url: to be configured by you hosted on your server access managed by you an unoffical shebanq website (very welcome, thanks for taking the trouble) Other (new) on url: to be configured by you hosted on your new server, as a successor to your current server access managed by you an unoffical shebanq website The scenarios \u00b6 The maintenance scripts can be used in several identified scenarios, which we spell out below. In all situations, when on the server, you must sudo the invocations of the scripts or run them as root. It might be the case, especially on production servers, that you do not have general sudo rights and that the script as a whole can not be run with root privileges. In that case you need to have rights for specific commands to run them under sudo. That is why in some scripts the word sudo still appears. If it does not work for your situation, you can tweak your local copy of the script. Install SHEBANQ on a new server \u00b6 Situation Other (first time) \u00b6 This is likely your case: you want to install SHEBANQ on a server of your choice. For the sake of simplicity we assume that the database resides on the server itself and we will transport and import all data needed. We assume that this there is no previous dynamic data to be imported. (local computer) ./provision.sh o upload all needed installation files to the server; there will also be (big) data transfers of the static databases. (server) ./install.sh perform the complete installation of shebanq Arrange with your internet provider to let the domain name point to the IP address of the server Other (migrating) \u00b6 You have a server with SHEBANQ running and want to migrate to a new server. (current server) ./backup.sh make a backup of user data (local computer) ./save.sh o save backup to local computer (local computer) ./provision.sh on upload all needed installation files to the server; the backup of the current server will be imported; there will also be (big) data transfers of the static databases. (new server) ./install.sh perform the complete installation of shebanq Arrange with your internet provider to let the domain name point to the IP address of the new server (local computer) Tweak config.sh and put the name of the new server into serverOther . Test \u00b6 The database resides on the test server itself, data operations will be performed. (production server) ./backup.sh make a backup of user data (only to get meaningful content in the databases) (local computer) ./save.sh p save backup to local computer (only to get meaningful content in the databases) (local computer) ./provision.sh t upload all needed installation files to the server; there will also be (big) data transfers of the static databases. (test server) ./install.sh perform the complete installation of shebanq Production (migrating) \u00b6 The database resides on a separate database server, no data operations needed. (current production server) ./backup.sh make a backup of user data (only for safety, if all goes well, we do not need it) (local computer) ./save.sh p save backup from current production server to local computer (only for safety, if all goes well, we do not need it) (local computer) ./provision.sh pn upload all needed installation files to the new production server; the static database files will be skipped. (new production server) ./install.sh perform the complete installation of shebanq Arrange with your internet provider to let the domain name point to the IP address of the new production server (local computer) Tweak config.sh and put the name of the new production server into serverProd . Update SHEBANQ on an existing server \u00b6 This works the same in all situations. We give the steps for the other situation, which is most likely your situation. In all situations, when on the server, you must sudo the invocations of the scripts or run them as root. SHEBANQ code only \u00b6 Do this when you noticed that the SHEBANQ repo has updates. (server) update.sh Pull the SHEBANQ repository from GitHUb That's all. Simple and quick. A version of the static data \u00b6 Do this when a new version of the etcbc data is released or an existing version has got an update. These databases are released through the etcbc/bhsa repository on GitHub, in the directory shebanq . You have them in your local clone of the BHSA. Below, version is the desired data version that you want to import, such as 4 , 4b , c , 2017 , 2021 . (local computer) git pull origin master Do this in your clone of the BHSA repository. And then again in your clone of the SHEBANQ repository (local computer) ./provision.sh o --static version upload all needed data files files to the server; (server) install.sh --static version This imports both the shebanq_passage and shebanq_etcbc databases of that version. Emdros \u00b6 Do this when you noticed that there is a new version of Emdros. In that case, the SHEBANQ repository contains all that is necessary. (local computer) git pull origin master Do this in your clone of the SHEBANQ repository. (local computer) Tweak config.sh Adapt the EMDROS_VERSION variable so that it reflects the Emdros version in question. (local computer) ./provision.sh o --emdros Only transfer the new Emdros distribution. (server) ./install.sh --emdros Install Emdros only. (server) update.sh Pull the SHEBANQ repository from GitHUb Web2py \u00b6 Do this when you noticed that there is a new version of Web2py and if you are sure that it does not break SHEBANQ. In that case, the SHEBANQ repository contains all that is necessary. (local computer) git pull origin master Do this in your clone of the SHEBANQ repository. (local computer) ./provision.sh o --web2py Only transfer the new Web2py distribution. (server) ./install.sh --web2py Install Web2py only. (server) update.sh Pull the SHEBANQ repository from GitHUb Maintain backups of dynamic data \u00b6 The dynamic data of SHEBANQ is stored in two databases: shebanq_web : user data: names and email addresses and password hashes of registered users. query data: meta data and results of queries that have been saved in shebanq shebanq_note : note data: metadata and content of all notes that have been saved in SHEBANQ. Currently, I make occasional backups of the production SHEBANQ and store them on my local computer, which is backed up in multiple ways, offline and online. Backup dynamic data \u00b6 (server) ./backup.sh This will create a fresh backup of the dynamic data and store it on the server in a folder with a time-stamped name. Also, a symbolic link under the name latest will link to that backup. (local computer) ./save.sh o This will fetch the latest backup from the server to your local computer. It will end up in your backup directory there, under the same time-stamped name, and also with a latest link. Restore dynamic data \u00b6 In cases where a server has crashed and data has been lost, it is necessary to restore the latest known dynamic data. (local computer) ./provision.sh o --dynamic This will find the latest dynamic data backup of the server that exists on your local computer and upload it to the server. (server) ./restore.sh This will find the latest dynamic data backup that exists on the server and import it to the databases. Mixing backups If you maintain multiple servers from your local computers, the backups of all these servers end up in the same place. Production and test backups are kept separate In order to avoid the risk of restoring a backup made on the test server to the production server, backups made on a test server are stored in a different directory. When backups are restored, they will never be taken from this directory, not even when restoring on the test server. If you do need to restore a test backup on the test server, you have to manually copy it over to the right place. The same holds for backups that come from the serverOtherNew and serverProdNew servers. These backups have no importance except for testing the processes, so they will be stored in the alternative place. Trouble shooting \u00b6 It is very difficult to view messages issued by Python code. So far, I have not been able to view them anywhere in the log files. The recommended practice is to install Web2Py and SHEBANQ on your local computer, and debug it there.","title":"Server"},{"location":"deploy/server/#server","text":"This article describes the installation and maintenance of SHEBANQ of a secure RedHat Fedora linux server. Ubuntu If you prefer Ubuntu, that should be easier. You need to change a few things: yum becomes apt-get , the names of installation packages might be slightly different. You can leave out typical selinux commands such as chcon and setsebool . Various locations maybe a little bit different.","title":"Server"},{"location":"deploy/server/#tools","text":"This repository contains a set of shell scripts to perform installation and maintenance tasks on SHEBANQ servers. It also has most of the assets needed for installation. The remaining assets are available through the BHSA repository. Requirements Read first to the end of this document, and take note of the requirements . SELINUX might not be the most obvious choice to host SHEBANQ on, because it is considerably more difficult to work with than Ubuntu. However, there are a few key advantages you enjoy after the installation: prime security You have SHEBANQ running on a top-notch secure system. head-ache-free software updates Much of supporting software (Python, MySQL, Apache) can be updated without the risk of breaking things, because the current versions of them are supported for an extra long time. Often, new security updates are back-ported to older versions, so that you can avoid upgrading to newer but incompatible versions. The latter advantage is quite convenient for SHEBANQ, because the Emdros software is compiled against de MySQL libraries. So when MySQL is upgraded to a new version, Emdros has to be recompiled. And that is something we do not want to do too often.","title":"Tools"},{"location":"deploy/server/#requirements","text":"","title":"Requirements"},{"location":"deploy/server/#server_1","text":"The server on which SHEBANQ is installed is a Security Enhanced Linux Server (SELINUX) . You must be able to access this server by means of ssh and scp , using a certificate , so that you are not prompted for passwords. You must have sudo rights on this server. We assume that the Apache webserver is already installed and: its config files reside in /etc/httpd ; the relevant certificates are installed in /etc/pki/tls/certs and /etc/pki/tls/private mod_wsgi is not yet installed. We assume that the following packages can be installed with yum . That means that you must have the right package repositories enabled. python36 python36-devel python3-markdown mod_wsgi mariadb mariadb-devel mariadb-server","title":"Server"},{"location":"deploy/server/#local-computer","text":"You have cloned the shebanq and bhsa repositories from Github to your local computer: cd ~/github/etcbc git clone https://github.com/etcbc/shebanq git clone https://github.com/etcbc/bhsa If you have cloned these long ago, you can make them up to date by pulling them again: cd ~/github/etcbc/shebanq git pull origin master cd ~/github/etcbc/bhsa git pull origin master You can choose to place the github directory somewhere else, see below, but the structure within the github directory must be as prescribed.","title":"Local computer"},{"location":"deploy/server/#the-_local-directory","text":"The scripts in ~/github/etcbc/scripts/maintenance have generic content. Before working with it, the file configtemplate must be edited to reflect your actual situation. Do this as follows: cd ~/github/etcbc/shebanq/scripts/maintenance ./localize.sh Now you have a directory ~/github/etcbc/shebanq/_local And the command tells you what to do next: copy configtemplate.sh to config.sh edit config.sh What needs to be done is: adapt the serverOther variables to your situation: provide the name of the database host server (typically: localhost) provide passwords for mysql users named shebanq and shebanq_admin ; these users will be created and later in the installation process shebanq_admin is used for importing data, and after installation the webapp will use shebanq to fetch data in response to requests by web users. provide the locations where the https-certificates are installed in Apache; these will be used in in the httpd config file for the webapp. The _local directory is never pushed online (because of the .gitignore file in the shebanq repo), so your local setup remains private. Also, when you tweak files in your _local directory, you can still pull new versions of the shebanq repository without overwriting your local changes. When you run a maintenance script, you should run them from this _local directory, to be sure that you run your adapted version. These local files are also the ones that are sent to the server in the provisioning step below. The scripts can be run from any directory, because they do not depend on the current working directory.","title":"The _local directory"},{"location":"deploy/server/#the-scripts","text":"The originals of the maintenance scripts are in the shebanq repository in the scripts/maintenance directory. In the previous step you have copied them to the _local directory. You can run all scripts with --help to view the options and arguments it accepts. backup.sh Run it on the server. Backs up the databases that have dynamic web data: shebanq_web shebanq_note save.sh Run it on your local computer. It will retrieve data from the server. Saves backups of dynamic web data from the shebanq server to a directory on your local computer where you hold backups. The backup is saved in a subfolder yyyy-mm-ddT-hh-mm-ss (the datetime of the backup). provision.sh Run it on your local computer. It will send data to the server. Copies all files needed for installation from your local computer to the shebanq server. These files end up in shebanq-install under your home directory there. The maintenance scripts themselves will be copied over from your _local directory to your home directory on the server. The latest backup of dynamic data from will be taken from your local computer and copied over to the server. You can run this script in single steps by passing an option. install.sh Run it on the server. Installs required software (MySQL, Python, ModWsgi, Emdros, Web2py, and Shebanq itself) and loads data into the databases. You can run this script in single steps by passing an option. uninstall.sh Run it on the server. Uninstalls what install.sh has installed. You can run this script in single steps by passing an option. restore.sh Run it on the server. Restores the databases that have dynamic web data: shebanq_web shebanq_note They are restored from a previous backup. update.sh Run it on the server. Updates the shebanq webapp, i.e. the web-app as it is hung into the web2py framework.","title":"The scripts"},{"location":"deploy/server/#the-situations","text":"There are several situations, depending on the server that hosts SHEBANQ: Production p url: shebanq.ancient-data.org hosted by DANS on a KNAW server publicly accessible, the one and only offical shebanq website Production (new) pn url: not yet shebanq.ancient-data.org hosted by DANS on a KNAW server, as a successor of the current production server not yet publicly accessible, not yet the one and only offical shebanq website Test t url: test.shebanq.ancient-data.org hosted by DANS on a KNAW server only accessible from within the DANS-KNAW network the one and only offical shebanq test website Other o url: to be configured by you hosted on your server access managed by you an unoffical shebanq website (very welcome, thanks for taking the trouble) Other (new) on url: to be configured by you hosted on your new server, as a successor to your current server access managed by you an unoffical shebanq website","title":"The situations"},{"location":"deploy/server/#the-scenarios","text":"The maintenance scripts can be used in several identified scenarios, which we spell out below. In all situations, when on the server, you must sudo the invocations of the scripts or run them as root. It might be the case, especially on production servers, that you do not have general sudo rights and that the script as a whole can not be run with root privileges. In that case you need to have rights for specific commands to run them under sudo. That is why in some scripts the word sudo still appears. If it does not work for your situation, you can tweak your local copy of the script.","title":"The scenarios"},{"location":"deploy/server/#install-shebanq-on-a-new-server","text":"","title":"Install SHEBANQ on a new server"},{"location":"deploy/server/#situation-other-first-time","text":"This is likely your case: you want to install SHEBANQ on a server of your choice. For the sake of simplicity we assume that the database resides on the server itself and we will transport and import all data needed. We assume that this there is no previous dynamic data to be imported. (local computer) ./provision.sh o upload all needed installation files to the server; there will also be (big) data transfers of the static databases. (server) ./install.sh perform the complete installation of shebanq Arrange with your internet provider to let the domain name point to the IP address of the server","title":"Situation Other (first time)"},{"location":"deploy/server/#other-migrating","text":"You have a server with SHEBANQ running and want to migrate to a new server. (current server) ./backup.sh make a backup of user data (local computer) ./save.sh o save backup to local computer (local computer) ./provision.sh on upload all needed installation files to the server; the backup of the current server will be imported; there will also be (big) data transfers of the static databases. (new server) ./install.sh perform the complete installation of shebanq Arrange with your internet provider to let the domain name point to the IP address of the new server (local computer) Tweak config.sh and put the name of the new server into serverOther .","title":"Other (migrating)"},{"location":"deploy/server/#test","text":"The database resides on the test server itself, data operations will be performed. (production server) ./backup.sh make a backup of user data (only to get meaningful content in the databases) (local computer) ./save.sh p save backup to local computer (only to get meaningful content in the databases) (local computer) ./provision.sh t upload all needed installation files to the server; there will also be (big) data transfers of the static databases. (test server) ./install.sh perform the complete installation of shebanq","title":"Test"},{"location":"deploy/server/#production-migrating","text":"The database resides on a separate database server, no data operations needed. (current production server) ./backup.sh make a backup of user data (only for safety, if all goes well, we do not need it) (local computer) ./save.sh p save backup from current production server to local computer (only for safety, if all goes well, we do not need it) (local computer) ./provision.sh pn upload all needed installation files to the new production server; the static database files will be skipped. (new production server) ./install.sh perform the complete installation of shebanq Arrange with your internet provider to let the domain name point to the IP address of the new production server (local computer) Tweak config.sh and put the name of the new production server into serverProd .","title":"Production (migrating)"},{"location":"deploy/server/#update-shebanq-on-an-existing-server","text":"This works the same in all situations. We give the steps for the other situation, which is most likely your situation. In all situations, when on the server, you must sudo the invocations of the scripts or run them as root.","title":"Update SHEBANQ on an existing server"},{"location":"deploy/server/#shebanq-code-only","text":"Do this when you noticed that the SHEBANQ repo has updates. (server) update.sh Pull the SHEBANQ repository from GitHUb That's all. Simple and quick.","title":"SHEBANQ code only"},{"location":"deploy/server/#a-version-of-the-static-data","text":"Do this when a new version of the etcbc data is released or an existing version has got an update. These databases are released through the etcbc/bhsa repository on GitHub, in the directory shebanq . You have them in your local clone of the BHSA. Below, version is the desired data version that you want to import, such as 4 , 4b , c , 2017 , 2021 . (local computer) git pull origin master Do this in your clone of the BHSA repository. And then again in your clone of the SHEBANQ repository (local computer) ./provision.sh o --static version upload all needed data files files to the server; (server) install.sh --static version This imports both the shebanq_passage and shebanq_etcbc databases of that version.","title":"A version of the static data"},{"location":"deploy/server/#emdros","text":"Do this when you noticed that there is a new version of Emdros. In that case, the SHEBANQ repository contains all that is necessary. (local computer) git pull origin master Do this in your clone of the SHEBANQ repository. (local computer) Tweak config.sh Adapt the EMDROS_VERSION variable so that it reflects the Emdros version in question. (local computer) ./provision.sh o --emdros Only transfer the new Emdros distribution. (server) ./install.sh --emdros Install Emdros only. (server) update.sh Pull the SHEBANQ repository from GitHUb","title":"Emdros"},{"location":"deploy/server/#web2py","text":"Do this when you noticed that there is a new version of Web2py and if you are sure that it does not break SHEBANQ. In that case, the SHEBANQ repository contains all that is necessary. (local computer) git pull origin master Do this in your clone of the SHEBANQ repository. (local computer) ./provision.sh o --web2py Only transfer the new Web2py distribution. (server) ./install.sh --web2py Install Web2py only. (server) update.sh Pull the SHEBANQ repository from GitHUb","title":"Web2py"},{"location":"deploy/server/#maintain-backups-of-dynamic-data","text":"The dynamic data of SHEBANQ is stored in two databases: shebanq_web : user data: names and email addresses and password hashes of registered users. query data: meta data and results of queries that have been saved in shebanq shebanq_note : note data: metadata and content of all notes that have been saved in SHEBANQ. Currently, I make occasional backups of the production SHEBANQ and store them on my local computer, which is backed up in multiple ways, offline and online.","title":"Maintain backups of dynamic data"},{"location":"deploy/server/#backup-dynamic-data","text":"(server) ./backup.sh This will create a fresh backup of the dynamic data and store it on the server in a folder with a time-stamped name. Also, a symbolic link under the name latest will link to that backup. (local computer) ./save.sh o This will fetch the latest backup from the server to your local computer. It will end up in your backup directory there, under the same time-stamped name, and also with a latest link.","title":"Backup dynamic data"},{"location":"deploy/server/#restore-dynamic-data","text":"In cases where a server has crashed and data has been lost, it is necessary to restore the latest known dynamic data. (local computer) ./provision.sh o --dynamic This will find the latest dynamic data backup of the server that exists on your local computer and upload it to the server. (server) ./restore.sh This will find the latest dynamic data backup that exists on the server and import it to the databases. Mixing backups If you maintain multiple servers from your local computers, the backups of all these servers end up in the same place. Production and test backups are kept separate In order to avoid the risk of restoring a backup made on the test server to the production server, backups made on a test server are stored in a different directory. When backups are restored, they will never be taken from this directory, not even when restoring on the test server. If you do need to restore a test backup on the test server, you have to manually copy it over to the right place. The same holds for backups that come from the serverOtherNew and serverProdNew servers. These backups have no importance except for testing the processes, so they will be stored in the alternative place.","title":"Restore dynamic data"},{"location":"deploy/server/#trouble-shooting","text":"It is very difficult to view messages issued by Python code. So far, I have not been able to view them anywhere in the log files. The recommended practice is to install Web2Py and SHEBANQ on your local computer, and debug it there.","title":"Trouble shooting"},{"location":"elements/","text":"Pages \u00b6 We give an overview of the elements of the typical SHEBANQ pages, and we will name the different parts. These concepts will recur in the discussion of the code, whether it is Python, Javascript, CSS, HTML or SQL. A good introduction into the kinds of pages is the menubar. Main pages \u00b6 There are several kinds of main pages text pages have Hebrew text material words presents the lexicon queries presents the family of saved queries, organized by organization, project and user notes presents the family of saved notes, organized by organization, project and user","title":"Pages"},{"location":"elements/#pages","text":"We give an overview of the elements of the typical SHEBANQ pages, and we will name the different parts. These concepts will recur in the discussion of the code, whether it is Python, Javascript, CSS, HTML or SQL. A good introduction into the kinds of pages is the menubar.","title":"Pages"},{"location":"elements/#main-pages","text":"There are several kinds of main pages text pages have Hebrew text material words presents the lexicon queries presents the family of saved queries, organized by organization, project and user notes presents the family of saved notes, organized by organization, project and user","title":"Main pages"},{"location":"elements/notespage/","text":"","title":"Notespage"},{"location":"elements/queriespage/","text":"","title":"Queriespage"},{"location":"elements/textpages/","text":"Text pages \u00b6 The text pages are the bread and butter of shebanq, they are subdivided into two kinds: material pages show a chapter of the Hebrew Bible: the left sidebar may show related words, queries, notes the main area shows the text of the chapter, as a list of its verses; record pages show an individual word , query , or note set ; we use the term record to refer to an individual word, query or note set. the left sidebar shows the characteristics of the record, depending on the type of the record, the main area shows the verses that belong to that record, as a list of verses, being: for a word, the verses where it occurs; for a query, shows the verses where it has results; for a note set, the verses where it has members. Skeleton \u00b6 All text pages have a left side bar and a main area. Both areas have a header which contains verious controls that influence the selection and presentation of the content. Here is a schematic overview. =============================================================================== |all: icon menu login | |all: Text Word Queries Notes | =============================================================================== ====================== ===================================================== |m:w list controls | |m: material controls book chapter | |m:w word list | |m: verse content verse | |m:w | |m: verse content verse | ---------------------- |m: verse content verse | |m:q list controls | ===================================================== |m:q query list | |rw: material controls word page | |m:q query list | |rw: verse content chapter:verse | |m:q | |rw: verse content verse | ---------------------- |rw: verse content verse | |m:n list controls | ===================================================== |m:n note list | |rq: material controls query page | |m:n | |rq: verse content verse | ====================== |rq: verse content verse | |rw: record control | |rq: verse content verse | |rw: word info | ===================================================== |rw: | |rn: material controls noteset page | ====================== |rn: verse content verse | |rq: record control | |rn: verse content verse | |rq: query info | |rn: verse content verse | |rq: | ===================================================== ====================== |rn: record control | |rn: note set info | ============= |rn: | |text: cite | ====================== ============= Not all blocks occur on all pages. The qualifiers indicate what occurs on what: qualifier page type all: all pages text: all text pages m: all material text pages m:w all material text pages if word sidebar is on m:q all material text pages if query sidebar is on m:n all material text pages if noteset sidebar is on rw: all record text pages of type word rq: all record text pages of type query rn: all record text pages of type noteset Operation \u00b6 When a SHEBANQ user navigates on a text page, he can switch between m and r pages. On an m page he sees chapter material, in a sidebar he sees lists of related words, queries, notes. A click on a related query item opens an rq page. There he sees hits of that query. Every hit has a link to the chapter the hit is in. A click on that chapter opens an m page for that chapter. In the sidebars there are again related words, queries, notes. A click on a related word opens an rw page. And so on. Under the hood there is just a single page. All blocks are always present on a text page, but not all are visible. Two parameters regulate which one are visible mr = m or r qw = w or q or n Changes in mr and qw trigger the showing and hiding of the appropriate blocks. Moreover, if needed, fresh content for these blocks is fetched from the server by means of AJAX calls and inserted into them. So, during all this navigation, the skeleton of the page does not change, and the server is only accessed by for partial content. The controls for content selection and view settings belong to the skeleton. code type associated names JS materialsettings.MaterialSettings , sideSettings.sideSettings.js view text.html controller hebrew.text() Material Controls \u00b6 info \u00b6 link to feature docs of BHSA code type associated names CSS source.ctli JS select.SelectPassage views versions.html modules -- controllers -- version \u00b6 select ETCBC data version code type associated names CSS mvradio.ctl JS words.View.init , select.SelectPassage.apply views versions.html modules ViewSettings language \u00b6 switch between languages in which the names of the books of the bible are presented. code type associated names CSS #thelang , #select_control_lang JS select.SelectLangugae views textbody.html modules blang.py text representation \u00b6 select hebrew script or phonetic script code type associated names CSS mtradio.ctl , mhb , mph JS tr , materialsettings.MaterialSettings views textbody.html modules tr , VerseContent.plainText text presentation \u00b6 select normal running text, or one of several tabular formats. The tabular formats present the text by clause atom , one clause atom per line, with extra syntactic information added Notes : with notes displayed Syntax : with indentation according to linguistic embedding Abstract : with letter mapped to just a few symbols code type associated names CSS mhradio.ctl , #mtxtp . mtxt1 , #mtxt2 , mtxt3 JS tp , materialsettings.MaterialSettings , select.SelectPassage views textbody.html modules tp , VerseContent.material book \u00b6 select a book of the bible, not on record pages code type associated names CSS #select_control_book , #thebook JS book , material.Material , select.SelectBook/SelectPassage , share. views textbody.html modules book , materials.MATERIAL , book , books.BOOKS chapter \u00b6 select a chapter within the current book, not on record pages, with controls to go to next/previous chapters code type associated names CSS #select_control_chapter , #thechapter JS chapter , material.Material , select.SelectItems/SelectPassage , share. views textbody.html modules chapter , materials.MATERIAL , book , books.BOOKS page \u00b6 select a page within the list of items associated with the current record (word/query/note set), not on material pages, with controls to go to next/previous pages code type associated names CSS #select_control_page , #thepage JS page , material.Material , select.SelectItems , share. views textbody.html modules page , materials.MATERIAL links \u00b6 each chapter has a link to the same chapter in other tools, such as Bible Online Learner and ParaBible , not on record pages. code type associated names CSS #bol_lnk , #pbl_lnk JS select.SelectPassage views textbody.html List Controls \u00b6 highlight published \u00b6 show published items only; not in word item lists code type associated names CSS #hlpub[qn] , [qn]pradio.ctl JS sideSettings.SideSettings , notes.NoteVerse views textsidebar.html modules viewdefs.Make highlight reset \u00b6 reset the highlighting of all items in this list; not in note item lists code type associated names CSS #hlreset[wq] , [wq]hradio.ctl JS sideSettings.SideSettings , page.Page views textsidebar.html modules viewdefs.Make highlight many \u00b6 highlight all items in this list; not in note item lists code type associated names CSS #hlmany[wq] , [wq]hradio.ctl JS sideSettings.SideSettings , page.Page views textsidebar.html modules viewdefs.Make highlight custom \u00b6 highlight only selected items in this list; not in note item lists code type associated names CSS #hlcustom[wq] , [wq]hradio.ctl JS sideSettings.SideSettings , page.Page views textsidebar.html modules viewdefs.Make highlight one \u00b6 highlight the selected items in this list and use only one color for that, to be selected in the box next to it; not in note item lists code type associated names CSS #hlone[wq] , [wq]hradio.ctl JS sideSettings.SideSettings , page.Page views textsidebar.html modules viewdefs.Make highlight off \u00b6 turn highlighting off for all items in this list ; not in note item lists code type associated names CSS #hloff[wq] , [wq]hradio.ctl JS sideSettings.SideSettings , page.Page views textsidebar.html modules viewdefs.Make select single highlight color \u00b6 if highlight one is chosen, pick the color used for all highlights; not in note item lists code type associated names CSS #sel[wq]_one , colorselect_[wq] JS sideSettings.SideSettings , page.Page , colorpicker.ColorPicker1/ColorPicker2 , viewState.viewState views textsidebar.html modules viewdefs.Make Record Control \u00b6 select highlight color \u00b6 pick the color used to highlight items of this record, i.e. occurrences of this word or hits of this query; not in note item lists code type associated names CSS #sel[wq]_me , colorselect_[wq] JS sideSettings.SideSettings , page.Page , colorpicker.ColorPicker1/ColorPicker2 , viewState.viewState views textsidebar.html modules viewdefs.Make Content \u00b6 The main area presents a verse list. The verses are those of a chapter for an m page, and those of a record for an r page. Think of query results and word occurrences and notes from a note set. goto chapter \u00b6 r pages show book-chapter indications next to the verses, which link to the m pages of the corresponding book chapters. code type associated names CSS cref JS material.Material views material.html show verse data \u00b6 Both m and r pages show verse numbers next to the verses, which are clickable and open a data view of the corresponding verses, together with a legend button. code type associated names CSS vradio , #datalegend_control JS material.Material views material.html feature legend \u00b6 The legend can be used to control which features are displayed in data view. The feature labels in the legend link to the feature documentation in the BHSA repo. code type associated names CSS #datalegend_control JS material.Material , materialsettings.MaterialSettings views textbody.html, material.html Citation \u00b6 cite slider \u00b6 At the bottom-right corner of the page is a slider control from where the user can pick urls for citation. Which urls are shown is dependent on the contents of the page. code type associated names CSS #citeh JS share","title":"Text pages"},{"location":"elements/textpages/#text-pages","text":"The text pages are the bread and butter of shebanq, they are subdivided into two kinds: material pages show a chapter of the Hebrew Bible: the left sidebar may show related words, queries, notes the main area shows the text of the chapter, as a list of its verses; record pages show an individual word , query , or note set ; we use the term record to refer to an individual word, query or note set. the left sidebar shows the characteristics of the record, depending on the type of the record, the main area shows the verses that belong to that record, as a list of verses, being: for a word, the verses where it occurs; for a query, shows the verses where it has results; for a note set, the verses where it has members.","title":"Text pages"},{"location":"elements/textpages/#skeleton","text":"All text pages have a left side bar and a main area. Both areas have a header which contains verious controls that influence the selection and presentation of the content. Here is a schematic overview. =============================================================================== |all: icon menu login | |all: Text Word Queries Notes | =============================================================================== ====================== ===================================================== |m:w list controls | |m: material controls book chapter | |m:w word list | |m: verse content verse | |m:w | |m: verse content verse | ---------------------- |m: verse content verse | |m:q list controls | ===================================================== |m:q query list | |rw: material controls word page | |m:q query list | |rw: verse content chapter:verse | |m:q | |rw: verse content verse | ---------------------- |rw: verse content verse | |m:n list controls | ===================================================== |m:n note list | |rq: material controls query page | |m:n | |rq: verse content verse | ====================== |rq: verse content verse | |rw: record control | |rq: verse content verse | |rw: word info | ===================================================== |rw: | |rn: material controls noteset page | ====================== |rn: verse content verse | |rq: record control | |rn: verse content verse | |rq: query info | |rn: verse content verse | |rq: | ===================================================== ====================== |rn: record control | |rn: note set info | ============= |rn: | |text: cite | ====================== ============= Not all blocks occur on all pages. The qualifiers indicate what occurs on what: qualifier page type all: all pages text: all text pages m: all material text pages m:w all material text pages if word sidebar is on m:q all material text pages if query sidebar is on m:n all material text pages if noteset sidebar is on rw: all record text pages of type word rq: all record text pages of type query rn: all record text pages of type noteset","title":"Skeleton"},{"location":"elements/textpages/#operation","text":"When a SHEBANQ user navigates on a text page, he can switch between m and r pages. On an m page he sees chapter material, in a sidebar he sees lists of related words, queries, notes. A click on a related query item opens an rq page. There he sees hits of that query. Every hit has a link to the chapter the hit is in. A click on that chapter opens an m page for that chapter. In the sidebars there are again related words, queries, notes. A click on a related word opens an rw page. And so on. Under the hood there is just a single page. All blocks are always present on a text page, but not all are visible. Two parameters regulate which one are visible mr = m or r qw = w or q or n Changes in mr and qw trigger the showing and hiding of the appropriate blocks. Moreover, if needed, fresh content for these blocks is fetched from the server by means of AJAX calls and inserted into them. So, during all this navigation, the skeleton of the page does not change, and the server is only accessed by for partial content. The controls for content selection and view settings belong to the skeleton. code type associated names JS materialsettings.MaterialSettings , sideSettings.sideSettings.js view text.html controller hebrew.text()","title":"Operation"},{"location":"elements/textpages/#material-controls","text":"","title":"Material Controls"},{"location":"elements/textpages/#info","text":"link to feature docs of BHSA code type associated names CSS source.ctli JS select.SelectPassage views versions.html modules -- controllers --","title":"info"},{"location":"elements/textpages/#version","text":"select ETCBC data version code type associated names CSS mvradio.ctl JS words.View.init , select.SelectPassage.apply views versions.html modules ViewSettings","title":"version"},{"location":"elements/textpages/#language","text":"switch between languages in which the names of the books of the bible are presented. code type associated names CSS #thelang , #select_control_lang JS select.SelectLangugae views textbody.html modules blang.py","title":"language"},{"location":"elements/textpages/#text-representation","text":"select hebrew script or phonetic script code type associated names CSS mtradio.ctl , mhb , mph JS tr , materialsettings.MaterialSettings views textbody.html modules tr , VerseContent.plainText","title":"text representation"},{"location":"elements/textpages/#text-presentation","text":"select normal running text, or one of several tabular formats. The tabular formats present the text by clause atom , one clause atom per line, with extra syntactic information added Notes : with notes displayed Syntax : with indentation according to linguistic embedding Abstract : with letter mapped to just a few symbols code type associated names CSS mhradio.ctl , #mtxtp . mtxt1 , #mtxt2 , mtxt3 JS tp , materialsettings.MaterialSettings , select.SelectPassage views textbody.html modules tp , VerseContent.material","title":"text presentation"},{"location":"elements/textpages/#book","text":"select a book of the bible, not on record pages code type associated names CSS #select_control_book , #thebook JS book , material.Material , select.SelectBook/SelectPassage , share. views textbody.html modules book , materials.MATERIAL , book , books.BOOKS","title":"book"},{"location":"elements/textpages/#chapter","text":"select a chapter within the current book, not on record pages, with controls to go to next/previous chapters code type associated names CSS #select_control_chapter , #thechapter JS chapter , material.Material , select.SelectItems/SelectPassage , share. views textbody.html modules chapter , materials.MATERIAL , book , books.BOOKS","title":"chapter"},{"location":"elements/textpages/#page","text":"select a page within the list of items associated with the current record (word/query/note set), not on material pages, with controls to go to next/previous pages code type associated names CSS #select_control_page , #thepage JS page , material.Material , select.SelectItems , share. views textbody.html modules page , materials.MATERIAL","title":"page"},{"location":"elements/textpages/#links","text":"each chapter has a link to the same chapter in other tools, such as Bible Online Learner and ParaBible , not on record pages. code type associated names CSS #bol_lnk , #pbl_lnk JS select.SelectPassage views textbody.html","title":"links"},{"location":"elements/textpages/#list-controls","text":"","title":"List Controls"},{"location":"elements/textpages/#highlight-published","text":"show published items only; not in word item lists code type associated names CSS #hlpub[qn] , [qn]pradio.ctl JS sideSettings.SideSettings , notes.NoteVerse views textsidebar.html modules viewdefs.Make","title":"highlight published"},{"location":"elements/textpages/#highlight-reset","text":"reset the highlighting of all items in this list; not in note item lists code type associated names CSS #hlreset[wq] , [wq]hradio.ctl JS sideSettings.SideSettings , page.Page views textsidebar.html modules viewdefs.Make","title":"highlight reset"},{"location":"elements/textpages/#highlight-many","text":"highlight all items in this list; not in note item lists code type associated names CSS #hlmany[wq] , [wq]hradio.ctl JS sideSettings.SideSettings , page.Page views textsidebar.html modules viewdefs.Make","title":"highlight many"},{"location":"elements/textpages/#highlight-custom","text":"highlight only selected items in this list; not in note item lists code type associated names CSS #hlcustom[wq] , [wq]hradio.ctl JS sideSettings.SideSettings , page.Page views textsidebar.html modules viewdefs.Make","title":"highlight custom"},{"location":"elements/textpages/#highlight-one","text":"highlight the selected items in this list and use only one color for that, to be selected in the box next to it; not in note item lists code type associated names CSS #hlone[wq] , [wq]hradio.ctl JS sideSettings.SideSettings , page.Page views textsidebar.html modules viewdefs.Make","title":"highlight one"},{"location":"elements/textpages/#highlight-off","text":"turn highlighting off for all items in this list ; not in note item lists code type associated names CSS #hloff[wq] , [wq]hradio.ctl JS sideSettings.SideSettings , page.Page views textsidebar.html modules viewdefs.Make","title":"highlight off"},{"location":"elements/textpages/#select-single-highlight-color","text":"if highlight one is chosen, pick the color used for all highlights; not in note item lists code type associated names CSS #sel[wq]_one , colorselect_[wq] JS sideSettings.SideSettings , page.Page , colorpicker.ColorPicker1/ColorPicker2 , viewState.viewState views textsidebar.html modules viewdefs.Make","title":"select single highlight color"},{"location":"elements/textpages/#record-control","text":"","title":"Record Control"},{"location":"elements/textpages/#select-highlight-color","text":"pick the color used to highlight items of this record, i.e. occurrences of this word or hits of this query; not in note item lists code type associated names CSS #sel[wq]_me , colorselect_[wq] JS sideSettings.SideSettings , page.Page , colorpicker.ColorPicker1/ColorPicker2 , viewState.viewState views textsidebar.html modules viewdefs.Make","title":"select highlight color"},{"location":"elements/textpages/#content","text":"The main area presents a verse list. The verses are those of a chapter for an m page, and those of a record for an r page. Think of query results and word occurrences and notes from a note set.","title":"Content"},{"location":"elements/textpages/#goto-chapter","text":"r pages show book-chapter indications next to the verses, which link to the m pages of the corresponding book chapters. code type associated names CSS cref JS material.Material views material.html","title":"goto chapter"},{"location":"elements/textpages/#show-verse-data","text":"Both m and r pages show verse numbers next to the verses, which are clickable and open a data view of the corresponding verses, together with a legend button. code type associated names CSS vradio , #datalegend_control JS material.Material views material.html","title":"show verse data"},{"location":"elements/textpages/#feature-legend","text":"The legend can be used to control which features are displayed in data view. The feature labels in the legend link to the feature documentation in the BHSA repo. code type associated names CSS #datalegend_control JS material.Material , materialsettings.MaterialSettings views textbody.html, material.html","title":"feature legend"},{"location":"elements/textpages/#citation","text":"","title":"Citation"},{"location":"elements/textpages/#cite-slider","text":"At the bottom-right corner of the page is a slider control from where the user can pick urls for citation. Which urls are shown is dependent on the contents of the page. code type associated names CSS #citeh JS share","title":"cite slider"},{"location":"elements/wordspage/","text":"","title":"Wordspage"},{"location":"server/","text":"Server \u00b6 This is the part of SHEBANQ that works on the server. It consists of controllers that are triggered by urls. The actual work of the controllers is implemented in the modules . The result of that work is data, in the form of dictionaries. These dictionaries are fed into views , which are chunks of HTML with placeholders that are filled by the key value pairs in the dictionary. For every controller function like def xxx(): produce a dictionary there is a view with the same name: xxx.html , in which the result of xxx() will be filled in. Not strict There might be more functions in a controller file than are controllers: auxiliary functions are allowed. There might be more html files in the views directory than are proper views: views may include sub views.","title":"Server"},{"location":"server/#server","text":"This is the part of SHEBANQ that works on the server. It consists of controllers that are triggered by urls. The actual work of the controllers is implemented in the modules . The result of that work is data, in the form of dictionaries. These dictionaries are fed into views , which are chunks of HTML with placeholders that are filled by the key value pairs in the dictionary. For every controller function like def xxx(): produce a dictionary there is a view with the same name: xxx.html , in which the result of xxx() will be filled in. Not strict There might be more functions in a controller file than are controllers: auxiliary functions are allowed. There might be more html files in the views directory than are proper views: views may include sub views.","title":"Server"},{"location":"server/controllers/","text":"Controllers \u00b6 The controllers can be grouped as follows. Default \u00b6 controllers.default \u00b6 call () \u00b6 Unchanged from web2py. exposes services. for example: http://..../[app]/default/call/jsonrpc decorate with @services.jsonrpc the functions to expose supports xml, json, xmlrpc, jsonrpc, amfrpc, rss, csv Source code in controllers/default.py def call (): \"\"\"Unchanged from web2py. ``` exposes services. for example: http://..../[app]/default/call/jsonrpc decorate with @services.jsonrpc the functions to expose supports xml, json, xmlrpc, jsonrpc, amfrpc, rss, csv ``` \"\"\" return service () # noqa F821 data () \u00b6 Unchanged from web2py. http://..../[app]/default/data/tables http://..../[app]/default/data/create/[table] http://..../[app]/default/data/read/[table]/[id] http://..../[app]/default/data/update/[table]/[id] http://..../[app]/default/data/delete/[table]/[id] http://..../[app]/default/data/select/[table] http://..../[app]/default/data/search/[table] but URLs must be signed, i.e. linked with A('table',_href=URL('data/tables',user_signature=True)) or with the signed load operator LOAD('default','data.load',args='tables',ajax=True,user_signature=True) Source code in controllers/default.py @auth . requires_signature () def data (): \"\"\"Unchanged from web2py. ``` http://..../[app]/default/data/tables http://..../[app]/default/data/create/[table] http://..../[app]/default/data/read/[table]/[id] http://..../[app]/default/data/update/[table]/[id] http://..../[app]/default/data/delete/[table]/[id] http://..../[app]/default/data/select/[table] http://..../[app]/default/data/search/[table] but URLs must be signed, i.e. linked with A('table',_href=URL('data/tables',user_signature=True)) or with the signed load operator LOAD('default','data.load',args='tables',ajax=True,user_signature=True) ``` \"\"\" return dict ( form = crud ()) # noqa F821 download () \u00b6 Unchanged from web2py. allows downloading of uploaded files http://..../[app]/default/download/[filename] Source code in controllers/default.py @cache . action () def download (): \"\"\"Unchanged from web2py. ``` allows downloading of uploaded files http://..../[app]/default/download/[filename] ``` \"\"\" return response . download ( request , db ) index () \u00b6 Serves the home page. Corresponds with the SHEBANQ logo in the navigation bar. Source code in controllers/default.py def index (): \"\"\"Serves the **home** page. Corresponds with the SHEBANQ logo in the navigation bar. \"\"\" session . forget ( response ) response . title = T ( \"SHEBANQ\" ) response . subtitle = T ( \"Query the Hebrew Bible through the BHSA database\" ) return dict () user () \u00b6 Unchanged from web2py. exposes: http://..../[app]/default/user/login http://..../[app]/default/user/logout http://..../[app]/default/user/register http://..../[app]/default/user/profile http://..../[app]/default/user/retrieve_password http://..../[app]/default/user/change_password http://..../[app]/default/user/manage_users (requires membership in use @auth.requires_login() @auth.requires_membership('group name') @auth.requires_permission('read','table name',record_id) to decorate functions that need access control Source code in controllers/default.py def user (): \"\"\"Unchanged from web2py. ``` exposes: http://..../[app]/default/user/login http://..../[app]/default/user/logout http://..../[app]/default/user/register http://..../[app]/default/user/profile http://..../[app]/default/user/retrieve_password http://..../[app]/default/user/change_password http://..../[app]/default/user/manage_users (requires membership in use @auth.requires_login() @auth.requires_membership('group name') @auth.requires_permission('read','table name',record_id) to decorate functions that need access control ``` \"\"\" response . title = T ( \"User Profile\" ) return dict ( form = auth ()) Feed \u00b6 controllers.feed \u00b6 atom () \u00b6 Serves an RSS feed of recently saved shared queries. See also M:QUERYRECENT . Source code in controllers/feed.py def atom (): \"\"\"Serves an RSS feed of recently saved shared queries. See also [M:QUERYRECENT][queryrecent.QUERYRECENT]. \"\"\" session . forget ( response ) U = Urls () QueryRecent = QUERYRECENT () queries = QueryRecent . feed () icon = URL ( \"static\" , \"images/shebanq_logo_xxsmall.png\" , host = True ) cover = URL ( \"static\" , \"images/shebanq_cover.png\" , host = True ) base = URL ( \"xxx\" , \"yyy\" , host = True , extension = \"\" )[ 0 : - 8 ] feed = URL ( \"feed\" , \"atom\" , host = True , extension = \"\" ) xml = [] xml . append ( \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?> \"\"\" ) xml . append ( dedent ( \"\"\" <feed xmlns=\"http://www.w3.org/2005/Atom\" xmlns:webfeeds=\"http://webfeeds.org/rss/1.0\" > \"\"\" ) ) xml . append ( dedent ( f \"\"\" <title>SHEBANQ</title> <subtitle>Shared queries, recently executed</subtitle> <link href=\" { hEsc ( feed ) } \" rel=\"self\" title=\"SHEBANQ - Shared Queries\" type=\"application/atom+xml\"/> <link href=\" { hEsc ( base ) } \" rel=\"alternate\" type=\"text/html\"/> <id> { hEsc ( base + \"/hebrew/queries\" ) } </id> <updated> { isodt () } </updated> <category term=\"bible study\"/> <category term=\"biblical studies\"/> <category term=\"text\"/> <category term=\"linguistic\"/> <category term=\"hebrew\"/> <category term=\"bible\"/> <category term=\"query\"/> <category term=\"database\"/> <category term=\"research\"/> <category term=\"scholar\"/> <category term=\"annotation\"/> <category term=\"digital bible\"/> <category term=\"digital\"/> <category term=\"religion\"/> <category term=\"theology\"/> <icon> { hEsc ( icon ) } </icon> <webfeeds:icon> { hEsc ( icon ) } </webfeeds:icon> <logo> { hEsc ( cover ) } </logo> <webfeeds:cover image=\" { hEsc ( cover ) } \"/> <webfeeds:accentColor>DDBB00</webfeeds:accentColor> \"\"\" ) ) for ( query_id , first_name , last_name , query_name , description , qvid , qexe , qver , ) in queries : descHtml = U . specialLinks ( sanitize ( markdown ( hEsc ( description or \"No description given\" ), output_format = \"xhtml5\" ) ) ) # we add a standard cover image if the description does not contain any image standardImage = ( f \"\"\"<p><img src=\" { cover } \"/></p>\"\"\" if \"<img \" not in descHtml else \"\" ) href = hEsc ( URL ( \"hebrew\" , \"query\" , vars = dict ( id = query_id , version = qver ), host = True , extension = \"\" , ) ) tag = f \"tag:shebanq.ancient-data.org,2016-01-01: { query_id } / { qvid } / { qver } \" name = hEsc ( f \" { first_name } { last_name } \" ) xml . append ( dedent ( f \"\"\" <entry> <title> { hEsc ( query_name ) } </title> <link href=\" { href } \" rel=\"alternate\" type=\"text/html\"/> <id> { tag } </id> <updated> { isodt ( qexe ) } </updated> <category term=\"query\"/> <content type=\"xhtml\"> <div xmlns=\"http://www.w3.org/1999/xhtml\"> { standardImage } { descHtml } </div> </content> <author><name> { name } </name></author> </entry> \"\"\" ) ) xml . append ( dedent ( \"\"\" </feed> \"\"\" ) ) return dict ( xml = \"\" . join ( xml )) Hebrew \u00b6 In hebrew.py . The significant controllers are all here. Their bodies are very short, because they all call a function from the modules, which does all the work. The modules are individually documented by docstrings in the code. controllers.hebrew \u00b6 books () \u00b6 Get all bible book names in all their translations. This is a utility page for website users. This controller is not used by other parts of the webapp. See also M:BOOKS.getNames . Source code in controllers/hebrew.py def books (): \"\"\"Get all bible book names in all their translations. This is a utility page for website users. This controller is not used by other parts of the webapp. See also [M:BOOKS.getNames][books.BOOKS.getNames]. \"\"\" Books = BOOKS () session . forget ( response ) return Books . getNames () chart () \u00b6 Get a heat map of the items associated to a record. Items are: the occurrences of a word, the results of a query, the notes of a notes set. See also M:CHART.page . Client code: {chart.fetch} . Source code in controllers/hebrew.py def chart (): # controller to produce a chart of query results or lexeme occurrences \"\"\"Get a heat map of the items associated to a record. Items are: the occurrences of a word, the results of a query, the notes of a notes set. See also [M:CHART.page][chart.CHART.page]. Client code: [{chart.fetch}][chartfetch]. \"\"\" session . forget ( response ) Books = BOOKS () Word = WORD () Query = QUERY () Note = NOTE ( Books ) RecordQuery = RECORDQUERY ( Query ) Chart = CHART ( Books , RecordQuery , Word , Query , Note ) return Chart . page () getversenotes () \u00b6 Serves AJAX call for json data for all notes belonging to a single verse. See also M:NOTE.getVerseNotes . Client code: {noteverse.fetch} Source code in controllers/hebrew.py def getversenotes (): \"\"\"Serves AJAX call for json data for all notes belonging to a single verse. See also [M:NOTE.getVerseNotes][note.NOTE.getVerseNotes]. Client code: [{noteverse.fetch}][noteversefetch] \"\"\" session . forget ( response ) Books = BOOKS () Note = NOTE ( Books ) return Note . getVerseNotes () item () \u00b6 Get csv data of the items associated with a record. Items are: the occurrences of a word, the results of a query, the notes of a notes set. See also M:CSVDATA.page . Client code: {viewstate.csvUrl} . Source code in controllers/hebrew.py def item (): \"\"\"Get csv data of the items associated with a record. Items are: the occurrences of a word, the results of a query, the notes of a notes set. See also [M:CSVDATA.page][csvdata.CSVDATA.page]. Client code: [{viewstate.csvUrl}][viewstatecsvurl]. \"\"\" session . forget ( response ) Word = WORD () Query = QUERY () RecordQuery = RECORDQUERY ( Query ) CsvData = CSVDATA ( RecordQuery , Word , Query ) return CsvData . page () itemrecord () \u00b6 Saves a record to the database, typically organizations, projects, queries. See also M:RECORD.setItem . Client code: {querytree.Tree.record} . Source code in controllers/hebrew.py def itemrecord (): \"\"\"Saves a record to the database, typically organizations, projects, queries. See also [M:RECORD.setItem][record.RECORD.setItem]. Client code: [{querytree.Tree.record}][treerecord]. \"\"\" session . forget ( response ) Query = QUERY () RecordQuery = RECORDQUERY ( Query ) return RecordQuery . setItem () material () \u00b6 Serves AJAX call for HTML content for the main area. Client code: {material.fetch} . Source code in controllers/hebrew.py def material (): \"\"\"Serves AJAX call for HTML content for the main area. Client code: [{material.fetch}][materialfetch]. \"\"\" session . forget ( response ) Books = BOOKS () Word = WORD () Query = QUERY () Note = NOTE ( Books ) RecordQuery = RECORDQUERY ( Query ) Material = MATERIAL ( RecordQuery , Word , Query , Note ) return Material . page () note () \u00b6 Serves a notes set record page. Usually from an overview page or a shared link. The page consists of a sidebar with the details of the notes set, and the main area displays the notes between the verses. Source code in controllers/hebrew.py def note (): \"\"\"Serves a *notes set* **record** page. Usually from an overview page or a shared link. The page consists of a sidebar with the details of the notes set, and the main area displays the notes between the verses. \"\"\" session . forget ( response ) request . vars [ \"mr\" ] = \"r\" request . vars [ \"qw\" ] = \"n\" request . vars [ \"page\" ] = 1 return () notes () \u00b6 Serves the notes overview page. Corresponds with Notes in the menu bar. The main part is the tree of note sets. There is also a widget for bulk uploading sets of notes. Source code in controllers/hebrew.py def notes (): \"\"\"Serves the **notes** overview page. Corresponds with `Notes` in the menu bar. The main part is the tree of note sets. There is also a widget for bulk uploading sets of notes. \"\"\" session . forget ( response ) init () Books = BOOKS () ViewSettings = VIEWSETTINGS ( Books ) ViewSettings . initState () Note = NOTE ( Books ) return Note . page ( ViewSettings ) notetree () \u00b6 Serves AJAX call for json data for the tree overview of notes sets. See also M:NOTETREE.get . Client code: {notetree.Tree} Source code in controllers/hebrew.py def notetree (): \"\"\"Serves AJAX call for json data for the tree overview of notes sets. See also [M:NOTETREE.get][notetree.NOTETREE.get]. Client code: [{notetree.Tree}][notetreetree] \"\"\" session . forget ( response ) NoteTree = NOTETREE () return NoteTree . get () noteupload () \u00b6 Receives bulk-uploaded notes and stores them. See also M:NOTESUPLOAD.upload . Client code: {notetree.Upload.submit} . Source code in controllers/hebrew.py def noteupload (): \"\"\"Receives bulk-uploaded notes and stores them. See also [M:NOTESUPLOAD.upload][notesupload.NOTESUPLOAD.upload]. Client code: [{notetree.Upload.submit}][uploadsubmit]. \"\"\" session . forget ( response ) Books = BOOKS () Note = NOTE ( Books ) NotesUpload = NOTESUPLOAD ( Books , Note ) return NotesUpload . upload () putversenotes () \u00b6 Serves AJAX call for json data to save notes. See also M:NOTESAVE.putVerseNotes . Client code: {noteverse.sendnotes} Source code in controllers/hebrew.py def putversenotes (): \"\"\"Serves AJAX call for json data to save notes. See also [M:NOTESAVE.putVerseNotes][notesave.NOTESAVE.putVerseNotes]. Client code: [{noteverse.sendnotes}][noteversesendnotes] \"\"\" session . forget ( response ) Books = BOOKS () Note = NOTE ( Books ) NoteSave = NOTESAVE ( Note ) return NoteSave . putVerseNotes () queries () \u00b6 Serves the queries overview page. Corresponds with Queries in the menu bar. The main part is the tree of queries. There is also a widget with recent queries and a control to add new queries. Source code in controllers/hebrew.py def queries (): \"\"\"Serves the **queries** overview page. Corresponds with `Queries` in the menu bar. The main part is the tree of queries. There is also a widget with recent queries and a control to add new queries. \"\"\" session . forget ( response ) init () Books = BOOKS () ViewSettings = VIEWSETTINGS ( Books ) ViewSettings . initState () Query = QUERY () return Query . page ( ViewSettings ) queriesr () \u00b6 Serves AJAX call for json data for recently saved shared queries. See also [queryrecent.QUERYRECENT.recent]. Client code: {queryrecent.fetch} Source code in controllers/hebrew.py def queriesr (): \"\"\"Serves AJAX call for json data for recently saved shared queries. See also [queryrecent.QUERYRECENT.recent]. Client code: [{queryrecent.fetch}][queryrecentfetch] \"\"\" session . forget ( response ) QueryRecent = QUERYRECENT () return QueryRecent . recent () query () \u00b6 Serves a query record page. Usually an overview page or from a shared link. The page consists of a sidebar with the details of the query, and the main area displays the results. Source code in controllers/hebrew.py def query (): \"\"\"Serves a *query* **record** page. Usually an overview page or from a shared link. The page consists of a sidebar with the details of the query, and the main area displays the results. \"\"\" session . forget ( response ) request . vars [ \"mr\" ] = \"r\" request . vars [ \"qw\" ] = \"q\" if request . extension == \"json\" : Query = QUERY () return Query . bodyJson () else : request . vars [ \"page\" ] = 1 return () querysharing () \u00b6 Saves the shared status of a query to the database. See also M:QUERYSAVE.sharing . Client code: {sidecontent.sendval} . Source code in controllers/hebrew.py def querysharing (): \"\"\"Saves the shared status of a query to the database. See also [M:QUERYSAVE.sharing][querysave.QUERYSAVE.sharing]. Client code: [{sidecontent.sendval}][sidecontentsendval]. \"\"\" session . forget ( response ) Query = QUERY () QueryChapter = QUERYCHAPTER () QuerySave = QUERYSAVE ( Query , QueryChapter ) return QuerySave . sharing () querytree () \u00b6 Serves AJAX call for json data for the tree overview of queries. See also M:QUERYTREE.get . Client code: {querytree.Tree} Source code in controllers/hebrew.py def querytree (): \"\"\"Serves AJAX call for json data for the tree overview of queries. See also [M:QUERYTREE.get][querytree.QUERYTREE.get]. Client code: [{querytree.Tree}][querytreetree] \"\"\" session . forget ( response ) QueryTree = QUERYTREE () return QueryTree . get () queryupdate () \u00b6 Saves metadata of a query to the database. See also M:QUERYSAVE.putRecord . Client code: {sidecontent.sendvals} . Source code in controllers/hebrew.py def queryupdate (): \"\"\"Saves metadata of a query to the database. See also [M:QUERYSAVE.putRecord][querysave.QUERYSAVE.putRecord]. Client code: [{sidecontent.sendvals}][sidecontentsendvals]. \"\"\" session . forget ( response ) Query = QUERY () QueryChapter = QUERYCHAPTER () QuerySave = QUERYSAVE ( Query , QueryChapter ) return QuerySave . putRecord () sidematerial () \u00b6 Serves AJAX call for HTML content for the sidebar ( main page). Client code: {sidecontent.fetch} . Source code in controllers/hebrew.py def sidematerial (): \"\"\"Serves AJAX call for HTML content for the sidebar (**main** page). Client code: [{sidecontent.fetch}][sidecontentfetch]. \"\"\" session . forget ( response ) Books = BOOKS () Word = WORD () Query = QUERY () Note = NOTE ( Books ) RecordQuery = RECORDQUERY ( Query ) Material = MATERIAL ( RecordQuery , Word , Query , Note ) Side = SIDE ( Material , Word , Query , Note ) return Side . page () sidenote () \u00b6 Serves AJAX call for HTML content for the sidebar ( note set record page). Used when the user is switching between main and record pages. See also M:RECORD.body . Client code: {sidecontent.fetch} . Source code in controllers/hebrew.py def sidenote (): \"\"\"Serves AJAX call for HTML content for the sidebar (*note set* **record** page). Used when the user is switching between **main** and **record** pages. See also [M:RECORD.body][record.RECORD.body]. Client code: [{sidecontent.fetch}][sidecontentfetch]. \"\"\" session . forget ( response ) Record = RECORD () return Record . body () sidenotebody () \u00b6 Serves AJAX call for HTML content for the sidebar ( notes set record page). Used when the user is loading a notes set page directly. See also M:NOTE.body . Source code in controllers/hebrew.py def sidenotebody (): \"\"\"Serves AJAX call for HTML content for the sidebar (*notes set* **record** page). Used when the user is loading a *notes set* page directly. See also [M:NOTE.body][note.NOTE.body]. \"\"\" session . forget ( response ) if not request . ajax : redirect ( URL ( \"hebrew\" , \"note\" , extension = \"\" , vars = request . vars )) Books = BOOKS () Note = NOTE ( Books ) return Note . body () sidequery () \u00b6 Serves AJAX call for HTML content for the sidebar ( query record page). Used when the user is switching between main and record pages. See also M:RECORD.body . Client code: {sidecontent.fetch} . Source code in controllers/hebrew.py def sidequery (): \"\"\"Serves AJAX call for HTML content for the sidebar (*query* **record** page). Used when the user is switching between **main** and **record** pages. See also [M:RECORD.body][record.RECORD.body]. Client code: [{sidecontent.fetch}][sidecontentfetch]. \"\"\" session . forget ( response ) Record = RECORD () return Record . body () sidequerybody () \u00b6 Serves AJAX call for HTML content for the sidebar ( query record page). Used when the user is loading a query page directly. See also M:QUERY.body . Source code in controllers/hebrew.py def sidequerybody (): \"\"\"Serves AJAX call for HTML content for the sidebar (*query* **record** page). Used when the user is loading a *query* page directly. See also [M:QUERY.body][query.QUERY.body]. \"\"\" session . forget ( response ) if not request . ajax : redirect ( URL ( \"hebrew\" , \"query\" , extension = \"\" , vars = request . vars )) Query = QUERY () return Query . body () sideword () \u00b6 Serves AJAX call for HTML content for the sidebar ( word record page). Used when the user is switching between main and record pages. See also M:RECORD.body . Client code: {sidecontent.fetch} . Source code in controllers/hebrew.py def sideword (): \"\"\"Serves AJAX call for HTML content for the sidebar (*word* **record** page). Used when the user is switching between **main** and **record** pages. See also [M:RECORD.body][record.RECORD.body]. Client code: [{sidecontent.fetch}][sidecontentfetch]. \"\"\" session . forget ( response ) Record = RECORD () return Record . body () sidewordbody () \u00b6 Serves AJAX call for HTML content for the sidebar ( word record page). Used when the user is loading word page directly. See also M:WORD.body . Source code in controllers/hebrew.py def sidewordbody (): \"\"\"Serves AJAX call for HTML content for the sidebar (*word* **record** page). Used when the user is loading *word* page directly. See also [M:WORD.body][word.WORD.body]. \"\"\" session . forget ( response ) if not request . ajax : redirect ( URL ( \"hebrew\" , \"word\" , extension = \"\" , vars = request . vars )) Word = WORD () return Word . body () text () \u00b6 Serves a text page. Corresponds with Text in the menu bar. Only the skeleton of the page is fetched. See also M:VIEWSETTINGS.page . Source code in controllers/hebrew.py def text (): \"\"\"Serves a **text** page. Corresponds with `Text` in the menu bar. Only the skeleton of the page is fetched. See also [M:VIEWSETTINGS.page][viewsettings.VIEWSETTINGS.page]. \"\"\" session . forget ( response ) init () Books = BOOKS () ViewSettings = VIEWSETTINGS ( Books ) ViewSettings . initState () return ViewSettings . page () verse () \u00b6 Get the linguistic data of a verse. See also M:VERSE.get . Client code: {material.addverserefs} . Source code in controllers/hebrew.py def verse (): \"\"\"Get the linguistic data of a verse. See also [M:VERSE.get][verse.VERSE.get]. Client code: [{material.addverserefs}][materialaddverserefs]. \"\"\" session . forget ( response ) Verse = VERSE () return Verse . get () word () \u00b6 Serves a word record page. Usually an overview page or from a shared link. The page consists of a sidebar with the details of the word, and the main area displays the occurrences. Source code in controllers/hebrew.py def word (): \"\"\"Serves a *word* **record** page. Usually an overview page or from a shared link. The page consists of a sidebar with the details of the word, and the main area displays the occurrences. \"\"\" session . forget ( response ) request . vars [ \"mr\" ] = \"r\" request . vars [ \"qw\" ] = \"w\" request . vars [ \"page\" ] = 1 return () words () \u00b6 Serves words overview pages. Corresponds with Words in the menu bar. The words are fetched in pages off all words starting with the same letter. Source code in controllers/hebrew.py def words (): \"\"\"Serves **words** overview pages. Corresponds with `Words` in the menu bar. The words are fetched in pages off all words starting with the same letter. \"\"\" session . forget ( response ) init () Books = BOOKS () ViewSettings = VIEWSETTINGS ( Books ) ViewSettings . initState () Word = WORD () return Word . page ( ViewSettings )","title":"Controllers"},{"location":"server/controllers/#controllers","text":"The controllers can be grouped as follows.","title":"Controllers"},{"location":"server/controllers/#default","text":"","title":"Default"},{"location":"server/controllers/#controllers.default","text":"","title":"default"},{"location":"server/controllers/#controllers.default.call","text":"Unchanged from web2py. exposes services. for example: http://..../[app]/default/call/jsonrpc decorate with @services.jsonrpc the functions to expose supports xml, json, xmlrpc, jsonrpc, amfrpc, rss, csv Source code in controllers/default.py def call (): \"\"\"Unchanged from web2py. ``` exposes services. for example: http://..../[app]/default/call/jsonrpc decorate with @services.jsonrpc the functions to expose supports xml, json, xmlrpc, jsonrpc, amfrpc, rss, csv ``` \"\"\" return service () # noqa F821","title":"call()"},{"location":"server/controllers/#controllers.default.data","text":"Unchanged from web2py. http://..../[app]/default/data/tables http://..../[app]/default/data/create/[table] http://..../[app]/default/data/read/[table]/[id] http://..../[app]/default/data/update/[table]/[id] http://..../[app]/default/data/delete/[table]/[id] http://..../[app]/default/data/select/[table] http://..../[app]/default/data/search/[table] but URLs must be signed, i.e. linked with A('table',_href=URL('data/tables',user_signature=True)) or with the signed load operator LOAD('default','data.load',args='tables',ajax=True,user_signature=True) Source code in controllers/default.py @auth . requires_signature () def data (): \"\"\"Unchanged from web2py. ``` http://..../[app]/default/data/tables http://..../[app]/default/data/create/[table] http://..../[app]/default/data/read/[table]/[id] http://..../[app]/default/data/update/[table]/[id] http://..../[app]/default/data/delete/[table]/[id] http://..../[app]/default/data/select/[table] http://..../[app]/default/data/search/[table] but URLs must be signed, i.e. linked with A('table',_href=URL('data/tables',user_signature=True)) or with the signed load operator LOAD('default','data.load',args='tables',ajax=True,user_signature=True) ``` \"\"\" return dict ( form = crud ()) # noqa F821","title":"data()"},{"location":"server/controllers/#controllers.default.download","text":"Unchanged from web2py. allows downloading of uploaded files http://..../[app]/default/download/[filename] Source code in controllers/default.py @cache . action () def download (): \"\"\"Unchanged from web2py. ``` allows downloading of uploaded files http://..../[app]/default/download/[filename] ``` \"\"\" return response . download ( request , db )","title":"download()"},{"location":"server/controllers/#controllers.default.index","text":"Serves the home page. Corresponds with the SHEBANQ logo in the navigation bar. Source code in controllers/default.py def index (): \"\"\"Serves the **home** page. Corresponds with the SHEBANQ logo in the navigation bar. \"\"\" session . forget ( response ) response . title = T ( \"SHEBANQ\" ) response . subtitle = T ( \"Query the Hebrew Bible through the BHSA database\" ) return dict ()","title":"index()"},{"location":"server/controllers/#controllers.default.user","text":"Unchanged from web2py. exposes: http://..../[app]/default/user/login http://..../[app]/default/user/logout http://..../[app]/default/user/register http://..../[app]/default/user/profile http://..../[app]/default/user/retrieve_password http://..../[app]/default/user/change_password http://..../[app]/default/user/manage_users (requires membership in use @auth.requires_login() @auth.requires_membership('group name') @auth.requires_permission('read','table name',record_id) to decorate functions that need access control Source code in controllers/default.py def user (): \"\"\"Unchanged from web2py. ``` exposes: http://..../[app]/default/user/login http://..../[app]/default/user/logout http://..../[app]/default/user/register http://..../[app]/default/user/profile http://..../[app]/default/user/retrieve_password http://..../[app]/default/user/change_password http://..../[app]/default/user/manage_users (requires membership in use @auth.requires_login() @auth.requires_membership('group name') @auth.requires_permission('read','table name',record_id) to decorate functions that need access control ``` \"\"\" response . title = T ( \"User Profile\" ) return dict ( form = auth ())","title":"user()"},{"location":"server/controllers/#feed","text":"","title":"Feed"},{"location":"server/controllers/#controllers.feed","text":"","title":"feed"},{"location":"server/controllers/#controllers.feed.atom","text":"Serves an RSS feed of recently saved shared queries. See also M:QUERYRECENT . Source code in controllers/feed.py def atom (): \"\"\"Serves an RSS feed of recently saved shared queries. See also [M:QUERYRECENT][queryrecent.QUERYRECENT]. \"\"\" session . forget ( response ) U = Urls () QueryRecent = QUERYRECENT () queries = QueryRecent . feed () icon = URL ( \"static\" , \"images/shebanq_logo_xxsmall.png\" , host = True ) cover = URL ( \"static\" , \"images/shebanq_cover.png\" , host = True ) base = URL ( \"xxx\" , \"yyy\" , host = True , extension = \"\" )[ 0 : - 8 ] feed = URL ( \"feed\" , \"atom\" , host = True , extension = \"\" ) xml = [] xml . append ( \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?> \"\"\" ) xml . append ( dedent ( \"\"\" <feed xmlns=\"http://www.w3.org/2005/Atom\" xmlns:webfeeds=\"http://webfeeds.org/rss/1.0\" > \"\"\" ) ) xml . append ( dedent ( f \"\"\" <title>SHEBANQ</title> <subtitle>Shared queries, recently executed</subtitle> <link href=\" { hEsc ( feed ) } \" rel=\"self\" title=\"SHEBANQ - Shared Queries\" type=\"application/atom+xml\"/> <link href=\" { hEsc ( base ) } \" rel=\"alternate\" type=\"text/html\"/> <id> { hEsc ( base + \"/hebrew/queries\" ) } </id> <updated> { isodt () } </updated> <category term=\"bible study\"/> <category term=\"biblical studies\"/> <category term=\"text\"/> <category term=\"linguistic\"/> <category term=\"hebrew\"/> <category term=\"bible\"/> <category term=\"query\"/> <category term=\"database\"/> <category term=\"research\"/> <category term=\"scholar\"/> <category term=\"annotation\"/> <category term=\"digital bible\"/> <category term=\"digital\"/> <category term=\"religion\"/> <category term=\"theology\"/> <icon> { hEsc ( icon ) } </icon> <webfeeds:icon> { hEsc ( icon ) } </webfeeds:icon> <logo> { hEsc ( cover ) } </logo> <webfeeds:cover image=\" { hEsc ( cover ) } \"/> <webfeeds:accentColor>DDBB00</webfeeds:accentColor> \"\"\" ) ) for ( query_id , first_name , last_name , query_name , description , qvid , qexe , qver , ) in queries : descHtml = U . specialLinks ( sanitize ( markdown ( hEsc ( description or \"No description given\" ), output_format = \"xhtml5\" ) ) ) # we add a standard cover image if the description does not contain any image standardImage = ( f \"\"\"<p><img src=\" { cover } \"/></p>\"\"\" if \"<img \" not in descHtml else \"\" ) href = hEsc ( URL ( \"hebrew\" , \"query\" , vars = dict ( id = query_id , version = qver ), host = True , extension = \"\" , ) ) tag = f \"tag:shebanq.ancient-data.org,2016-01-01: { query_id } / { qvid } / { qver } \" name = hEsc ( f \" { first_name } { last_name } \" ) xml . append ( dedent ( f \"\"\" <entry> <title> { hEsc ( query_name ) } </title> <link href=\" { href } \" rel=\"alternate\" type=\"text/html\"/> <id> { tag } </id> <updated> { isodt ( qexe ) } </updated> <category term=\"query\"/> <content type=\"xhtml\"> <div xmlns=\"http://www.w3.org/1999/xhtml\"> { standardImage } { descHtml } </div> </content> <author><name> { name } </name></author> </entry> \"\"\" ) ) xml . append ( dedent ( \"\"\" </feed> \"\"\" ) ) return dict ( xml = \"\" . join ( xml ))","title":"atom()"},{"location":"server/controllers/#hebrew","text":"In hebrew.py . The significant controllers are all here. Their bodies are very short, because they all call a function from the modules, which does all the work. The modules are individually documented by docstrings in the code.","title":"Hebrew"},{"location":"server/controllers/#controllers.hebrew","text":"","title":"hebrew"},{"location":"server/controllers/#controllers.hebrew.books","text":"Get all bible book names in all their translations. This is a utility page for website users. This controller is not used by other parts of the webapp. See also M:BOOKS.getNames . Source code in controllers/hebrew.py def books (): \"\"\"Get all bible book names in all their translations. This is a utility page for website users. This controller is not used by other parts of the webapp. See also [M:BOOKS.getNames][books.BOOKS.getNames]. \"\"\" Books = BOOKS () session . forget ( response ) return Books . getNames ()","title":"books()"},{"location":"server/controllers/#controllers.hebrew.chart","text":"Get a heat map of the items associated to a record. Items are: the occurrences of a word, the results of a query, the notes of a notes set. See also M:CHART.page . Client code: {chart.fetch} . Source code in controllers/hebrew.py def chart (): # controller to produce a chart of query results or lexeme occurrences \"\"\"Get a heat map of the items associated to a record. Items are: the occurrences of a word, the results of a query, the notes of a notes set. See also [M:CHART.page][chart.CHART.page]. Client code: [{chart.fetch}][chartfetch]. \"\"\" session . forget ( response ) Books = BOOKS () Word = WORD () Query = QUERY () Note = NOTE ( Books ) RecordQuery = RECORDQUERY ( Query ) Chart = CHART ( Books , RecordQuery , Word , Query , Note ) return Chart . page ()","title":"chart()"},{"location":"server/controllers/#controllers.hebrew.getversenotes","text":"Serves AJAX call for json data for all notes belonging to a single verse. See also M:NOTE.getVerseNotes . Client code: {noteverse.fetch} Source code in controllers/hebrew.py def getversenotes (): \"\"\"Serves AJAX call for json data for all notes belonging to a single verse. See also [M:NOTE.getVerseNotes][note.NOTE.getVerseNotes]. Client code: [{noteverse.fetch}][noteversefetch] \"\"\" session . forget ( response ) Books = BOOKS () Note = NOTE ( Books ) return Note . getVerseNotes ()","title":"getversenotes()"},{"location":"server/controllers/#controllers.hebrew.item","text":"Get csv data of the items associated with a record. Items are: the occurrences of a word, the results of a query, the notes of a notes set. See also M:CSVDATA.page . Client code: {viewstate.csvUrl} . Source code in controllers/hebrew.py def item (): \"\"\"Get csv data of the items associated with a record. Items are: the occurrences of a word, the results of a query, the notes of a notes set. See also [M:CSVDATA.page][csvdata.CSVDATA.page]. Client code: [{viewstate.csvUrl}][viewstatecsvurl]. \"\"\" session . forget ( response ) Word = WORD () Query = QUERY () RecordQuery = RECORDQUERY ( Query ) CsvData = CSVDATA ( RecordQuery , Word , Query ) return CsvData . page ()","title":"item()"},{"location":"server/controllers/#controllers.hebrew.itemrecord","text":"Saves a record to the database, typically organizations, projects, queries. See also M:RECORD.setItem . Client code: {querytree.Tree.record} . Source code in controllers/hebrew.py def itemrecord (): \"\"\"Saves a record to the database, typically organizations, projects, queries. See also [M:RECORD.setItem][record.RECORD.setItem]. Client code: [{querytree.Tree.record}][treerecord]. \"\"\" session . forget ( response ) Query = QUERY () RecordQuery = RECORDQUERY ( Query ) return RecordQuery . setItem ()","title":"itemrecord()"},{"location":"server/controllers/#controllers.hebrew.material","text":"Serves AJAX call for HTML content for the main area. Client code: {material.fetch} . Source code in controllers/hebrew.py def material (): \"\"\"Serves AJAX call for HTML content for the main area. Client code: [{material.fetch}][materialfetch]. \"\"\" session . forget ( response ) Books = BOOKS () Word = WORD () Query = QUERY () Note = NOTE ( Books ) RecordQuery = RECORDQUERY ( Query ) Material = MATERIAL ( RecordQuery , Word , Query , Note ) return Material . page ()","title":"material()"},{"location":"server/controllers/#controllers.hebrew.note","text":"Serves a notes set record page. Usually from an overview page or a shared link. The page consists of a sidebar with the details of the notes set, and the main area displays the notes between the verses. Source code in controllers/hebrew.py def note (): \"\"\"Serves a *notes set* **record** page. Usually from an overview page or a shared link. The page consists of a sidebar with the details of the notes set, and the main area displays the notes between the verses. \"\"\" session . forget ( response ) request . vars [ \"mr\" ] = \"r\" request . vars [ \"qw\" ] = \"n\" request . vars [ \"page\" ] = 1 return ()","title":"note()"},{"location":"server/controllers/#controllers.hebrew.notes","text":"Serves the notes overview page. Corresponds with Notes in the menu bar. The main part is the tree of note sets. There is also a widget for bulk uploading sets of notes. Source code in controllers/hebrew.py def notes (): \"\"\"Serves the **notes** overview page. Corresponds with `Notes` in the menu bar. The main part is the tree of note sets. There is also a widget for bulk uploading sets of notes. \"\"\" session . forget ( response ) init () Books = BOOKS () ViewSettings = VIEWSETTINGS ( Books ) ViewSettings . initState () Note = NOTE ( Books ) return Note . page ( ViewSettings )","title":"notes()"},{"location":"server/controllers/#controllers.hebrew.notetree","text":"Serves AJAX call for json data for the tree overview of notes sets. See also M:NOTETREE.get . Client code: {notetree.Tree} Source code in controllers/hebrew.py def notetree (): \"\"\"Serves AJAX call for json data for the tree overview of notes sets. See also [M:NOTETREE.get][notetree.NOTETREE.get]. Client code: [{notetree.Tree}][notetreetree] \"\"\" session . forget ( response ) NoteTree = NOTETREE () return NoteTree . get ()","title":"notetree()"},{"location":"server/controllers/#controllers.hebrew.noteupload","text":"Receives bulk-uploaded notes and stores them. See also M:NOTESUPLOAD.upload . Client code: {notetree.Upload.submit} . Source code in controllers/hebrew.py def noteupload (): \"\"\"Receives bulk-uploaded notes and stores them. See also [M:NOTESUPLOAD.upload][notesupload.NOTESUPLOAD.upload]. Client code: [{notetree.Upload.submit}][uploadsubmit]. \"\"\" session . forget ( response ) Books = BOOKS () Note = NOTE ( Books ) NotesUpload = NOTESUPLOAD ( Books , Note ) return NotesUpload . upload ()","title":"noteupload()"},{"location":"server/controllers/#controllers.hebrew.putversenotes","text":"Serves AJAX call for json data to save notes. See also M:NOTESAVE.putVerseNotes . Client code: {noteverse.sendnotes} Source code in controllers/hebrew.py def putversenotes (): \"\"\"Serves AJAX call for json data to save notes. See also [M:NOTESAVE.putVerseNotes][notesave.NOTESAVE.putVerseNotes]. Client code: [{noteverse.sendnotes}][noteversesendnotes] \"\"\" session . forget ( response ) Books = BOOKS () Note = NOTE ( Books ) NoteSave = NOTESAVE ( Note ) return NoteSave . putVerseNotes ()","title":"putversenotes()"},{"location":"server/controllers/#controllers.hebrew.queries","text":"Serves the queries overview page. Corresponds with Queries in the menu bar. The main part is the tree of queries. There is also a widget with recent queries and a control to add new queries. Source code in controllers/hebrew.py def queries (): \"\"\"Serves the **queries** overview page. Corresponds with `Queries` in the menu bar. The main part is the tree of queries. There is also a widget with recent queries and a control to add new queries. \"\"\" session . forget ( response ) init () Books = BOOKS () ViewSettings = VIEWSETTINGS ( Books ) ViewSettings . initState () Query = QUERY () return Query . page ( ViewSettings )","title":"queries()"},{"location":"server/controllers/#controllers.hebrew.queriesr","text":"Serves AJAX call for json data for recently saved shared queries. See also [queryrecent.QUERYRECENT.recent]. Client code: {queryrecent.fetch} Source code in controllers/hebrew.py def queriesr (): \"\"\"Serves AJAX call for json data for recently saved shared queries. See also [queryrecent.QUERYRECENT.recent]. Client code: [{queryrecent.fetch}][queryrecentfetch] \"\"\" session . forget ( response ) QueryRecent = QUERYRECENT () return QueryRecent . recent ()","title":"queriesr()"},{"location":"server/controllers/#controllers.hebrew.query","text":"Serves a query record page. Usually an overview page or from a shared link. The page consists of a sidebar with the details of the query, and the main area displays the results. Source code in controllers/hebrew.py def query (): \"\"\"Serves a *query* **record** page. Usually an overview page or from a shared link. The page consists of a sidebar with the details of the query, and the main area displays the results. \"\"\" session . forget ( response ) request . vars [ \"mr\" ] = \"r\" request . vars [ \"qw\" ] = \"q\" if request . extension == \"json\" : Query = QUERY () return Query . bodyJson () else : request . vars [ \"page\" ] = 1 return ()","title":"query()"},{"location":"server/controllers/#controllers.hebrew.querysharing","text":"Saves the shared status of a query to the database. See also M:QUERYSAVE.sharing . Client code: {sidecontent.sendval} . Source code in controllers/hebrew.py def querysharing (): \"\"\"Saves the shared status of a query to the database. See also [M:QUERYSAVE.sharing][querysave.QUERYSAVE.sharing]. Client code: [{sidecontent.sendval}][sidecontentsendval]. \"\"\" session . forget ( response ) Query = QUERY () QueryChapter = QUERYCHAPTER () QuerySave = QUERYSAVE ( Query , QueryChapter ) return QuerySave . sharing ()","title":"querysharing()"},{"location":"server/controllers/#controllers.hebrew.querytree","text":"Serves AJAX call for json data for the tree overview of queries. See also M:QUERYTREE.get . Client code: {querytree.Tree} Source code in controllers/hebrew.py def querytree (): \"\"\"Serves AJAX call for json data for the tree overview of queries. See also [M:QUERYTREE.get][querytree.QUERYTREE.get]. Client code: [{querytree.Tree}][querytreetree] \"\"\" session . forget ( response ) QueryTree = QUERYTREE () return QueryTree . get ()","title":"querytree()"},{"location":"server/controllers/#controllers.hebrew.queryupdate","text":"Saves metadata of a query to the database. See also M:QUERYSAVE.putRecord . Client code: {sidecontent.sendvals} . Source code in controllers/hebrew.py def queryupdate (): \"\"\"Saves metadata of a query to the database. See also [M:QUERYSAVE.putRecord][querysave.QUERYSAVE.putRecord]. Client code: [{sidecontent.sendvals}][sidecontentsendvals]. \"\"\" session . forget ( response ) Query = QUERY () QueryChapter = QUERYCHAPTER () QuerySave = QUERYSAVE ( Query , QueryChapter ) return QuerySave . putRecord ()","title":"queryupdate()"},{"location":"server/controllers/#controllers.hebrew.sidematerial","text":"Serves AJAX call for HTML content for the sidebar ( main page). Client code: {sidecontent.fetch} . Source code in controllers/hebrew.py def sidematerial (): \"\"\"Serves AJAX call for HTML content for the sidebar (**main** page). Client code: [{sidecontent.fetch}][sidecontentfetch]. \"\"\" session . forget ( response ) Books = BOOKS () Word = WORD () Query = QUERY () Note = NOTE ( Books ) RecordQuery = RECORDQUERY ( Query ) Material = MATERIAL ( RecordQuery , Word , Query , Note ) Side = SIDE ( Material , Word , Query , Note ) return Side . page ()","title":"sidematerial()"},{"location":"server/controllers/#controllers.hebrew.sidenote","text":"Serves AJAX call for HTML content for the sidebar ( note set record page). Used when the user is switching between main and record pages. See also M:RECORD.body . Client code: {sidecontent.fetch} . Source code in controllers/hebrew.py def sidenote (): \"\"\"Serves AJAX call for HTML content for the sidebar (*note set* **record** page). Used when the user is switching between **main** and **record** pages. See also [M:RECORD.body][record.RECORD.body]. Client code: [{sidecontent.fetch}][sidecontentfetch]. \"\"\" session . forget ( response ) Record = RECORD () return Record . body ()","title":"sidenote()"},{"location":"server/controllers/#controllers.hebrew.sidenotebody","text":"Serves AJAX call for HTML content for the sidebar ( notes set record page). Used when the user is loading a notes set page directly. See also M:NOTE.body . Source code in controllers/hebrew.py def sidenotebody (): \"\"\"Serves AJAX call for HTML content for the sidebar (*notes set* **record** page). Used when the user is loading a *notes set* page directly. See also [M:NOTE.body][note.NOTE.body]. \"\"\" session . forget ( response ) if not request . ajax : redirect ( URL ( \"hebrew\" , \"note\" , extension = \"\" , vars = request . vars )) Books = BOOKS () Note = NOTE ( Books ) return Note . body ()","title":"sidenotebody()"},{"location":"server/controllers/#controllers.hebrew.sidequery","text":"Serves AJAX call for HTML content for the sidebar ( query record page). Used when the user is switching between main and record pages. See also M:RECORD.body . Client code: {sidecontent.fetch} . Source code in controllers/hebrew.py def sidequery (): \"\"\"Serves AJAX call for HTML content for the sidebar (*query* **record** page). Used when the user is switching between **main** and **record** pages. See also [M:RECORD.body][record.RECORD.body]. Client code: [{sidecontent.fetch}][sidecontentfetch]. \"\"\" session . forget ( response ) Record = RECORD () return Record . body ()","title":"sidequery()"},{"location":"server/controllers/#controllers.hebrew.sidequerybody","text":"Serves AJAX call for HTML content for the sidebar ( query record page). Used when the user is loading a query page directly. See also M:QUERY.body . Source code in controllers/hebrew.py def sidequerybody (): \"\"\"Serves AJAX call for HTML content for the sidebar (*query* **record** page). Used when the user is loading a *query* page directly. See also [M:QUERY.body][query.QUERY.body]. \"\"\" session . forget ( response ) if not request . ajax : redirect ( URL ( \"hebrew\" , \"query\" , extension = \"\" , vars = request . vars )) Query = QUERY () return Query . body ()","title":"sidequerybody()"},{"location":"server/controllers/#controllers.hebrew.sideword","text":"Serves AJAX call for HTML content for the sidebar ( word record page). Used when the user is switching between main and record pages. See also M:RECORD.body . Client code: {sidecontent.fetch} . Source code in controllers/hebrew.py def sideword (): \"\"\"Serves AJAX call for HTML content for the sidebar (*word* **record** page). Used when the user is switching between **main** and **record** pages. See also [M:RECORD.body][record.RECORD.body]. Client code: [{sidecontent.fetch}][sidecontentfetch]. \"\"\" session . forget ( response ) Record = RECORD () return Record . body ()","title":"sideword()"},{"location":"server/controllers/#controllers.hebrew.sidewordbody","text":"Serves AJAX call for HTML content for the sidebar ( word record page). Used when the user is loading word page directly. See also M:WORD.body . Source code in controllers/hebrew.py def sidewordbody (): \"\"\"Serves AJAX call for HTML content for the sidebar (*word* **record** page). Used when the user is loading *word* page directly. See also [M:WORD.body][word.WORD.body]. \"\"\" session . forget ( response ) if not request . ajax : redirect ( URL ( \"hebrew\" , \"word\" , extension = \"\" , vars = request . vars )) Word = WORD () return Word . body ()","title":"sidewordbody()"},{"location":"server/controllers/#controllers.hebrew.text","text":"Serves a text page. Corresponds with Text in the menu bar. Only the skeleton of the page is fetched. See also M:VIEWSETTINGS.page . Source code in controllers/hebrew.py def text (): \"\"\"Serves a **text** page. Corresponds with `Text` in the menu bar. Only the skeleton of the page is fetched. See also [M:VIEWSETTINGS.page][viewsettings.VIEWSETTINGS.page]. \"\"\" session . forget ( response ) init () Books = BOOKS () ViewSettings = VIEWSETTINGS ( Books ) ViewSettings . initState () return ViewSettings . page ()","title":"text()"},{"location":"server/controllers/#controllers.hebrew.verse","text":"Get the linguistic data of a verse. See also M:VERSE.get . Client code: {material.addverserefs} . Source code in controllers/hebrew.py def verse (): \"\"\"Get the linguistic data of a verse. See also [M:VERSE.get][verse.VERSE.get]. Client code: [{material.addverserefs}][materialaddverserefs]. \"\"\" session . forget ( response ) Verse = VERSE () return Verse . get ()","title":"verse()"},{"location":"server/controllers/#controllers.hebrew.word","text":"Serves a word record page. Usually an overview page or from a shared link. The page consists of a sidebar with the details of the word, and the main area displays the occurrences. Source code in controllers/hebrew.py def word (): \"\"\"Serves a *word* **record** page. Usually an overview page or from a shared link. The page consists of a sidebar with the details of the word, and the main area displays the occurrences. \"\"\" session . forget ( response ) request . vars [ \"mr\" ] = \"r\" request . vars [ \"qw\" ] = \"w\" request . vars [ \"page\" ] = 1 return ()","title":"word()"},{"location":"server/controllers/#controllers.hebrew.words","text":"Serves words overview pages. Corresponds with Words in the menu bar. The words are fetched in pages off all words starting with the same letter. Source code in controllers/hebrew.py def words (): \"\"\"Serves **words** overview pages. Corresponds with `Words` in the menu bar. The words are fetched in pages off all words starting with the same letter. \"\"\" session . forget ( response ) init () Books = BOOKS () ViewSettings = VIEWSETTINGS ( Books ) ViewSettings . initState () Word = WORD () return Word . page ( ViewSettings )","title":"words()"},{"location":"server/models/","text":"Models \u00b6 The code in the models define the database connections and define other data related global variables.","title":"Models"},{"location":"server/models/#models","text":"The code in the models define the database connections and define other data related global variables.","title":"Models"},{"location":"server/views/","text":"Views \u00b6 The HTML generation takes place in the views, based on data supplied by the controllers in template variables. Nevertheless, there is also a fair bit of HTML generation at the client side, done by Javascript.","title":"Views"},{"location":"server/views/#views","text":"The HTML generation takes place in the views, based on data supplied by the controllers in template variables. Nevertheless, there is also a fair bit of HTML generation at the client side, done by Javascript.","title":"Views"},{"location":"server/bymodule/","text":"About modules \u00b6 Modules perform dedicated data retrieval and composition tasks. These tasks have been delegated to them by the controllers. Use the navigation menu to jump to the individual modules.","title":"About modules"},{"location":"server/bymodule/#about-modules","text":"Modules perform dedicated data retrieval and composition tasks. These tasks have been delegated to them by the controllers. Use the navigation menu to jump to the individual modules.","title":"About modules"},{"location":"server/bymodule/blang/","text":"blang \u00b6 BOOK_LANGS \u00b6 Languages for bible book names BOOK_NAMES \u00b6 Book names in all the languages","title":"Blang"},{"location":"server/bymodule/blang/#blang","text":"","title":"blang"},{"location":"server/bymodule/blang/#blang.BOOK_LANGS","text":"Languages for bible book names","title":"BOOK_LANGS"},{"location":"server/bymodule/blang/#blang.BOOK_NAMES","text":"Book names in all the languages","title":"BOOK_NAMES"},{"location":"server/bymodule/boiler/","text":"boiler \u00b6 FIELDNAMES \u00b6 Lists of field names of the data that is displayed in text presentations. Keyed by the code of the text presentation type, the values are combinations of data type (word, phrase, clause etc.) and feature name (gloss, phono, gender, etc.) LEGEND \u00b6 The legend as an HTML table. TEXT_TPL \u00b6 The representation of a word in data view as an HTML table.","title":"Boiler"},{"location":"server/bymodule/boiler/#boiler","text":"","title":"boiler"},{"location":"server/bymodule/boiler/#boiler.FIELDNAMES","text":"Lists of field names of the data that is displayed in text presentations. Keyed by the code of the text presentation type, the values are combinations of data type (word, phrase, clause etc.) and feature name (gloss, phono, gender, etc.)","title":"FIELDNAMES"},{"location":"server/bymodule/boiler/#boiler.LEGEND","text":"The legend as an HTML table.","title":"LEGEND"},{"location":"server/bymodule/boiler/#boiler.TEXT_TPL","text":"The representation of a word in data view as an HTML table.","title":"TEXT_TPL"},{"location":"server/bymodule/books/","text":"books \u00b6 BOOKS \u00b6 All information about the names of bible books. The order of the books and the names of the books in all supported languages. This information is meant to be permanently cached. getNames ( self ) \u00b6 Send information about bible booknames. The info consists of the latin booknames, the languages in which we have translations for them, and a translation table for all book names. The info is wrapped in global Javascript variables, so that the whole client app can use the info. Source code in modules/books.py def getNames ( self ): \"\"\"Send information about bible booknames. The info consists of the latin booknames, the languages in which we have translations for them, and a translation table for all book names. The info is wrapped in global Javascript variables, so that the whole client app can use the info. \"\"\" jsinit = dedent ( f \"\"\" var bookLatin = { json . dumps ( BOOK_NAMES [ \"Hebrew\" ][ \"la\" ]) } ; var bookTrans = { json . dumps ( BOOK_TRANS ) } ; var bookLangs = { json . dumps ( BOOK_LANGS [ \"Hebrew\" ]) } ; \"\"\" ) return dict ( jsinit = jsinit )","title":"Books"},{"location":"server/bymodule/books/#books","text":"","title":"books"},{"location":"server/bymodule/books/#books.BOOKS","text":"All information about the names of bible books. The order of the books and the names of the books in all supported languages. This information is meant to be permanently cached.","title":"BOOKS"},{"location":"server/bymodule/books/#books.BOOKS.getNames","text":"Send information about bible booknames. The info consists of the latin booknames, the languages in which we have translations for them, and a translation table for all book names. The info is wrapped in global Javascript variables, so that the whole client app can use the info. Source code in modules/books.py def getNames ( self ): \"\"\"Send information about bible booknames. The info consists of the latin booknames, the languages in which we have translations for them, and a translation table for all book names. The info is wrapped in global Javascript variables, so that the whole client app can use the info. \"\"\" jsinit = dedent ( f \"\"\" var bookLatin = { json . dumps ( BOOK_NAMES [ \"Hebrew\" ][ \"la\" ]) } ; var bookTrans = { json . dumps ( BOOK_TRANS ) } ; var bookLangs = { json . dumps ( BOOK_LANGS [ \"Hebrew\" ]) } ; \"\"\" ) return dict ( jsinit = jsinit )","title":"getNames()"},{"location":"server/bymodule/chart/","text":"chart \u00b6 CHART \u00b6 Make heat maps of lists of items. The items are word occurrences or query results or note set members. We divide the bible in 500-word blocks and count the number of items per block. We present the blocks in a chart, where each block shows the number of items by means of color. The blocks are clickable and move to the chapter in which the first word of the block occurs. See also the client code: {chart} . compose ( self , vr , slotSets ) \u00b6 Organize the raw chart data in books and then in blocks. Returns \u00b6 dict keyed by book, with values lists of blocks where each block is a tuple (chapter number, start position, end position, number of results, size) Source code in modules/chart.py def compose ( self , vr , slotSets ): \"\"\"Organize the raw chart data in books and then in blocks. Returns ------- dict keyed by book, with values lists of blocks where each block is a tuple (chapter number, start position, end position, number of results, size) \"\"\" Books = self . Books slots = flatten ( slotSets ) chart = {} chartOrder = [] if len ( slots ): ( books , booksOrder , bookIds , bookName ) = Books . get ( vr ) ( blocks , blockMapping ) = self . getBlocks ( vr ) results = {} for bl in range ( len ( blocks )): results [ bl ] = 0 for bk in booksOrder : chart [ bk ] = [] chartOrder . append ( bk ) for m in slots : results [ blockMapping [ m ]] += 1 for bl in range ( len ( blocks )): ( bk , chpStart , chpEnd , size ) = blocks [ bl ] r = results [ bl ] chart [ bk ] . append (( chpStart [ 0 ], chpStart [ 1 ], chpEnd [ 1 ], r , size )) return dict ( chart = json . dumps ( chart ), chartOrder = json . dumps ( chartOrder )) get ( self , vr , qw , iidRep ) \u00b6 Get chart data, using the cache. Source code in modules/chart.py def get ( self , vr , qw , iidRep ): \"\"\"Get chart data, using the cache. \"\"\" Caching = current . Caching return Caching . get ( f \"chart_ { vr } _ { qw } _ { iidRep } _\" , lambda : self . get_c ( vr , qw , iidRep ), None , ) getBlocks ( self , vr ) \u00b6 Get info on the 500-word blocks. for each slot: to which block it belongs, for each block: book and chapter number of first word. Possibly there are gaps between books. Source code in modules/chart.py def getBlocks ( self , vr ): \"\"\"Get info on the 500-word blocks. * for each slot: to which block it belongs, * for each block: book and chapter number of first word. Possibly there are gaps between books. \"\"\" Caching = current . Caching return Caching . get ( f \"blocks_ { vr } _\" , lambda : self . getBlocks_c ( vr ), None ) page ( self ) \u00b6 Read request parameters and get chart data ready for the controller. Source code in modules/chart.py def page ( self ): \"\"\"Read request parameters and get chart data ready for the controller. \"\"\" Check = current . Check Record = self . Record vr = Check . field ( \"material\" , \"\" , \"version\" ) mr = Check . field ( \"material\" , \"\" , \"mr\" ) qw = Check . field ( \"material\" , \"\" , \"qw\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) ( authorized , msg ) = Record . authRead ( mr , qw , iidRep ) if not authorized : # produce empty chart result = self . compose ( vr , []) else : result = self . get ( vr , qw , iidRep ) result . update ( qw = qw ) result . update ( msg = msg ) return result","title":"Chart"},{"location":"server/bymodule/chart/#chart","text":"","title":"chart"},{"location":"server/bymodule/chart/#chart.CHART","text":"Make heat maps of lists of items. The items are word occurrences or query results or note set members. We divide the bible in 500-word blocks and count the number of items per block. We present the blocks in a chart, where each block shows the number of items by means of color. The blocks are clickable and move to the chapter in which the first word of the block occurs. See also the client code: {chart} .","title":"CHART"},{"location":"server/bymodule/chart/#chart.CHART.compose","text":"Organize the raw chart data in books and then in blocks.","title":"compose()"},{"location":"server/bymodule/chart/#chart.CHART.compose--returns","text":"dict keyed by book, with values lists of blocks where each block is a tuple (chapter number, start position, end position, number of results, size) Source code in modules/chart.py def compose ( self , vr , slotSets ): \"\"\"Organize the raw chart data in books and then in blocks. Returns ------- dict keyed by book, with values lists of blocks where each block is a tuple (chapter number, start position, end position, number of results, size) \"\"\" Books = self . Books slots = flatten ( slotSets ) chart = {} chartOrder = [] if len ( slots ): ( books , booksOrder , bookIds , bookName ) = Books . get ( vr ) ( blocks , blockMapping ) = self . getBlocks ( vr ) results = {} for bl in range ( len ( blocks )): results [ bl ] = 0 for bk in booksOrder : chart [ bk ] = [] chartOrder . append ( bk ) for m in slots : results [ blockMapping [ m ]] += 1 for bl in range ( len ( blocks )): ( bk , chpStart , chpEnd , size ) = blocks [ bl ] r = results [ bl ] chart [ bk ] . append (( chpStart [ 0 ], chpStart [ 1 ], chpEnd [ 1 ], r , size )) return dict ( chart = json . dumps ( chart ), chartOrder = json . dumps ( chartOrder ))","title":"Returns"},{"location":"server/bymodule/chart/#chart.CHART.get","text":"Get chart data, using the cache. Source code in modules/chart.py def get ( self , vr , qw , iidRep ): \"\"\"Get chart data, using the cache. \"\"\" Caching = current . Caching return Caching . get ( f \"chart_ { vr } _ { qw } _ { iidRep } _\" , lambda : self . get_c ( vr , qw , iidRep ), None , )","title":"get()"},{"location":"server/bymodule/chart/#chart.CHART.getBlocks","text":"Get info on the 500-word blocks. for each slot: to which block it belongs, for each block: book and chapter number of first word. Possibly there are gaps between books. Source code in modules/chart.py def getBlocks ( self , vr ): \"\"\"Get info on the 500-word blocks. * for each slot: to which block it belongs, * for each block: book and chapter number of first word. Possibly there are gaps between books. \"\"\" Caching = current . Caching return Caching . get ( f \"blocks_ { vr } _\" , lambda : self . getBlocks_c ( vr ), None )","title":"getBlocks()"},{"location":"server/bymodule/chart/#chart.CHART.page","text":"Read request parameters and get chart data ready for the controller. Source code in modules/chart.py def page ( self ): \"\"\"Read request parameters and get chart data ready for the controller. \"\"\" Check = current . Check Record = self . Record vr = Check . field ( \"material\" , \"\" , \"version\" ) mr = Check . field ( \"material\" , \"\" , \"mr\" ) qw = Check . field ( \"material\" , \"\" , \"qw\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) ( authorized , msg ) = Record . authRead ( mr , qw , iidRep ) if not authorized : # produce empty chart result = self . compose ( vr , []) else : result = self . get ( vr , qw , iidRep ) result . update ( qw = qw ) result . update ( msg = msg ) return result","title":"page()"},{"location":"server/bymodule/constants/","text":"constants \u00b6 NOTFILLFIELDS \u00b6 Fields that, when represented in HTML, should not be filled with a non breaking space when empty. NULLDT \u00b6 Empty date time representation. PUBLISH_FREEZE \u00b6 Time interval after which publishing is irrevocable. TPS \u00b6 Types of records in query tree view.","title":"Constants"},{"location":"server/bymodule/constants/#constants","text":"","title":"constants"},{"location":"server/bymodule/constants/#constants.NOTFILLFIELDS","text":"Fields that, when represented in HTML, should not be filled with a non breaking space when empty.","title":"NOTFILLFIELDS"},{"location":"server/bymodule/constants/#constants.NULLDT","text":"Empty date time representation.","title":"NULLDT"},{"location":"server/bymodule/constants/#constants.PUBLISH_FREEZE","text":"Time interval after which publishing is irrevocable.","title":"PUBLISH_FREEZE"},{"location":"server/bymodule/constants/#constants.TPS","text":"Types of records in query tree view.","title":"TPS"},{"location":"server/bymodule/csvdata/","text":"csvdata \u00b6 CSVDATA \u00b6 Produces various kinds of csv exports of lists of items. Items are word occirrences, query results or noteset members. get ( self , vr , mr , qw , iid , keywords , tp , extra , hebrewFields , fileName ) \u00b6 Get csv data as specified by parameters. Source code in modules/csvdata.py def get ( self , vr , mr , qw , iid , keywords , tp , extra , hebrewFields , fileName ): \"\"\"Get csv data as specified by parameters. \"\"\" Word = self . Word Query = self . Query auth = current . auth PASSAGE_DBS = current . PASSAGE_DBS if extra : extra = \"_\" + extra if len ( extra ) > 64 : extra = extra [ 0 : 64 ] headRow = [ \"book\" , \"chapter\" , \"verse\" ] + [ hf [ 1 ] for hf in hebrewFields ] if qw == \"n\" : keywordsSql = keywords . replace ( \"'\" , \"''\" ) myId = auth . user . id if auth . user is not None else None extra = \"\" if myId is None else f \" or created_by = { myId } \" hflist = \", \" . join ( hf [ 0 ] for hf in hebrewFields ) sql = dedent ( f \"\"\" select shebanq_note.note.book, shebanq_note.note.chapter, shebanq_note.note.verse, { hflist } from shebanq_note.note inner join book on shebanq_note.note.book = book.name inner join clause_atom on clause_atom.ca_num = shebanq_note.note.clause_atom and clause_atom.book_id = book.id where shebanq_note.note.keywords like '% { keywordsSql } %' and shebanq_note.note.version = ' { vr } ' and (shebanq_note.note.is_shared = 'T' { extra } ) ; \"\"\" ) dataRows = PASSAGE_DBS [ vr ] . executesql ( sql ) if vr in PASSAGE_DBS else [] else : ( nSlots , slotSets ) = ( Query . read ( vr , iid ) if qw == \"q\" else Word . read ( vr , iid ) ) slots = flatten ( slotSets ) dataRows = [] if len ( slots ): hflist = \", \" . join ( f \"word. { hf [ 0 ] } \" for hf in hebrewFields ) slotsVal = \",\" . join ( str ( x ) for x in slots ) sql = dedent ( f \"\"\" select book.name, chapter.chapter_num, verse.verse_num, { hflist } from word inner join word_verse on word_verse.anchor = word.word_number inner join verse on verse.id = word_verse.verse_id inner join chapter on verse.chapter_id = chapter.id inner join book on chapter.book_id = book.id where word.word_number in ( { slotsVal } ) order by word.word_number ; \"\"\" ) dataRows = PASSAGE_DBS [ vr ] . executesql ( sql ) if vr in PASSAGE_DBS else [] allRows = csv ([ headRow ] + list ( dataRows )) return allRows page ( self ) \u00b6 Read request parameters and get the data and ready for the controller. Source code in modules/csvdata.py def page ( self ): \"\"\"Read request parameters and get the data and ready for the controller. \"\"\" ViewDefs = current . ViewDefs Check = current . Check Record = self . Record vr = Check . field ( \"material\" , \"\" , \"version\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) mr = Check . field ( \"material\" , \"\" , \"mr\" ) qw = Check . field ( \"material\" , \"\" , \"qw\" ) tp = Check . field ( \"material\" , \"\" , \"tp\" ) extra = Check . field ( \"rest\" , \"\" , \"extra\" ) ( iid , keywords ) = iDecode ( qw , iidRep ) iidRep2 = iDecode ( qw , iidRep , rsep = \" \" ) itemStyle = ViewDefs . itemStyle tabLabels = ViewDefs . tabLabels fileName = f \" { vr } _ { itemStyle [ qw ][ 't' ] }{ iidRep2 } _ { tabLabels [ tp ] }{ extra } .csv\" ( authorized , msg ) = Record . authRead ( mr , qw , iidRep ) if not authorized : return dict ( fileName = fileName , data = msg ) hebrewFields = Check . fields ( tp , qw = qw ) data = self . get ( vr , mr , qw , iid , keywords , tp , extra , hebrewFields , fileName ) return dict ( fileName = fileName , data = data ) csv ( data ) \u00b6 converts an data structure of rows and fields into a csv string. With proper quotations and escapes Source code in modules/csvdata.py def csv ( data ): \"\"\"converts an data structure of rows and fields into a csv string. With proper quotations and escapes \"\"\" result = [] if data is not None : for row in data : prow = [ str ( x ) for x in row ] trow = [ f '''\" { x . replace ( '\"' , '\"\"' ) } \"''' if '\"' in x or \",\" in x else x for x in prow ] result . append (( \",\" . join ( trow )) . replace ( \" \\n \" , \" \" ) . replace ( \" \\r \" , \" \" )) return \" \\n \" . join ( result )","title":"Csvdata"},{"location":"server/bymodule/csvdata/#csvdata","text":"","title":"csvdata"},{"location":"server/bymodule/csvdata/#csvdata.CSVDATA","text":"Produces various kinds of csv exports of lists of items. Items are word occirrences, query results or noteset members.","title":"CSVDATA"},{"location":"server/bymodule/csvdata/#csvdata.CSVDATA.get","text":"Get csv data as specified by parameters. Source code in modules/csvdata.py def get ( self , vr , mr , qw , iid , keywords , tp , extra , hebrewFields , fileName ): \"\"\"Get csv data as specified by parameters. \"\"\" Word = self . Word Query = self . Query auth = current . auth PASSAGE_DBS = current . PASSAGE_DBS if extra : extra = \"_\" + extra if len ( extra ) > 64 : extra = extra [ 0 : 64 ] headRow = [ \"book\" , \"chapter\" , \"verse\" ] + [ hf [ 1 ] for hf in hebrewFields ] if qw == \"n\" : keywordsSql = keywords . replace ( \"'\" , \"''\" ) myId = auth . user . id if auth . user is not None else None extra = \"\" if myId is None else f \" or created_by = { myId } \" hflist = \", \" . join ( hf [ 0 ] for hf in hebrewFields ) sql = dedent ( f \"\"\" select shebanq_note.note.book, shebanq_note.note.chapter, shebanq_note.note.verse, { hflist } from shebanq_note.note inner join book on shebanq_note.note.book = book.name inner join clause_atom on clause_atom.ca_num = shebanq_note.note.clause_atom and clause_atom.book_id = book.id where shebanq_note.note.keywords like '% { keywordsSql } %' and shebanq_note.note.version = ' { vr } ' and (shebanq_note.note.is_shared = 'T' { extra } ) ; \"\"\" ) dataRows = PASSAGE_DBS [ vr ] . executesql ( sql ) if vr in PASSAGE_DBS else [] else : ( nSlots , slotSets ) = ( Query . read ( vr , iid ) if qw == \"q\" else Word . read ( vr , iid ) ) slots = flatten ( slotSets ) dataRows = [] if len ( slots ): hflist = \", \" . join ( f \"word. { hf [ 0 ] } \" for hf in hebrewFields ) slotsVal = \",\" . join ( str ( x ) for x in slots ) sql = dedent ( f \"\"\" select book.name, chapter.chapter_num, verse.verse_num, { hflist } from word inner join word_verse on word_verse.anchor = word.word_number inner join verse on verse.id = word_verse.verse_id inner join chapter on verse.chapter_id = chapter.id inner join book on chapter.book_id = book.id where word.word_number in ( { slotsVal } ) order by word.word_number ; \"\"\" ) dataRows = PASSAGE_DBS [ vr ] . executesql ( sql ) if vr in PASSAGE_DBS else [] allRows = csv ([ headRow ] + list ( dataRows )) return allRows","title":"get()"},{"location":"server/bymodule/csvdata/#csvdata.CSVDATA.page","text":"Read request parameters and get the data and ready for the controller. Source code in modules/csvdata.py def page ( self ): \"\"\"Read request parameters and get the data and ready for the controller. \"\"\" ViewDefs = current . ViewDefs Check = current . Check Record = self . Record vr = Check . field ( \"material\" , \"\" , \"version\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) mr = Check . field ( \"material\" , \"\" , \"mr\" ) qw = Check . field ( \"material\" , \"\" , \"qw\" ) tp = Check . field ( \"material\" , \"\" , \"tp\" ) extra = Check . field ( \"rest\" , \"\" , \"extra\" ) ( iid , keywords ) = iDecode ( qw , iidRep ) iidRep2 = iDecode ( qw , iidRep , rsep = \" \" ) itemStyle = ViewDefs . itemStyle tabLabels = ViewDefs . tabLabels fileName = f \" { vr } _ { itemStyle [ qw ][ 't' ] }{ iidRep2 } _ { tabLabels [ tp ] }{ extra } .csv\" ( authorized , msg ) = Record . authRead ( mr , qw , iidRep ) if not authorized : return dict ( fileName = fileName , data = msg ) hebrewFields = Check . fields ( tp , qw = qw ) data = self . get ( vr , mr , qw , iid , keywords , tp , extra , hebrewFields , fileName ) return dict ( fileName = fileName , data = data )","title":"page()"},{"location":"server/bymodule/csvdata/#csvdata.csv","text":"converts an data structure of rows and fields into a csv string. With proper quotations and escapes Source code in modules/csvdata.py def csv ( data ): \"\"\"converts an data structure of rows and fields into a csv string. With proper quotations and escapes \"\"\" result = [] if data is not None : for row in data : prow = [ str ( x ) for x in row ] trow = [ f '''\" { x . replace ( '\"' , '\"\"' ) } \"''' if '\"' in x or \",\" in x else x for x in prow ] result . append (( \",\" . join ( trow )) . replace ( \" \\n \" , \" \" ) . replace ( \" \\r \" , \" \" )) return \" \\n \" . join ( result )","title":"csv()"},{"location":"server/bymodule/dbconfig/","text":"dbconfig \u00b6 CONFIG \u00b6 Connection details for the databases. EMDROS_VERSIONS \u00b6 Emdros versions that have been in use by SHEBANQ. Copied manually from /opt/emdros/include/emdros/version-emdros.h","title":"Dbconfig"},{"location":"server/bymodule/dbconfig/#dbconfig","text":"","title":"dbconfig"},{"location":"server/bymodule/dbconfig/#dbconfig.CONFIG","text":"Connection details for the databases.","title":"CONFIG"},{"location":"server/bymodule/dbconfig/#dbconfig.EMDROS_VERSIONS","text":"Emdros versions that have been in use by SHEBANQ. Copied manually from /opt/emdros/include/emdros/version-emdros.h","title":"EMDROS_VERSIONS"},{"location":"server/bymodule/helpers/","text":"helpers \u00b6","title":"Helpers"},{"location":"server/bymodule/helpers/#helpers","text":"","title":"helpers"},{"location":"server/bymodule/materials/","text":"materials \u00b6","title":"Materials"},{"location":"server/bymodule/materials/#materials","text":"","title":"materials"},{"location":"server/bymodule/mql/","text":"mql \u00b6","title":"Mql"},{"location":"server/bymodule/mql/#mql","text":"","title":"mql"},{"location":"server/bymodule/note/","text":"note \u00b6 NOTE \u00b6 Handles notes. body ( self ) \u00b6 Retrieves a note set record based on parameters. Source code in modules/note.py def body ( self ): \"\"\"Retrieves a note set record based on parameters. \"\"\" Check = current . Check vr = Check . field ( \"material\" , \"\" , \"version\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) ( iid , keywords ) = iDecode ( \"n\" , iidRep ) msgs = [] if not iid : msg = f \"Not a valid note id: { iid } \" msgs . append (( \"error\" , msg )) return dict ( noteRecord = dict (), note = json . dumps ( dict ()), msgs = json . dumps ( msgs ), ) noteRecord = self . getInfo ( iidRep , vr , msgs ) return dict ( vr = vr , noteRecord = noteRecord , note = json . dumps ( noteRecord ), msgs = json . dumps ( msgs ), ) getVerseNotes ( self ) \u00b6 Get the notes belonging to a single verse. Reads request parameters to determine which verse. Source code in modules/note.py def getVerseNotes ( self ): \"\"\"Get the notes belonging to a single verse. Reads request parameters to determine which verse. \"\"\" Check = current . Check auth = current . auth vr = Check . field ( \"material\" , \"\" , \"version\" ) bk = Check . field ( \"material\" , \"\" , \"book\" ) ch = Check . field ( \"material\" , \"\" , \"chapter\" ) vs = Check . field ( \"material\" , \"\" , \"verse\" ) edit = Check . isBool ( \"edit\" ) myId = None if auth . user : myId = auth . user . id authenticated = myId is not None clauseAtoms = self . getClauseAtoms ( vr , bk , ch , vs ) changed = False msgs = [] return self . inVerse ( vr , bk , ch , vs , myId , clauseAtoms , changed , msgs , authenticated , edit )","title":"Note"},{"location":"server/bymodule/note/#note","text":"","title":"note"},{"location":"server/bymodule/note/#note.NOTE","text":"Handles notes.","title":"NOTE"},{"location":"server/bymodule/note/#note.NOTE.body","text":"Retrieves a note set record based on parameters. Source code in modules/note.py def body ( self ): \"\"\"Retrieves a note set record based on parameters. \"\"\" Check = current . Check vr = Check . field ( \"material\" , \"\" , \"version\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) ( iid , keywords ) = iDecode ( \"n\" , iidRep ) msgs = [] if not iid : msg = f \"Not a valid note id: { iid } \" msgs . append (( \"error\" , msg )) return dict ( noteRecord = dict (), note = json . dumps ( dict ()), msgs = json . dumps ( msgs ), ) noteRecord = self . getInfo ( iidRep , vr , msgs ) return dict ( vr = vr , noteRecord = noteRecord , note = json . dumps ( noteRecord ), msgs = json . dumps ( msgs ), )","title":"body()"},{"location":"server/bymodule/note/#note.NOTE.getVerseNotes","text":"Get the notes belonging to a single verse. Reads request parameters to determine which verse. Source code in modules/note.py def getVerseNotes ( self ): \"\"\"Get the notes belonging to a single verse. Reads request parameters to determine which verse. \"\"\" Check = current . Check auth = current . auth vr = Check . field ( \"material\" , \"\" , \"version\" ) bk = Check . field ( \"material\" , \"\" , \"book\" ) ch = Check . field ( \"material\" , \"\" , \"chapter\" ) vs = Check . field ( \"material\" , \"\" , \"verse\" ) edit = Check . isBool ( \"edit\" ) myId = None if auth . user : myId = auth . user . id authenticated = myId is not None clauseAtoms = self . getClauseAtoms ( vr , bk , ch , vs ) changed = False msgs = [] return self . inVerse ( vr , bk , ch , vs , myId , clauseAtoms , changed , msgs , authenticated , edit )","title":"getVerseNotes()"},{"location":"server/bymodule/notesave/","text":"notesave \u00b6 NOTESAVE \u00b6 putVerseNotes ( self ) \u00b6 Save notes. Reads request parameters to determine which notes for which verse. Source code in modules/notesave.py def putVerseNotes ( self ): \"\"\"Save notes. Reads request parameters to determine which notes for which verse. \"\"\" Check = current . Check Note = self . Note auth = current . auth vr = Check . field ( \"material\" , \"\" , \"version\" ) bk = Check . field ( \"material\" , \"\" , \"book\" ) ch = Check . field ( \"material\" , \"\" , \"chapter\" ) vs = Check . field ( \"material\" , \"\" , \"verse\" ) edit = Check . isBool ( \"edit\" ) myId = None if auth . user : myId = auth . user . id authenticated = myId is not None clauseAtoms = Note . getClauseAtoms ( vr , bk , ch , vs ) changed = False msgs = [] if myId is None : msgs . append (( \"error\" , \"You have to be logged in when you save notes\" )) else : requestVars = current . request . vars notes = ( json . loads ( requestVars . notes ) if requestVars and requestVars . notes else [] ) changed = self . put ( myId , vr , bk , ch , vs , notes , clauseAtoms , msgs ) return Note . inVerse ( vr , bk , ch , vs , myId , clauseAtoms , changed , msgs , authenticated , edit )","title":"Notesave"},{"location":"server/bymodule/notesave/#notesave","text":"","title":"notesave"},{"location":"server/bymodule/notesave/#notesave.NOTESAVE","text":"","title":"NOTESAVE"},{"location":"server/bymodule/notesave/#notesave.NOTESAVE.putVerseNotes","text":"Save notes. Reads request parameters to determine which notes for which verse. Source code in modules/notesave.py def putVerseNotes ( self ): \"\"\"Save notes. Reads request parameters to determine which notes for which verse. \"\"\" Check = current . Check Note = self . Note auth = current . auth vr = Check . field ( \"material\" , \"\" , \"version\" ) bk = Check . field ( \"material\" , \"\" , \"book\" ) ch = Check . field ( \"material\" , \"\" , \"chapter\" ) vs = Check . field ( \"material\" , \"\" , \"verse\" ) edit = Check . isBool ( \"edit\" ) myId = None if auth . user : myId = auth . user . id authenticated = myId is not None clauseAtoms = Note . getClauseAtoms ( vr , bk , ch , vs ) changed = False msgs = [] if myId is None : msgs . append (( \"error\" , \"You have to be logged in when you save notes\" )) else : requestVars = current . request . vars notes = ( json . loads ( requestVars . notes ) if requestVars and requestVars . notes else [] ) changed = self . put ( myId , vr , bk , ch , vs , notes , clauseAtoms , msgs ) return Note . inVerse ( vr , bk , ch , vs , myId , clauseAtoms , changed , msgs , authenticated , edit )","title":"putVerseNotes()"},{"location":"server/bymodule/notesupload/","text":"notesupload \u00b6 NOTESUPLOAD \u00b6 Handles bulk uploads of notes. upload ( self ) \u00b6 Checks a set of uploaded notes and stores them. Source code in modules/notesupload.py def upload ( self ): \"\"\"Checks a set of uploaded notes and stores them. \"\"\" Books = self . Books ViewDefs = current . ViewDefs Note = self . Note fileText = current . request . vars . file good = True ( authorized , myId , msg ) = Note . authUpload () if not authorized : return dict ( data = json . dumps ( dict ( msgs = [( \"error\" , msg )], good = False ))) Caching = current . Caching NOTE_DB = current . NOTE_DB VERSIONS = current . VERSIONS msgs = [] myVersions = set () bookInfo = {} for vr in VERSIONS : myVersions . add ( vr ) bookInfo [ vr ] = Books . get ( vr )[ 0 ] normFields = \" \\t \" . join ( \"\"\" version book chapter verse clause_atom is_shared is_published status keywords ntext \"\"\" . strip () . split () ) good = True fieldnames = normFields . split ( \" \\t \" ) nfields = len ( fieldnames ) errors = {} allKeywords = set () allVersions = set () now = current . request . utcnow created_on = now modified_on = now nerrors = 0 chunks = [] chunksize = 100 sqlhead = dedent ( f \"\"\" insert into note ( { \", \" . join ( fieldnames ) } , created_by, created_on, modified_on, shared_on, published_on, bulk) values \"\"\" ) thisChunk = [] thisI = 0 for ( i , linenl ) in enumerate ( fileText . value . decode ( \"utf8\" ) . split ( \" \\n \" )): line = linenl . rstrip () if line == \"\" : continue if i == 0 : if line != normFields : msgs . append ( [ \"error\" , ( f \"Wrong fields: { line } . \" f \"Required fields are { normFields } \" ), ] ) good = False break continue fields = line . replace ( \"'\" , \"''\" ) . split ( \" \\t \" ) if len ( fields ) != nfields : nerrors += 1 errors . setdefault ( \"wrong number of fields\" , []) . append ( i + 1 ) continue ( version , book , chapter , verse , clause_atom , is_shared , is_published , status , keywords , ntext , ) = fields published_on = \"NULL\" shared_on = \"NULL\" if version not in myVersions : nerrors += 1 errors . setdefault ( \"unrecognized version\" , []) . append ( f \" { i + 1 } : { version } \" ) continue books = bookInfo [ version ] if book not in books : nerrors += 1 errors . setdefault ( \"unrecognized book\" , []) . append ( f \" { i + 1 } : { book } \" ) continue maxChapter = books [ book ] if not chapter . isdigit () or int ( chapter ) > maxChapter : nerrors += 1 errors . setdefault ( \"unrecognized chapter\" , []) . append ( f \" { i + 1 } : { chapter } \" ) continue if not verse . isdigit () or int ( verse ) > 200 : nerrors += 1 errors . setdefault ( \"unrecognized verse\" , []) . append ( f \" { i + 1 } : { verse } \" ) continue if not clause_atom . isdigit () or int ( clause_atom ) > 100000 : nerrors += 1 errors . setdefault ( \"unrecognized clause_atom\" , []) . append ( f \" { i + 1 } : { clause_atom } \" ) continue if is_shared not in { \"T\" , \"\" }: nerrors += 1 errors . setdefault ( \"unrecognized shared field\" , []) . append ( f \" { i + 1 } : { is_shared } \" ) continue if is_published not in { \"T\" , \"\" }: nerrors += 1 errors . setdefault ( \"unrecognized published field\" , []) . append ( f \" { i + 1 } : { is_published } \" ) continue if status not in ViewDefs . noteStatusCls : nerrors += 1 errors . setdefault ( \"unrecognized status\" , []) . append ( f \" { i + 1 } : { status } \" ) continue if len ( keywords ) >= 128 : nerrors += 1 errors . setdefault ( \"keywords length over 128\" , []) . append ( f \" { i + 1 } : { len ( keywords ) } \" ) continue if len ( ntext ) >= 1024 : nerrors += 1 errors . setdefault ( \"note text length over 1024\" , []) . append ( f \" { i + 1 } : { len ( ntext ) } \" ) continue if nerrors > 20 : msgs . append ([ \"error\" , \"too many errors, aborting\" ]) break if is_shared == \"T\" : shared_on = f \"' { now } '\" if is_published == \"T\" : published_on = f \"' { now } '\" keywordList = keywords . split () if len ( keywordList ) == 0 : errors . setdefault ( \"empty keyword\" , []) . append ( f ' { i + 1 } :\" { keywords } \"' ) continue allKeywords |= set ( keywordList ) keywords = \"\" . join ( f \" { x } \" for x in keywordList ) allVersions . add ( version ) thisChunk . append ( ( f \"(' { version } ',' { book } ', { chapter } , { verse } , { clause_atom } ,\" f \"' { is_shared } ',' { is_published } ',\" f \"' { status } ',' { keywords } ',' { ntext } ', { myId } ,\" f \"' { created_on } ',' { modified_on } ', { shared_on } , { published_on } ,'b')\" ) ) thisI += 1 if thisI >= chunksize : chunks . append ( thisChunk ) thisChunk = [] thisI = 0 if len ( thisChunk ): chunks . append ( thisChunk ) # with open('/tmp/xxx.txt', 'w') as fh: # for line in fileText.value: # fh.write(line) if errors or nerrors : good = False else : avrep = \"', '\" . join ( allVersions ) whereVersion = f \"version in (' { avrep } ')\" whereKeywords = \" or \" . join ( f \" keywords like '% { keyword } %' \" for keyword in keywordList ) # first delete previously bulk uploaded notes by this author # and with these keywords and these versions delSql = dedent ( f \"\"\" delete from note where bulk = 'b' and created_by = { myId } and { whereVersion } and { whereKeywords } ; \"\"\" ) NOTE_DB . executesql ( delSql ) NOTE_DB . commit () for chunk in chunks : chunkRep = \", \\n \" . join ( chunk ) sql = f \" { sqlhead } { chunkRep } ;\" NOTE_DB . executesql ( sql ) NOTE_DB . commit () Caching . clear ( r \"^items_n_\" ) for vr in myVersions : Caching . clear ( f \"^verses_ { vr } _n_\" ) for msg in sorted ( errors ): istr = \",\" . join ( str ( i ) for i in errors [ msg ]) msgs . append ([ \"error\" , f \" { msg } : { istr } \" ]) msgs . append ([ \"good\" if good else \"error\" , \"Done\" ]) return dict ( data = json . dumps ( dict ( msgs = msgs , good = good )))","title":"Notesupload"},{"location":"server/bymodule/notesupload/#notesupload","text":"","title":"notesupload"},{"location":"server/bymodule/notesupload/#notesupload.NOTESUPLOAD","text":"Handles bulk uploads of notes.","title":"NOTESUPLOAD"},{"location":"server/bymodule/notesupload/#notesupload.NOTESUPLOAD.upload","text":"Checks a set of uploaded notes and stores them. Source code in modules/notesupload.py def upload ( self ): \"\"\"Checks a set of uploaded notes and stores them. \"\"\" Books = self . Books ViewDefs = current . ViewDefs Note = self . Note fileText = current . request . vars . file good = True ( authorized , myId , msg ) = Note . authUpload () if not authorized : return dict ( data = json . dumps ( dict ( msgs = [( \"error\" , msg )], good = False ))) Caching = current . Caching NOTE_DB = current . NOTE_DB VERSIONS = current . VERSIONS msgs = [] myVersions = set () bookInfo = {} for vr in VERSIONS : myVersions . add ( vr ) bookInfo [ vr ] = Books . get ( vr )[ 0 ] normFields = \" \\t \" . join ( \"\"\" version book chapter verse clause_atom is_shared is_published status keywords ntext \"\"\" . strip () . split () ) good = True fieldnames = normFields . split ( \" \\t \" ) nfields = len ( fieldnames ) errors = {} allKeywords = set () allVersions = set () now = current . request . utcnow created_on = now modified_on = now nerrors = 0 chunks = [] chunksize = 100 sqlhead = dedent ( f \"\"\" insert into note ( { \", \" . join ( fieldnames ) } , created_by, created_on, modified_on, shared_on, published_on, bulk) values \"\"\" ) thisChunk = [] thisI = 0 for ( i , linenl ) in enumerate ( fileText . value . decode ( \"utf8\" ) . split ( \" \\n \" )): line = linenl . rstrip () if line == \"\" : continue if i == 0 : if line != normFields : msgs . append ( [ \"error\" , ( f \"Wrong fields: { line } . \" f \"Required fields are { normFields } \" ), ] ) good = False break continue fields = line . replace ( \"'\" , \"''\" ) . split ( \" \\t \" ) if len ( fields ) != nfields : nerrors += 1 errors . setdefault ( \"wrong number of fields\" , []) . append ( i + 1 ) continue ( version , book , chapter , verse , clause_atom , is_shared , is_published , status , keywords , ntext , ) = fields published_on = \"NULL\" shared_on = \"NULL\" if version not in myVersions : nerrors += 1 errors . setdefault ( \"unrecognized version\" , []) . append ( f \" { i + 1 } : { version } \" ) continue books = bookInfo [ version ] if book not in books : nerrors += 1 errors . setdefault ( \"unrecognized book\" , []) . append ( f \" { i + 1 } : { book } \" ) continue maxChapter = books [ book ] if not chapter . isdigit () or int ( chapter ) > maxChapter : nerrors += 1 errors . setdefault ( \"unrecognized chapter\" , []) . append ( f \" { i + 1 } : { chapter } \" ) continue if not verse . isdigit () or int ( verse ) > 200 : nerrors += 1 errors . setdefault ( \"unrecognized verse\" , []) . append ( f \" { i + 1 } : { verse } \" ) continue if not clause_atom . isdigit () or int ( clause_atom ) > 100000 : nerrors += 1 errors . setdefault ( \"unrecognized clause_atom\" , []) . append ( f \" { i + 1 } : { clause_atom } \" ) continue if is_shared not in { \"T\" , \"\" }: nerrors += 1 errors . setdefault ( \"unrecognized shared field\" , []) . append ( f \" { i + 1 } : { is_shared } \" ) continue if is_published not in { \"T\" , \"\" }: nerrors += 1 errors . setdefault ( \"unrecognized published field\" , []) . append ( f \" { i + 1 } : { is_published } \" ) continue if status not in ViewDefs . noteStatusCls : nerrors += 1 errors . setdefault ( \"unrecognized status\" , []) . append ( f \" { i + 1 } : { status } \" ) continue if len ( keywords ) >= 128 : nerrors += 1 errors . setdefault ( \"keywords length over 128\" , []) . append ( f \" { i + 1 } : { len ( keywords ) } \" ) continue if len ( ntext ) >= 1024 : nerrors += 1 errors . setdefault ( \"note text length over 1024\" , []) . append ( f \" { i + 1 } : { len ( ntext ) } \" ) continue if nerrors > 20 : msgs . append ([ \"error\" , \"too many errors, aborting\" ]) break if is_shared == \"T\" : shared_on = f \"' { now } '\" if is_published == \"T\" : published_on = f \"' { now } '\" keywordList = keywords . split () if len ( keywordList ) == 0 : errors . setdefault ( \"empty keyword\" , []) . append ( f ' { i + 1 } :\" { keywords } \"' ) continue allKeywords |= set ( keywordList ) keywords = \"\" . join ( f \" { x } \" for x in keywordList ) allVersions . add ( version ) thisChunk . append ( ( f \"(' { version } ',' { book } ', { chapter } , { verse } , { clause_atom } ,\" f \"' { is_shared } ',' { is_published } ',\" f \"' { status } ',' { keywords } ',' { ntext } ', { myId } ,\" f \"' { created_on } ',' { modified_on } ', { shared_on } , { published_on } ,'b')\" ) ) thisI += 1 if thisI >= chunksize : chunks . append ( thisChunk ) thisChunk = [] thisI = 0 if len ( thisChunk ): chunks . append ( thisChunk ) # with open('/tmp/xxx.txt', 'w') as fh: # for line in fileText.value: # fh.write(line) if errors or nerrors : good = False else : avrep = \"', '\" . join ( allVersions ) whereVersion = f \"version in (' { avrep } ')\" whereKeywords = \" or \" . join ( f \" keywords like '% { keyword } %' \" for keyword in keywordList ) # first delete previously bulk uploaded notes by this author # and with these keywords and these versions delSql = dedent ( f \"\"\" delete from note where bulk = 'b' and created_by = { myId } and { whereVersion } and { whereKeywords } ; \"\"\" ) NOTE_DB . executesql ( delSql ) NOTE_DB . commit () for chunk in chunks : chunkRep = \", \\n \" . join ( chunk ) sql = f \" { sqlhead } { chunkRep } ;\" NOTE_DB . executesql ( sql ) NOTE_DB . commit () Caching . clear ( r \"^items_n_\" ) for vr in myVersions : Caching . clear ( f \"^verses_ { vr } _n_\" ) for msg in sorted ( errors ): istr = \",\" . join ( str ( i ) for i in errors [ msg ]) msgs . append ([ \"error\" , f \" { msg } : { istr } \" ]) msgs . append ([ \"good\" if good else \"error\" , \"Done\" ]) return dict ( data = json . dumps ( dict ( msgs = msgs , good = good )))","title":"upload()"},{"location":"server/bymodule/notetree/","text":"notetree \u00b6 NOTETREE \u00b6 get ( self ) \u00b6 Get the metadata of all queries and deliver it as json. Source code in modules/notetree.py def get ( self ): \"\"\"Get the metadata of all queries and deliver it as json. \"\"\" auth = current . auth NOTE_DB = current . NOTE_DB VERSION_ORDER = current . VERSION_ORDER VERSION_INDEX = current . VERSION_INDEX myId = None if auth . user : myId = auth . user . id objInfo = collections . defaultdict ( lambda : {}) def titleBadge ( obj_id , objType , tot ): name = objInfo [ objType ][ obj_id ] if objType is not None else \"Shared Notes\" badge = \"\" if tot != 0 : badge = f '<span class=\"total special\"> { tot } </span>' return f '<span n=\"1\"> { hEsc ( name ) } </span><span class=\"brn\">( { badge } )</span>' condition = ( dedent ( \"\"\" where note.is_shared = 'T' \"\"\" ) if myId is None else dedent ( f \"\"\" where note.is_shared = 'T' or note.created_by = { myId } \"\"\" ) ) projectNoteSql = dedent ( f \"\"\" select count(note.id) as amount, note.version, note.keywords, concat(auth_user.first_name, ' ', auth_user.last_name) as uname, auth_user.id as user_id from note inner join shebanq_web.auth_user on note.created_by = shebanq_web.auth_user.id { condition } group by auth_user.id, note.keywords, note.version order by shebanq_web.auth_user.last_name, shebanq_web.auth_user.first_name, note.keywords ; \"\"\" ) projectNote = NOTE_DB . executesql ( projectNoteSql ) projectNotes = collections . OrderedDict () for ( amount , nvr , keywordList , uname , user_id ) in projectNote : for keywords in set ( keywordList . strip () . split ()): key_id = iEncode ( \"n\" , user_id , keywords = keywords ) if key_id not in projectNotes : projectNotes [ key_id ] = { \"\" : ( uname , user_id , keywords ), \"v\" : [ 0 for v in VERSION_ORDER ], } projectNotes [ key_id ][ \"v\" ][ VERSION_INDEX [ nvr ]] = amount tree = collections . OrderedDict () countSet = collections . defaultdict ( lambda : set ()) countUser = collections . defaultdict ( lambda : 0 ) count = 0 for key_id in projectNotes : projectNoteInfo = projectNotes [ key_id ] ( uname , user_id , noteName ) = projectNoteInfo [ \"\" ] countSet [ \"u\" ] . add ( user_id ) countSet [ \"n\" ] . add ( key_id ) objInfo [ \"u\" ][ user_id ] = uname tree . setdefault ( user_id , []) . append ( key_id ) count += 1 countUser [ user_id ] += 1 objInfo [ \"u\" ][ 0 ] = \"\" objInfo [ \"n\" ] = projectNotes categoryCount = dict (( x [ 0 ], len ( x [ 1 ])) for x in countSet . items ()) categoryCount [ \"user_id\" ] = myId title = titleBadge ( None , None , count ) dest = [ dict ( title = str ( title ), folder = True , children = [], data = categoryCount )] curDest = dest [ - 1 ][ \"children\" ] curSource = tree for user_id in curSource : userTotal = countUser [ user_id ] userTitle = titleBadge ( user_id , \"u\" , userTotal ) curDest . append ( dict ( title = str ( userTitle ), folder = True , children = [])) curUserDest = curDest [ - 1 ][ \"children\" ] curUserSource = curSource [ user_id ] for key_id in curUserSource : projectNoteInfo = objInfo [ \"n\" ][ key_id ] ( uname , user_id , noteName ) = projectNoteInfo [ \"\" ] noteVersions = projectNoteInfo [ \"v\" ] versionRep = \" \" . join ( formatVersion ( \"n\" , key_id , v , noteVersions [ VERSION_INDEX [ v ]]) for v in VERSION_ORDER ) curUserDest . append ( dict ( title = ( f \"\"\" { versionRep } <a class=\"n keywords\" n=\"1\" key_id=\" { key_id } \" href=\"#\" > { hEsc ( noteName ) } </a> <a class=\"md\" href=\"#\"></a>\"\"\" ), key = f \"n { key_id } \" , folder = False , ), ) return dict ( data = json . dumps ( dest ))","title":"Notetree"},{"location":"server/bymodule/notetree/#notetree","text":"","title":"notetree"},{"location":"server/bymodule/notetree/#notetree.NOTETREE","text":"","title":"NOTETREE"},{"location":"server/bymodule/notetree/#notetree.NOTETREE.get","text":"Get the metadata of all queries and deliver it as json. Source code in modules/notetree.py def get ( self ): \"\"\"Get the metadata of all queries and deliver it as json. \"\"\" auth = current . auth NOTE_DB = current . NOTE_DB VERSION_ORDER = current . VERSION_ORDER VERSION_INDEX = current . VERSION_INDEX myId = None if auth . user : myId = auth . user . id objInfo = collections . defaultdict ( lambda : {}) def titleBadge ( obj_id , objType , tot ): name = objInfo [ objType ][ obj_id ] if objType is not None else \"Shared Notes\" badge = \"\" if tot != 0 : badge = f '<span class=\"total special\"> { tot } </span>' return f '<span n=\"1\"> { hEsc ( name ) } </span><span class=\"brn\">( { badge } )</span>' condition = ( dedent ( \"\"\" where note.is_shared = 'T' \"\"\" ) if myId is None else dedent ( f \"\"\" where note.is_shared = 'T' or note.created_by = { myId } \"\"\" ) ) projectNoteSql = dedent ( f \"\"\" select count(note.id) as amount, note.version, note.keywords, concat(auth_user.first_name, ' ', auth_user.last_name) as uname, auth_user.id as user_id from note inner join shebanq_web.auth_user on note.created_by = shebanq_web.auth_user.id { condition } group by auth_user.id, note.keywords, note.version order by shebanq_web.auth_user.last_name, shebanq_web.auth_user.first_name, note.keywords ; \"\"\" ) projectNote = NOTE_DB . executesql ( projectNoteSql ) projectNotes = collections . OrderedDict () for ( amount , nvr , keywordList , uname , user_id ) in projectNote : for keywords in set ( keywordList . strip () . split ()): key_id = iEncode ( \"n\" , user_id , keywords = keywords ) if key_id not in projectNotes : projectNotes [ key_id ] = { \"\" : ( uname , user_id , keywords ), \"v\" : [ 0 for v in VERSION_ORDER ], } projectNotes [ key_id ][ \"v\" ][ VERSION_INDEX [ nvr ]] = amount tree = collections . OrderedDict () countSet = collections . defaultdict ( lambda : set ()) countUser = collections . defaultdict ( lambda : 0 ) count = 0 for key_id in projectNotes : projectNoteInfo = projectNotes [ key_id ] ( uname , user_id , noteName ) = projectNoteInfo [ \"\" ] countSet [ \"u\" ] . add ( user_id ) countSet [ \"n\" ] . add ( key_id ) objInfo [ \"u\" ][ user_id ] = uname tree . setdefault ( user_id , []) . append ( key_id ) count += 1 countUser [ user_id ] += 1 objInfo [ \"u\" ][ 0 ] = \"\" objInfo [ \"n\" ] = projectNotes categoryCount = dict (( x [ 0 ], len ( x [ 1 ])) for x in countSet . items ()) categoryCount [ \"user_id\" ] = myId title = titleBadge ( None , None , count ) dest = [ dict ( title = str ( title ), folder = True , children = [], data = categoryCount )] curDest = dest [ - 1 ][ \"children\" ] curSource = tree for user_id in curSource : userTotal = countUser [ user_id ] userTitle = titleBadge ( user_id , \"u\" , userTotal ) curDest . append ( dict ( title = str ( userTitle ), folder = True , children = [])) curUserDest = curDest [ - 1 ][ \"children\" ] curUserSource = curSource [ user_id ] for key_id in curUserSource : projectNoteInfo = objInfo [ \"n\" ][ key_id ] ( uname , user_id , noteName ) = projectNoteInfo [ \"\" ] noteVersions = projectNoteInfo [ \"v\" ] versionRep = \" \" . join ( formatVersion ( \"n\" , key_id , v , noteVersions [ VERSION_INDEX [ v ]]) for v in VERSION_ORDER ) curUserDest . append ( dict ( title = ( f \"\"\" { versionRep } <a class=\"n keywords\" n=\"1\" key_id=\" { key_id } \" href=\"#\" > { hEsc ( noteName ) } </a> <a class=\"md\" href=\"#\"></a>\"\"\" ), key = f \"n { key_id } \" , folder = False , ), ) return dict ( data = json . dumps ( dest ))","title":"get()"},{"location":"server/bymodule/query/","text":"query \u00b6 QUERY \u00b6 body ( self ) \u00b6 Retrieves a query record based on parameters. Source code in modules/query.py def body ( self ): \"\"\"Retrieves a query record based on parameters. \"\"\" Check = current . Check auth = current . auth vr = Check . field ( \"material\" , \"\" , \"version\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) ( iid , keywords ) = iDecode ( \"q\" , iidRep ) ( authorized , msg ) = self . authRead ( iid ) msgs = [] if authorized and iid == 0 : msg = f \"Not a valid query id: { iidRep } \" if not authorized or iid == 0 : msgs . append (( \"error\" , msg )) return dict ( writable = False , iidRep = iidRep , vr = vr , queryRecord = dict (), query = json . dumps ( dict ()), msgs = json . dumps ( msgs ), emdrosVersionsOld = set ( EMDROS_VERSIONS [ 0 : - 1 ]), ) queryRecord = self . getInfo ( auth . user is not None , iid , vr , msgs , withIds = True , singleVersion = False , po = True , ) if queryRecord is None : return dict ( writable = True , iidRep = iidRep , vr = vr , queryRecord = dict (), query = json . dumps ( dict ()), msgs = json . dumps ( msgs ), emdrosVersionsOld = set ( EMDROS_VERSIONS [ 0 : - 1 ]), ) ( authorized , msg ) = self . authWrite ( iid ) return dict ( writable = authorized , iidRep = iidRep , vr = vr , queryRecord = queryRecord , query = json . dumps ( queryRecord ), msgs = json . dumps ( msgs ), emdrosVersionsOld = set ( EMDROS_VERSIONS [ 0 : - 1 ]), ) getInfo ( self , showPrivateFields , query_id , vr , msgs , singleVersion = False , withIds = True , po = False ) \u00b6 If called with singleVersion is True, we are grabbibg queries for the side list of a chapter. In this case: * query_id is an iterable of query ids * we only want the query exe records of these queries for a single version vr * we only want query records that are: * belong to a shared query * up to date: executed after modified Source code in modules/query.py def getInfo ( self , showPrivateFields , query_id , vr , msgs , singleVersion = False , withIds = True , po = False , ): \"\"\" If called with singleVersion is True, we are grabbibg queries for the side list of a chapter. In this case: * query_id is an iterable of query ids * we only want the query exe records of these queries for a single version vr * we only want query records that are: * belong to a shared query * up to date: executed after modified \"\"\" db = current . db sqli = ( dedent ( \"\"\", query.created_by as user_id, project.id as project_id, organization.id as org_id \"\"\" ) if withIds and po else \"\" ) sqlx = ( dedent ( \"\"\", query_exe.id as query_exe_id, query_exe.mql as mql, query_exe.version as version, query_exe.eversion as eversion, query_exe.resultmonads as resultmonads, query_exe.results as results, query_exe.executed_on as executed_on, query_exe.modified_on as xmodified_on, query_exe.is_published as is_published, query_exe.published_on as published_on \"\"\" ) if singleVersion else \"\" ) sqlp = ( dedent ( \"\"\", project.name as project_name, project.website as project_website, organization.name as org_name, organization.website as org_website \"\"\" ) if po else \"\" ) sqlb = ( dedent ( \"\"\", auth_user.email as uemail \"\"\" ) if showPrivateFields else dedent ( \"\"\", 'n.n@not.disclosed' as uemail \"\"\" ) ) sqlm = dedent ( f \"\"\" query.id as id, query.name as name, query.description as description, query.created_on as created_on, query.modified_on as modified_on, query.is_shared as is_shared, query.shared_on as shared_on, auth_user.first_name, auth_user.last_name { sqlb }{ sqli }{ sqlp }{ sqlx } \"\"\" ) sqlr = ( dedent ( f \"\"\" inner join query_exe on query_exe.query_id = query.id and query_exe.version = ' { vr } ' \"\"\" ) if singleVersion else \"\" ) sqlpr = ( dedent ( \"\"\" inner join organization on query.organization = organization.id inner join project on query.project = project.id \"\"\" ) if po else \"\" ) sqlc = ( dedent ( f \"\"\" where query.id in ( { \",\" . join ( query_id ) } ) and query.is_shared = 'T' and query_exe.executed_on >= query_exe.modified_on \"\"\" ) if singleVersion else dedent ( f \"\"\" where query.id = { query_id } \"\"\" ) ) sqlo = ( dedent ( \"\"\" order by auth_user.last_name, query.name \"\"\" ) if singleVersion else \"\" ) sql = dedent ( f \"\"\" select { sqlm } from query inner join auth_user on query.created_by = auth_user.id { sqlr }{ sqlpr }{ sqlc }{ sqlo } ; \"\"\" ) records = db . executesql ( sql , as_dict = True ) if records is None : msgs . append (( \"error\" , \"Cannot lookup query(ies)\" )) return None if singleVersion : for record in records : self . getFields ( vr , record , [], singleVersion = True ) return records else : if len ( records ) == 0 : msgs . append (( \"error\" , f \"No query with id { query_id } \" )) return None record = records [ 0 ] record [ \"description_md\" ] = markdown ( record [ \"description\" ] or \"\" , output_format = \"xhtml5\" ) sql = dedent ( f \"\"\" select id as query_exe_id, mql, version, eversion, resultmonads, results, executed_on, modified_on as xmodified_on, is_published, published_on from query_exe where query_id = { query_id } ; \"\"\" ) recordsExe = db . executesql ( sql , as_dict = True ) self . getFields ( vr , record , recordsExe , singleVersion = False ) return record","title":"Query"},{"location":"server/bymodule/query/#query","text":"","title":"query"},{"location":"server/bymodule/query/#query.QUERY","text":"","title":"QUERY"},{"location":"server/bymodule/query/#query.QUERY.body","text":"Retrieves a query record based on parameters. Source code in modules/query.py def body ( self ): \"\"\"Retrieves a query record based on parameters. \"\"\" Check = current . Check auth = current . auth vr = Check . field ( \"material\" , \"\" , \"version\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) ( iid , keywords ) = iDecode ( \"q\" , iidRep ) ( authorized , msg ) = self . authRead ( iid ) msgs = [] if authorized and iid == 0 : msg = f \"Not a valid query id: { iidRep } \" if not authorized or iid == 0 : msgs . append (( \"error\" , msg )) return dict ( writable = False , iidRep = iidRep , vr = vr , queryRecord = dict (), query = json . dumps ( dict ()), msgs = json . dumps ( msgs ), emdrosVersionsOld = set ( EMDROS_VERSIONS [ 0 : - 1 ]), ) queryRecord = self . getInfo ( auth . user is not None , iid , vr , msgs , withIds = True , singleVersion = False , po = True , ) if queryRecord is None : return dict ( writable = True , iidRep = iidRep , vr = vr , queryRecord = dict (), query = json . dumps ( dict ()), msgs = json . dumps ( msgs ), emdrosVersionsOld = set ( EMDROS_VERSIONS [ 0 : - 1 ]), ) ( authorized , msg ) = self . authWrite ( iid ) return dict ( writable = authorized , iidRep = iidRep , vr = vr , queryRecord = queryRecord , query = json . dumps ( queryRecord ), msgs = json . dumps ( msgs ), emdrosVersionsOld = set ( EMDROS_VERSIONS [ 0 : - 1 ]), )","title":"body()"},{"location":"server/bymodule/query/#query.QUERY.getInfo","text":"If called with singleVersion is True, we are grabbibg queries for the side list of a chapter. In this case: * query_id is an iterable of query ids * we only want the query exe records of these queries for a single version vr * we only want query records that are: * belong to a shared query * up to date: executed after modified Source code in modules/query.py def getInfo ( self , showPrivateFields , query_id , vr , msgs , singleVersion = False , withIds = True , po = False , ): \"\"\" If called with singleVersion is True, we are grabbibg queries for the side list of a chapter. In this case: * query_id is an iterable of query ids * we only want the query exe records of these queries for a single version vr * we only want query records that are: * belong to a shared query * up to date: executed after modified \"\"\" db = current . db sqli = ( dedent ( \"\"\", query.created_by as user_id, project.id as project_id, organization.id as org_id \"\"\" ) if withIds and po else \"\" ) sqlx = ( dedent ( \"\"\", query_exe.id as query_exe_id, query_exe.mql as mql, query_exe.version as version, query_exe.eversion as eversion, query_exe.resultmonads as resultmonads, query_exe.results as results, query_exe.executed_on as executed_on, query_exe.modified_on as xmodified_on, query_exe.is_published as is_published, query_exe.published_on as published_on \"\"\" ) if singleVersion else \"\" ) sqlp = ( dedent ( \"\"\", project.name as project_name, project.website as project_website, organization.name as org_name, organization.website as org_website \"\"\" ) if po else \"\" ) sqlb = ( dedent ( \"\"\", auth_user.email as uemail \"\"\" ) if showPrivateFields else dedent ( \"\"\", 'n.n@not.disclosed' as uemail \"\"\" ) ) sqlm = dedent ( f \"\"\" query.id as id, query.name as name, query.description as description, query.created_on as created_on, query.modified_on as modified_on, query.is_shared as is_shared, query.shared_on as shared_on, auth_user.first_name, auth_user.last_name { sqlb }{ sqli }{ sqlp }{ sqlx } \"\"\" ) sqlr = ( dedent ( f \"\"\" inner join query_exe on query_exe.query_id = query.id and query_exe.version = ' { vr } ' \"\"\" ) if singleVersion else \"\" ) sqlpr = ( dedent ( \"\"\" inner join organization on query.organization = organization.id inner join project on query.project = project.id \"\"\" ) if po else \"\" ) sqlc = ( dedent ( f \"\"\" where query.id in ( { \",\" . join ( query_id ) } ) and query.is_shared = 'T' and query_exe.executed_on >= query_exe.modified_on \"\"\" ) if singleVersion else dedent ( f \"\"\" where query.id = { query_id } \"\"\" ) ) sqlo = ( dedent ( \"\"\" order by auth_user.last_name, query.name \"\"\" ) if singleVersion else \"\" ) sql = dedent ( f \"\"\" select { sqlm } from query inner join auth_user on query.created_by = auth_user.id { sqlr }{ sqlpr }{ sqlc }{ sqlo } ; \"\"\" ) records = db . executesql ( sql , as_dict = True ) if records is None : msgs . append (( \"error\" , \"Cannot lookup query(ies)\" )) return None if singleVersion : for record in records : self . getFields ( vr , record , [], singleVersion = True ) return records else : if len ( records ) == 0 : msgs . append (( \"error\" , f \"No query with id { query_id } \" )) return None record = records [ 0 ] record [ \"description_md\" ] = markdown ( record [ \"description\" ] or \"\" , output_format = \"xhtml5\" ) sql = dedent ( f \"\"\" select id as query_exe_id, mql, version, eversion, resultmonads, results, executed_on, modified_on as xmodified_on, is_published, published_on from query_exe where query_id = { query_id } ; \"\"\" ) recordsExe = db . executesql ( sql , as_dict = True ) self . getFields ( vr , record , recordsExe , singleVersion = False ) return record","title":"getInfo()"},{"location":"server/bymodule/querychapter/","text":"querychapter \u00b6 QUERYCHAPTER \u00b6 updateQCindex ( self , vr , query_id , uptodate = True ) \u00b6 We want an up to date mapping from chapters to the shared, up-to-date queries with results in those chapters. We call this function when: * a query has run and a niew set of slots has been stored. * the sharing status of a query changes We do not call this function when: * the published state of a query has changed (see updatePubStatus) * when a query body is edited but not run (see below). In those cases the following will be taken care of: First delete the query from the index. If the query is shared and up to date, we add it back to the index based on its results. However, this function might be called at a time that the results of the query have been stored in the database, before the metadata has arrived there. In that case we can not test on the uptodateness, so we assume that the caller has passed uptodate=True. Indeed, when the sharing status has changed, we are able to perform this test, and then there is no need to pass uptodate=True. What if a query body is edited but not run? It will then become outdated, and should be removed from the index. But that is a rather costly operation, and it is likely that a query is edited many times before it is run again. What we do instead is, that when we fetch queries for the sidebar of a chapter, we skip the ones that are outdated. Source code in modules/querychapter.py def updateQCindex ( self , vr , query_id , uptodate = True ): \"\"\" We want an up to date mapping from chapters to the shared, up-to-date queries with results in those chapters. We call this function when: * a query has run and a niew set of slots has been stored. * the sharing status of a query changes We do not call this function when: * the published state of a query has changed (see updatePubStatus) * when a query body is edited but not run (see below). In those cases the following will be taken care of: First delete the query from the index. If the query is shared and up to date, we add it back to the index based on its results. However, this function might be called at a time that the results of the query have been stored in the database, before the metadata has arrived there. In that case we can not test on the uptodateness, so we assume that the caller has passed uptodate=True. Indeed, when the sharing status has changed, we are able to perform this test, and then there is no need to pass uptodate=True. What if a query body is edited but not run? It will then become outdated, and should be removed from the index. But that is a rather costly operation, and it is likely that a query is edited many times before it is run again. What we do instead is, that when we fetch queries for the sidebar of a chapter, we skip the ones that are outdated. \"\"\" Caching = current . Caching db = current . db debug (( f \"o-o-o updating chapter-query index for data { vr } \" )) startTime = time . time () chaptersFromQuery = Caching . get ( f \"chaptersFromQuery_ { vr } _\" , lambda : {}, None , ) queriesFromChapter = Caching . get ( f \"queriesFromChapter_ { vr } _\" , lambda : {}, None , ) # remove query_id from both indexes: chaptersFromQuery and queriesFromChapter if query_id in chaptersFromQuery : theseChapters = chaptersFromQuery [ query_id ] for chapter_id in theseChapters : if chapter_id in queriesFromChapter : if query_id in queriesFromChapter [ chapter_id ]: del queriesFromChapter [ chapter_id ][ query_id ] if not queriesFromChapter [ chapter_id ]: del queriesFromChapter [ chapter_id ] del chaptersFromQuery [ query_id ] # add query_id again to both indexes (but now with updated results) uptodateSQL = ( \"\" if uptodate else dedent ( \"\"\" and query_exe.executed_on >= query_exe.modified_on \"\"\" ) ) resultSQL1 = dedent ( f \"\"\" select query_exe.id, query.id from query inner join query_exe on query.id = query_exe.query_id where query.id = { query_id } and query_exe.version = ' { vr } ' and query.is_shared = 'T' { uptodateSQL } ; \"\"\" ) queryTime = time . time () results1 = db . executesql ( resultSQL1 ) queryTime = time . time () - queryTime debug ( f \" found { len ( results1 ) } shared queries in { delta ( queryTime ) } \" ) queryFromExe = {} for ( query_exe_id , query_id ) in results1 : queryFromExe [ query_exe_id ] = query_id if queryFromExe : doQueryIndex ( db , vr , queryFromExe ) exe = time . time () - startTime debug ( f \"o-o-o updated chapter-query index for data { vr } in { delta ( exe ) } \" )","title":"Querychapter"},{"location":"server/bymodule/querychapter/#querychapter","text":"","title":"querychapter"},{"location":"server/bymodule/querychapter/#querychapter.QUERYCHAPTER","text":"","title":"QUERYCHAPTER"},{"location":"server/bymodule/querychapter/#querychapter.QUERYCHAPTER.updateQCindex","text":"We want an up to date mapping from chapters to the shared, up-to-date queries with results in those chapters. We call this function when: * a query has run and a niew set of slots has been stored. * the sharing status of a query changes We do not call this function when: * the published state of a query has changed (see updatePubStatus) * when a query body is edited but not run (see below). In those cases the following will be taken care of: First delete the query from the index. If the query is shared and up to date, we add it back to the index based on its results. However, this function might be called at a time that the results of the query have been stored in the database, before the metadata has arrived there. In that case we can not test on the uptodateness, so we assume that the caller has passed uptodate=True. Indeed, when the sharing status has changed, we are able to perform this test, and then there is no need to pass uptodate=True. What if a query body is edited but not run? It will then become outdated, and should be removed from the index. But that is a rather costly operation, and it is likely that a query is edited many times before it is run again. What we do instead is, that when we fetch queries for the sidebar of a chapter, we skip the ones that are outdated. Source code in modules/querychapter.py def updateQCindex ( self , vr , query_id , uptodate = True ): \"\"\" We want an up to date mapping from chapters to the shared, up-to-date queries with results in those chapters. We call this function when: * a query has run and a niew set of slots has been stored. * the sharing status of a query changes We do not call this function when: * the published state of a query has changed (see updatePubStatus) * when a query body is edited but not run (see below). In those cases the following will be taken care of: First delete the query from the index. If the query is shared and up to date, we add it back to the index based on its results. However, this function might be called at a time that the results of the query have been stored in the database, before the metadata has arrived there. In that case we can not test on the uptodateness, so we assume that the caller has passed uptodate=True. Indeed, when the sharing status has changed, we are able to perform this test, and then there is no need to pass uptodate=True. What if a query body is edited but not run? It will then become outdated, and should be removed from the index. But that is a rather costly operation, and it is likely that a query is edited many times before it is run again. What we do instead is, that when we fetch queries for the sidebar of a chapter, we skip the ones that are outdated. \"\"\" Caching = current . Caching db = current . db debug (( f \"o-o-o updating chapter-query index for data { vr } \" )) startTime = time . time () chaptersFromQuery = Caching . get ( f \"chaptersFromQuery_ { vr } _\" , lambda : {}, None , ) queriesFromChapter = Caching . get ( f \"queriesFromChapter_ { vr } _\" , lambda : {}, None , ) # remove query_id from both indexes: chaptersFromQuery and queriesFromChapter if query_id in chaptersFromQuery : theseChapters = chaptersFromQuery [ query_id ] for chapter_id in theseChapters : if chapter_id in queriesFromChapter : if query_id in queriesFromChapter [ chapter_id ]: del queriesFromChapter [ chapter_id ][ query_id ] if not queriesFromChapter [ chapter_id ]: del queriesFromChapter [ chapter_id ] del chaptersFromQuery [ query_id ] # add query_id again to both indexes (but now with updated results) uptodateSQL = ( \"\" if uptodate else dedent ( \"\"\" and query_exe.executed_on >= query_exe.modified_on \"\"\" ) ) resultSQL1 = dedent ( f \"\"\" select query_exe.id, query.id from query inner join query_exe on query.id = query_exe.query_id where query.id = { query_id } and query_exe.version = ' { vr } ' and query.is_shared = 'T' { uptodateSQL } ; \"\"\" ) queryTime = time . time () results1 = db . executesql ( resultSQL1 ) queryTime = time . time () - queryTime debug ( f \" found { len ( results1 ) } shared queries in { delta ( queryTime ) } \" ) queryFromExe = {} for ( query_exe_id , query_id ) in results1 : queryFromExe [ query_exe_id ] = query_id if queryFromExe : doQueryIndex ( db , vr , queryFromExe ) exe = time . time () - startTime debug ( f \"o-o-o updated chapter-query index for data { vr } in { delta ( exe ) } \" )","title":"updateQCindex()"},{"location":"server/bymodule/queryrecent/","text":"queryrecent \u00b6 QUERYRECENT \u00b6 Handles the set of recent queries. It can select the most recently saved shared queries. It can export them as an RSS feed. recent ( self ) \u00b6 Select the most recently saved shared queries. The next query contains a clever idea from stackoverflow . We want to find the most recent mql queries. Queries may have multiple executions. We want to have the queries with the most recent executions. From such queries, we only want to have the single most recent execution. This idea can be obtained by left outer joining the query_exe table with itself (qe1 with qe2) on the condition that those rows are combined where qe1 and qe2 belong to the same query, and qe2 is more recent. Rows in the combined table where qe2 is null, are such that qe1 is most recent. This is the basic idea. We then have to refine it: we only want shared queries. That is an easy where condition on the final result. We only want to have up-to-date queries. So the join condition is not that qe2 is more recent, but that qe2 is up-to-date and more recent. And we need to add a where to express that qe1 is up to date. Source code in modules/queryrecent.py def recent ( self ): \"\"\"Select the most recently saved shared queries. The next query contains a clever idea from [stackoverflow](https://stackoverflow.com/questions/5657446/mysql-query-max-group-by). We want to find the most recent mql queries. Queries may have multiple executions. We want to have the queries with the most recent executions. From such queries, we only want to have the single most recent execution. This idea can be obtained by left outer joining the `query_exe` table with itself (qe1 with qe2) on the condition that those rows are combined where qe1 and qe2 belong to the same query, and qe2 is more recent. Rows in the combined table where qe2 is null, are such that qe1 is most recent. This is the basic idea. We then have to refine it: we only want shared queries. That is an easy where condition on the final result. We only want to have up-to-date queries. So the join condition is not that qe2 is more recent, but that qe2 is up-to-date and more recent. And we need to add a where to express that qe1 is up to date. \"\"\" db = current . db projectQueryXSql = dedent ( f \"\"\" select query.id as query_id, auth_user.first_name, auth_user.last_name, query.name as query_name, qe.executed_on as qexe, qe.version as qver from query inner join ( select qe1.query_id, qe1.executed_on, qe1.version from query_exe qe1 left outer join query_exe qe2 on ( qe1.query_id = qe2.query_id and qe1.executed_on < qe2.executed_on and qe2.executed_on >= qe2.modified_on ) where ( qe1.executed_on is not null and qe1.executed_on >= qe1.modified_on ) and qe2.query_id is null ) as qe on qe.query_id = query.id inner join auth_user on query.created_by = auth_user.id where query.is_shared = 'T' order by qe.executed_on desc, auth_user.last_name limit { RECENT_LIMIT } ; \"\"\" ) pqueryx = db . executesql ( projectQueryXSql ) pqueries = [] for ( query_id , first_name , last_name , query_name , qexe , qver ) in pqueryx : text = hEsc ( f \" { first_name [ 0 ] } { last_name [ 0 : 9 ] } : { query_name [ 0 : 20 ] } \" ) title = hEsc ( f \" { first_name } { last_name } : { query_name } \" ) pqueries . append ( dict ( id = query_id , text = text , title = title , version = qver )) return dict ( data = json . dumps ( dict ( queries = pqueries , msgs = [], good = True )))","title":"Queryrecent"},{"location":"server/bymodule/queryrecent/#queryrecent","text":"","title":"queryrecent"},{"location":"server/bymodule/queryrecent/#queryrecent.QUERYRECENT","text":"Handles the set of recent queries. It can select the most recently saved shared queries. It can export them as an RSS feed.","title":"QUERYRECENT"},{"location":"server/bymodule/queryrecent/#queryrecent.QUERYRECENT.recent","text":"Select the most recently saved shared queries. The next query contains a clever idea from stackoverflow . We want to find the most recent mql queries. Queries may have multiple executions. We want to have the queries with the most recent executions. From such queries, we only want to have the single most recent execution. This idea can be obtained by left outer joining the query_exe table with itself (qe1 with qe2) on the condition that those rows are combined where qe1 and qe2 belong to the same query, and qe2 is more recent. Rows in the combined table where qe2 is null, are such that qe1 is most recent. This is the basic idea. We then have to refine it: we only want shared queries. That is an easy where condition on the final result. We only want to have up-to-date queries. So the join condition is not that qe2 is more recent, but that qe2 is up-to-date and more recent. And we need to add a where to express that qe1 is up to date. Source code in modules/queryrecent.py def recent ( self ): \"\"\"Select the most recently saved shared queries. The next query contains a clever idea from [stackoverflow](https://stackoverflow.com/questions/5657446/mysql-query-max-group-by). We want to find the most recent mql queries. Queries may have multiple executions. We want to have the queries with the most recent executions. From such queries, we only want to have the single most recent execution. This idea can be obtained by left outer joining the `query_exe` table with itself (qe1 with qe2) on the condition that those rows are combined where qe1 and qe2 belong to the same query, and qe2 is more recent. Rows in the combined table where qe2 is null, are such that qe1 is most recent. This is the basic idea. We then have to refine it: we only want shared queries. That is an easy where condition on the final result. We only want to have up-to-date queries. So the join condition is not that qe2 is more recent, but that qe2 is up-to-date and more recent. And we need to add a where to express that qe1 is up to date. \"\"\" db = current . db projectQueryXSql = dedent ( f \"\"\" select query.id as query_id, auth_user.first_name, auth_user.last_name, query.name as query_name, qe.executed_on as qexe, qe.version as qver from query inner join ( select qe1.query_id, qe1.executed_on, qe1.version from query_exe qe1 left outer join query_exe qe2 on ( qe1.query_id = qe2.query_id and qe1.executed_on < qe2.executed_on and qe2.executed_on >= qe2.modified_on ) where ( qe1.executed_on is not null and qe1.executed_on >= qe1.modified_on ) and qe2.query_id is null ) as qe on qe.query_id = query.id inner join auth_user on query.created_by = auth_user.id where query.is_shared = 'T' order by qe.executed_on desc, auth_user.last_name limit { RECENT_LIMIT } ; \"\"\" ) pqueryx = db . executesql ( projectQueryXSql ) pqueries = [] for ( query_id , first_name , last_name , query_name , qexe , qver ) in pqueryx : text = hEsc ( f \" { first_name [ 0 ] } { last_name [ 0 : 9 ] } : { query_name [ 0 : 20 ] } \" ) title = hEsc ( f \" { first_name } { last_name } : { query_name } \" ) pqueries . append ( dict ( id = query_id , text = text , title = title , version = qver )) return dict ( data = json . dumps ( dict ( queries = pqueries , msgs = [], good = True )))","title":"recent()"},{"location":"server/bymodule/querysave/","text":"querysave \u00b6 QUERYSAVE \u00b6 putRecord ( self ) \u00b6 Receives updated record data of a query and stores it in the database. Source code in modules/querysave.py def putRecord ( self ): \"\"\"Receives updated record data of a query and stores it in the database. \"\"\" Check = current . Check Query = self . Query auth = current . auth requestVars = current . request . vars vr = requestVars . version nameNew = requestVars . name mqlNew = requestVars . mql descriptionNew = requestVars . description execute = requestVars . execute myId = auth . user . id if auth . user is not None else None now = current . request . utcnow msgs = [] good = False fields = {} fieldsExe = {} queryRecord = {} is_published = False for x in [ 1 ]: query_id = Check . isId ( \"query_id\" , \"q\" , \"query\" , msgs ) if query_id is None : break ( authorized , msg ) = Query . authWrite ( query_id ) if not authorized : msgs . append (( \"error\" , msg )) break self . verifyVersion ( vr , query_id ) recordOld = Query . getBasicInfo ( vr , query_id ) if recordOld is None or len ( recordOld ) == 0 : msgs . append (( \"error\" , f \"No query with id { query_id } \" )) break valsOld = recordOld [ 0 ] is_published = valsOld [ \"is_published\" ] == \"T\" if not is_published : if valsOld [ \"name\" ] != nameNew : valSql = Check . isName ( \"q\" , query_id , myId , nameNew , msgs ) if valSql is None : break fields [ \"name\" ] = valSql fields [ \"modified_on\" ] = now if valsOld [ \"mql\" ] != mqlNew : msgs . append (( \"warning\" , \"query body modified\" )) valSql = Check . isMql ( \"q\" , mqlNew , msgs ) if valSql is None : break fieldsExe [ \"mql\" ] = valSql fieldsExe [ \"modified_on\" ] = now else : msgs . append (( \"good\" , \"same query body\" )) else : msgs . append ( ( \"warning\" , ( \"only the description can been saved\" \"because this is a published query execution\" ), ) ) if valsOld [ \"description\" ] != descriptionNew : valSql = Check . isDescription ( \"q\" , descriptionNew , msgs ) if valSql is None : break fields [ \"description\" ] = valSql fields [ \"modified_on\" ] = now good = True if good : execute = not is_published and execute exeGood = True if execute == \"true\" : ( exeGood , limitExceeded , nResults , exeSlots , theseMsgs , emdrosVersion , ) = mql ( vr , mqlNew ) if exeGood and not limitExceeded : self . putSlots ( vr , query_id , exeSlots ) fieldsExe [ \"executed_on\" ] = now fieldsExe [ \"eversion\" ] = emdrosVersion nResultSlots = countSlots ( exeSlots ) fieldsExe [ \"results\" ] = nResults fieldsExe [ \"resultmonads\" ] = nResultSlots msgs . append (( \"good\" , \"Query executed\" )) else : self . putSlots ( vr , query_id , []) msgs . extend ( theseMsgs ) self . putMeta ( vr , query_id , fields , fieldsExe ) queryRecord = Query . getInfo ( auth . user is not None , query_id , vr , msgs , withIds = False , singleVersion = False , po = True , ) emdrosVersionsOld = dict (( x , 1 ) for x in EMDROS_VERSIONS [ 0 : - 1 ]) return dict ( data = json . dumps ( dict ( msgs = msgs , good = good and exeGood , query = queryRecord , emdrosVersionsOld = emdrosVersionsOld , ) ) ) sharing ( self ) \u00b6 Receives a new sharing status of a query and saves it to the database. Source code in modules/querysave.py def sharing ( self ): \"\"\"Receives a new sharing status of a query and saves it to the database. \"\"\" Check = current . Check Query = self . Query msgs = [] good = False modDates = {} modCls = {} extra = {} requestVars = current . request . vars for x in [ 1 ]: query_id = Check . isId ( \"query_id\" , \"q\" , \"query\" , msgs ) if query_id is None : break fieldName = requestVars . fname val = requestVars . val vr = requestVars . version if fieldName is None or fieldName not in { \"is_shared\" , \"is_published\" }: msgs . append (( \"error\" , f \"Illegal field name { fieldName } \" )) break ( authorized , msg ) = Query . authWrite ( query_id ) if not authorized : msgs . append (( \"error\" , msg )) break ( good , modDates , modCls , extra ) = self . putSharing ( vr , query_id , fieldName , val , msgs ) return dict ( data = json . dumps ( dict ( msgs = msgs , good = good , modDates = modDates , modCls = modCls , extra = extra ) ) )","title":"Querysave"},{"location":"server/bymodule/querysave/#querysave","text":"","title":"querysave"},{"location":"server/bymodule/querysave/#querysave.QUERYSAVE","text":"","title":"QUERYSAVE"},{"location":"server/bymodule/querysave/#querysave.QUERYSAVE.putRecord","text":"Receives updated record data of a query and stores it in the database. Source code in modules/querysave.py def putRecord ( self ): \"\"\"Receives updated record data of a query and stores it in the database. \"\"\" Check = current . Check Query = self . Query auth = current . auth requestVars = current . request . vars vr = requestVars . version nameNew = requestVars . name mqlNew = requestVars . mql descriptionNew = requestVars . description execute = requestVars . execute myId = auth . user . id if auth . user is not None else None now = current . request . utcnow msgs = [] good = False fields = {} fieldsExe = {} queryRecord = {} is_published = False for x in [ 1 ]: query_id = Check . isId ( \"query_id\" , \"q\" , \"query\" , msgs ) if query_id is None : break ( authorized , msg ) = Query . authWrite ( query_id ) if not authorized : msgs . append (( \"error\" , msg )) break self . verifyVersion ( vr , query_id ) recordOld = Query . getBasicInfo ( vr , query_id ) if recordOld is None or len ( recordOld ) == 0 : msgs . append (( \"error\" , f \"No query with id { query_id } \" )) break valsOld = recordOld [ 0 ] is_published = valsOld [ \"is_published\" ] == \"T\" if not is_published : if valsOld [ \"name\" ] != nameNew : valSql = Check . isName ( \"q\" , query_id , myId , nameNew , msgs ) if valSql is None : break fields [ \"name\" ] = valSql fields [ \"modified_on\" ] = now if valsOld [ \"mql\" ] != mqlNew : msgs . append (( \"warning\" , \"query body modified\" )) valSql = Check . isMql ( \"q\" , mqlNew , msgs ) if valSql is None : break fieldsExe [ \"mql\" ] = valSql fieldsExe [ \"modified_on\" ] = now else : msgs . append (( \"good\" , \"same query body\" )) else : msgs . append ( ( \"warning\" , ( \"only the description can been saved\" \"because this is a published query execution\" ), ) ) if valsOld [ \"description\" ] != descriptionNew : valSql = Check . isDescription ( \"q\" , descriptionNew , msgs ) if valSql is None : break fields [ \"description\" ] = valSql fields [ \"modified_on\" ] = now good = True if good : execute = not is_published and execute exeGood = True if execute == \"true\" : ( exeGood , limitExceeded , nResults , exeSlots , theseMsgs , emdrosVersion , ) = mql ( vr , mqlNew ) if exeGood and not limitExceeded : self . putSlots ( vr , query_id , exeSlots ) fieldsExe [ \"executed_on\" ] = now fieldsExe [ \"eversion\" ] = emdrosVersion nResultSlots = countSlots ( exeSlots ) fieldsExe [ \"results\" ] = nResults fieldsExe [ \"resultmonads\" ] = nResultSlots msgs . append (( \"good\" , \"Query executed\" )) else : self . putSlots ( vr , query_id , []) msgs . extend ( theseMsgs ) self . putMeta ( vr , query_id , fields , fieldsExe ) queryRecord = Query . getInfo ( auth . user is not None , query_id , vr , msgs , withIds = False , singleVersion = False , po = True , ) emdrosVersionsOld = dict (( x , 1 ) for x in EMDROS_VERSIONS [ 0 : - 1 ]) return dict ( data = json . dumps ( dict ( msgs = msgs , good = good and exeGood , query = queryRecord , emdrosVersionsOld = emdrosVersionsOld , ) ) )","title":"putRecord()"},{"location":"server/bymodule/querysave/#querysave.QUERYSAVE.sharing","text":"Receives a new sharing status of a query and saves it to the database. Source code in modules/querysave.py def sharing ( self ): \"\"\"Receives a new sharing status of a query and saves it to the database. \"\"\" Check = current . Check Query = self . Query msgs = [] good = False modDates = {} modCls = {} extra = {} requestVars = current . request . vars for x in [ 1 ]: query_id = Check . isId ( \"query_id\" , \"q\" , \"query\" , msgs ) if query_id is None : break fieldName = requestVars . fname val = requestVars . val vr = requestVars . version if fieldName is None or fieldName not in { \"is_shared\" , \"is_published\" }: msgs . append (( \"error\" , f \"Illegal field name { fieldName } \" )) break ( authorized , msg ) = Query . authWrite ( query_id ) if not authorized : msgs . append (( \"error\" , msg )) break ( good , modDates , modCls , extra ) = self . putSharing ( vr , query_id , fieldName , val , msgs ) return dict ( data = json . dumps ( dict ( msgs = msgs , good = good , modDates = modDates , modCls = modCls , extra = extra ) ) )","title":"sharing()"},{"location":"server/bymodule/querytree/","text":"querytree \u00b6 QUERYTREE \u00b6 get ( self ) \u00b6 Get the metadata of all queries and deliver it as json. Source code in modules/querytree.py def get ( self ): \"\"\"Get the metadata of all queries and deliver it as json. \"\"\" auth = current . auth db = current . db VERSION_ORDER = current . VERSION_ORDER VERSION_INDEX = current . VERSION_INDEX myId = None if auth . user : myId = auth . user . id objInfo = collections . defaultdict ( lambda : {}) def titleBadge ( obj_id , objType , publ , good , num , tot ): name = objInfo [ objType ][ obj_id ] if objType is not None else \"Shared Queries\" nums = [] if publ != 0 : nums . append ( f '<span class=\"special fa fa-quote-right\"> { publ } </span>' ) if good != 0 : nums . append ( f '<span class=\"good fa fa-gears\"> { good } </span>' ) badge = \"\" if len ( nums ) == 0 : if tot == num : badge = f '<span class=\"total\"> { tot } </span>' else : badge = f ' { num } of <span class=\"total\"> { tot } </span>' else : nRep = \", \" . join ( nums ) if tot == num : badge = f ' { nRep } of <span class=\"total\"> { tot } </span>' else : badge = f ' { nRep } of { num } of all <span class=\"total\"> { tot } </span>' rename = \"\" select = \"\" if objType in { \"o\" , \"p\" }: if myId is not None : if obj_id : rename = ( f '<a class=\"r_ { objType } \" obj_id=\" { obj_id } \" href=\"#\"></a>' ) select = dedent ( f \"\"\"<a class=\"s_ { objType } fa fa-lg\" obj_id=\" { obj_id } \" href=\"#\"></a>\"\"\" ) else : if obj_id : rename = ( f '<a class=\"v_ { objType } \" obj_id=\" { obj_id } \" href=\"#\"></a>' ) return dedent ( f \"\"\" { select } <span n=\"1\"> { hEsc ( name ) } </span><span class=\"brq\">( { badge } )</span> { rename } \"\"\" ) condition = ( dedent ( \"\"\" where query.is_shared = 'T' \"\"\" ) if myId is None else dedent ( f \"\"\" where query.is_shared = 'T' or query.created_by = { myId } \"\"\" ) ) projectQueryXSql = dedent ( f \"\"\" select query_exe.query_id, query_exe.version, query_exe.is_published, query_exe.published_on, query_exe.modified_on, query_exe.executed_on from query_exe inner join query on query.id = query_exe.query_id { condition } ; \"\"\" ) projectQuerySql = dedent ( f \"\"\" select query.id as query_id, organization.name as org_name, organization.id as org_id, project.name as project_name, project.id as project_id, concat(auth_user.first_name, ' ', auth_user.last_name) as uname, auth_user.id as user_id, query.name as query_name, query.is_shared as is_shared from query inner join auth_user on query.created_by = auth_user.id inner join project on query.project = project.id inner join organization on query.organization = organization.id { condition } order by organization.name, project.name, auth_user.last_name, auth_user.first_name, query.name ; \"\"\" ) projectQuery = db . executesql ( projectQuerySql ) projectQueryX = db . executesql ( projectQueryXSql ) projectQueries = collections . OrderedDict () for ( query_id , orgName , org_id , projectName , project_id , userName , user_id , queryName , queryShared , ) in projectQuery : qSharedStatus = queryShared == \"T\" qOwnStatus = user_id == myId projectQueries [ query_id ] = { \"\" : ( orgName , org_id , projectName , project_id , userName , user_id , queryName , qSharedStatus , qOwnStatus , ), \"publ\" : False , \"good\" : False , \"v\" : [ 4 for v in VERSION_ORDER ], } now = current . request . utcnow for ( query_id , vr , queryIs_published , queryPublished_on , queryMod_on , queryExe_on , ) in projectQueryX : queryInfo = projectQueries [ query_id ] queryExeStatus = None if queryExe_on : queryExeStatus = queryExe_on >= queryMod_on queryPubStatus = ( False if queryIs_published != \"T\" else None if queryPublished_on > now - PUBLISH_FREEZE else True ) queryStatus = ( 1 if queryPubStatus else 2 if queryPubStatus is None else 3 if queryExeStatus else 4 if queryExeStatus is None else 5 ) queryInfo [ \"v\" ][ VERSION_INDEX [ vr ]] = queryStatus if queryPubStatus or queryPubStatus is None : queryInfo [ \"publ\" ] = True if queryExeStatus : queryInfo [ \"good\" ] = True projectOrgSql = dedent ( \"\"\" select name, id from organization order by name ; \"\"\" ) porg = db . executesql ( projectOrgSql ) projectSql = dedent ( \"\"\" select name, id from project order by name ; \"\"\" ) project = db . executesql ( projectSql ) tree = collections . OrderedDict () countSet = collections . defaultdict ( lambda : set ()) countOrg = collections . defaultdict ( lambda : 0 ) countOrgPub = collections . defaultdict ( lambda : 0 ) countOrgGood = collections . defaultdict ( lambda : 0 ) countOrgTotal = collections . defaultdict ( lambda : 0 ) countProject = collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 ) ) countProjectPub = collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 ) ) countProjectGood = collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 ) ) countProjectTotal = collections . defaultdict ( lambda : 0 ) countUser = collections . defaultdict ( lambda : collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 )) ) countUserPub = collections . defaultdict ( lambda : collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 )) ) countUserGood = collections . defaultdict ( lambda : collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 )) ) countUserTotal = collections . defaultdict ( lambda : 0 ) count = 0 countPub = 0 countGood = 0 for query_id in projectQueries : projectQueryInfo = projectQueries [ query_id ] ( orgName , org_id , projectName , project_id , userName , user_id , queryName , queryShared , queryOwn , ) = projectQueryInfo [ \"\" ] queryPub = projectQueryInfo [ \"publ\" ] queryGood = projectQueryInfo [ \"good\" ] countSet [ \"o\" ] . add ( org_id ) countSet [ \"p\" ] . add ( project_id ) countSet [ \"u\" ] . add ( user_id ) countSet [ \"q\" ] . add ( query_id ) objInfo [ \"o\" ][ org_id ] = orgName objInfo [ \"p\" ][ project_id ] = projectName objInfo [ \"u\" ][ user_id ] = userName if queryOwn : countSet [ \"m\" ] . add ( query_id ) if not queryShared : countSet [ \"r\" ] . add ( query_id ) if queryPub : countUserPub [ org_id ][ project_id ][ user_id ] += 1 countProjectPub [ org_id ][ project_id ] += 1 countOrgPub [ org_id ] += 1 countPub += 1 if queryGood : countUserGood [ org_id ][ project_id ][ user_id ] += 1 countProjectGood [ org_id ][ project_id ] += 1 countOrgGood [ org_id ] += 1 countGood += 1 tree . setdefault ( org_id , collections . OrderedDict ()) . setdefault ( project_id , collections . OrderedDict () ) . setdefault ( user_id , []) . append ( query_id ) count += 1 countOrg [ org_id ] += 1 countProject [ org_id ][ project_id ] += 1 countUser [ org_id ][ project_id ][ user_id ] += 1 countOrgTotal [ org_id ] += 1 countProjectTotal [ project_id ] += 1 countUserTotal [ user_id ] += 1 objInfo [ \"o\" ][ 0 ] = \"Projects without Queries\" objInfo [ \"p\" ][ 0 ] = \"New Project\" objInfo [ \"u\" ][ 0 ] = \"\" objInfo [ \"q\" ] = projectQueries countOrg [ 0 ] = 0 countProject [ 0 ][ 0 ] = 0 for ( orgName , org_id ) in porg : if org_id in objInfo [ \"o\" ]: continue countSet [ \"o\" ] . add ( org_id ) objInfo [ \"o\" ][ org_id ] = orgName tree [ org_id ] = collections . OrderedDict () for ( projectName , project_id ) in project : if project_id in objInfo [ \"p\" ]: continue countSet [ \"o\" ] . add ( 0 ) countSet [ \"p\" ] . add ( project_id ) objInfo [ \"p\" ][ project_id ] = projectName tree . setdefault ( 0 , collections . OrderedDict ())[ project_id ] = collections . OrderedDict () categoryCount = dict (( x [ 0 ], len ( x [ 1 ])) for x in countSet . items ()) categoryCount [ \"user_id\" ] = myId title = titleBadge ( None , None , countPub , countGood , count , count ) dest = [ dict ( title = str ( title ), folder = True , children = [], data = categoryCount )] curDest = dest [ - 1 ][ \"children\" ] curSource = tree for org_id in curSource : orgN = countOrg [ org_id ] orgPub = countOrgPub [ org_id ] orgGood = countOrgGood [ org_id ] orgTot = countOrgTotal [ org_id ] orgTitle = titleBadge ( org_id , \"o\" , orgPub , orgGood , orgN , orgTot ) curDest . append ( dict ( title = str ( orgTitle ), folder = True , children = [])) curOrgDest = curDest [ - 1 ][ \"children\" ] curOrgSource = curSource [ org_id ] for project_id in curOrgSource : projectN = countProject [ org_id ][ project_id ] projectPub = countProjectPub [ org_id ][ project_id ] projectPub = countProjectGood [ org_id ][ project_id ] projectTot = countProjectTotal [ project_id ] projectTitle = titleBadge ( project_id , \"p\" , projectPub , projectPub , projectN , projectTot ) curOrgDest . append ( dict ( title = str ( projectTitle ), folder = True , children = []) ) curProjectDest = curOrgDest [ - 1 ][ \"children\" ] curProjectSource = curOrgSource [ project_id ] for user_id in curProjectSource : userN = countUser [ org_id ][ project_id ][ user_id ] userPub = countUserPub [ org_id ][ project_id ][ user_id ] userGood = countUserGood [ org_id ][ project_id ][ user_id ] userTot = countUserTotal [ user_id ] userTitle = titleBadge ( user_id , \"u\" , userPub , userGood , userN , userTot ) curProjectDest . append ( dict ( title = str ( userTitle ), folder = True , children = []) ) curUserDest = curProjectDest [ - 1 ][ \"children\" ] curUserSource = curProjectSource [ user_id ] for query_id in curUserSource : projectQueryInfo = objInfo [ \"q\" ][ query_id ] ( orgName , org_id , projectName , project_id , userName , user_id , queryName , queryShared , queryOwn , ) = projectQueryInfo [ \"\" ] queryPub = projectQueryInfo [ \"publ\" ] queryGood = projectQueryInfo [ \"good\" ] queryVersions = projectQueryInfo [ \"v\" ] queryOwnRep = \"r\" if queryOwn else \"v\" queryMyRep = \"qmy\" if queryOwn else \"\" querySharedRep = \"\" if queryShared else \"qpriv\" queryIdRep = iEncode ( \"q\" , query_id ) rename = dedent ( f \"\"\"<a class=\" { queryOwnRep } _q\" obj_id=\" { queryIdRep } \" href=\"#\"></a>\"\"\" ) versionRep = \" \" . join ( formatVersion ( \"q\" , query_id , v , queryVersions [ VERSION_INDEX [ v ]] ) for v in VERSION_ORDER ) curUserDest . append ( dict ( title = dedent ( f \"\"\" { versionRep } <a class=\"q { queryMyRep } { querySharedRep } \" n=\"1\" query_id=\" { query_id } \" href=\"#\"> { hEsc ( queryName ) } </a> <a class=\"md\" href=\"#\"></a> { rename } \"\"\" ), key = f \"q { query_id } \" , folder = False , ) ) return dict ( data = json . dumps ( dest ))","title":"Querytree"},{"location":"server/bymodule/querytree/#querytree","text":"","title":"querytree"},{"location":"server/bymodule/querytree/#querytree.QUERYTREE","text":"","title":"QUERYTREE"},{"location":"server/bymodule/querytree/#querytree.QUERYTREE.get","text":"Get the metadata of all queries and deliver it as json. Source code in modules/querytree.py def get ( self ): \"\"\"Get the metadata of all queries and deliver it as json. \"\"\" auth = current . auth db = current . db VERSION_ORDER = current . VERSION_ORDER VERSION_INDEX = current . VERSION_INDEX myId = None if auth . user : myId = auth . user . id objInfo = collections . defaultdict ( lambda : {}) def titleBadge ( obj_id , objType , publ , good , num , tot ): name = objInfo [ objType ][ obj_id ] if objType is not None else \"Shared Queries\" nums = [] if publ != 0 : nums . append ( f '<span class=\"special fa fa-quote-right\"> { publ } </span>' ) if good != 0 : nums . append ( f '<span class=\"good fa fa-gears\"> { good } </span>' ) badge = \"\" if len ( nums ) == 0 : if tot == num : badge = f '<span class=\"total\"> { tot } </span>' else : badge = f ' { num } of <span class=\"total\"> { tot } </span>' else : nRep = \", \" . join ( nums ) if tot == num : badge = f ' { nRep } of <span class=\"total\"> { tot } </span>' else : badge = f ' { nRep } of { num } of all <span class=\"total\"> { tot } </span>' rename = \"\" select = \"\" if objType in { \"o\" , \"p\" }: if myId is not None : if obj_id : rename = ( f '<a class=\"r_ { objType } \" obj_id=\" { obj_id } \" href=\"#\"></a>' ) select = dedent ( f \"\"\"<a class=\"s_ { objType } fa fa-lg\" obj_id=\" { obj_id } \" href=\"#\"></a>\"\"\" ) else : if obj_id : rename = ( f '<a class=\"v_ { objType } \" obj_id=\" { obj_id } \" href=\"#\"></a>' ) return dedent ( f \"\"\" { select } <span n=\"1\"> { hEsc ( name ) } </span><span class=\"brq\">( { badge } )</span> { rename } \"\"\" ) condition = ( dedent ( \"\"\" where query.is_shared = 'T' \"\"\" ) if myId is None else dedent ( f \"\"\" where query.is_shared = 'T' or query.created_by = { myId } \"\"\" ) ) projectQueryXSql = dedent ( f \"\"\" select query_exe.query_id, query_exe.version, query_exe.is_published, query_exe.published_on, query_exe.modified_on, query_exe.executed_on from query_exe inner join query on query.id = query_exe.query_id { condition } ; \"\"\" ) projectQuerySql = dedent ( f \"\"\" select query.id as query_id, organization.name as org_name, organization.id as org_id, project.name as project_name, project.id as project_id, concat(auth_user.first_name, ' ', auth_user.last_name) as uname, auth_user.id as user_id, query.name as query_name, query.is_shared as is_shared from query inner join auth_user on query.created_by = auth_user.id inner join project on query.project = project.id inner join organization on query.organization = organization.id { condition } order by organization.name, project.name, auth_user.last_name, auth_user.first_name, query.name ; \"\"\" ) projectQuery = db . executesql ( projectQuerySql ) projectQueryX = db . executesql ( projectQueryXSql ) projectQueries = collections . OrderedDict () for ( query_id , orgName , org_id , projectName , project_id , userName , user_id , queryName , queryShared , ) in projectQuery : qSharedStatus = queryShared == \"T\" qOwnStatus = user_id == myId projectQueries [ query_id ] = { \"\" : ( orgName , org_id , projectName , project_id , userName , user_id , queryName , qSharedStatus , qOwnStatus , ), \"publ\" : False , \"good\" : False , \"v\" : [ 4 for v in VERSION_ORDER ], } now = current . request . utcnow for ( query_id , vr , queryIs_published , queryPublished_on , queryMod_on , queryExe_on , ) in projectQueryX : queryInfo = projectQueries [ query_id ] queryExeStatus = None if queryExe_on : queryExeStatus = queryExe_on >= queryMod_on queryPubStatus = ( False if queryIs_published != \"T\" else None if queryPublished_on > now - PUBLISH_FREEZE else True ) queryStatus = ( 1 if queryPubStatus else 2 if queryPubStatus is None else 3 if queryExeStatus else 4 if queryExeStatus is None else 5 ) queryInfo [ \"v\" ][ VERSION_INDEX [ vr ]] = queryStatus if queryPubStatus or queryPubStatus is None : queryInfo [ \"publ\" ] = True if queryExeStatus : queryInfo [ \"good\" ] = True projectOrgSql = dedent ( \"\"\" select name, id from organization order by name ; \"\"\" ) porg = db . executesql ( projectOrgSql ) projectSql = dedent ( \"\"\" select name, id from project order by name ; \"\"\" ) project = db . executesql ( projectSql ) tree = collections . OrderedDict () countSet = collections . defaultdict ( lambda : set ()) countOrg = collections . defaultdict ( lambda : 0 ) countOrgPub = collections . defaultdict ( lambda : 0 ) countOrgGood = collections . defaultdict ( lambda : 0 ) countOrgTotal = collections . defaultdict ( lambda : 0 ) countProject = collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 ) ) countProjectPub = collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 ) ) countProjectGood = collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 ) ) countProjectTotal = collections . defaultdict ( lambda : 0 ) countUser = collections . defaultdict ( lambda : collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 )) ) countUserPub = collections . defaultdict ( lambda : collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 )) ) countUserGood = collections . defaultdict ( lambda : collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 )) ) countUserTotal = collections . defaultdict ( lambda : 0 ) count = 0 countPub = 0 countGood = 0 for query_id in projectQueries : projectQueryInfo = projectQueries [ query_id ] ( orgName , org_id , projectName , project_id , userName , user_id , queryName , queryShared , queryOwn , ) = projectQueryInfo [ \"\" ] queryPub = projectQueryInfo [ \"publ\" ] queryGood = projectQueryInfo [ \"good\" ] countSet [ \"o\" ] . add ( org_id ) countSet [ \"p\" ] . add ( project_id ) countSet [ \"u\" ] . add ( user_id ) countSet [ \"q\" ] . add ( query_id ) objInfo [ \"o\" ][ org_id ] = orgName objInfo [ \"p\" ][ project_id ] = projectName objInfo [ \"u\" ][ user_id ] = userName if queryOwn : countSet [ \"m\" ] . add ( query_id ) if not queryShared : countSet [ \"r\" ] . add ( query_id ) if queryPub : countUserPub [ org_id ][ project_id ][ user_id ] += 1 countProjectPub [ org_id ][ project_id ] += 1 countOrgPub [ org_id ] += 1 countPub += 1 if queryGood : countUserGood [ org_id ][ project_id ][ user_id ] += 1 countProjectGood [ org_id ][ project_id ] += 1 countOrgGood [ org_id ] += 1 countGood += 1 tree . setdefault ( org_id , collections . OrderedDict ()) . setdefault ( project_id , collections . OrderedDict () ) . setdefault ( user_id , []) . append ( query_id ) count += 1 countOrg [ org_id ] += 1 countProject [ org_id ][ project_id ] += 1 countUser [ org_id ][ project_id ][ user_id ] += 1 countOrgTotal [ org_id ] += 1 countProjectTotal [ project_id ] += 1 countUserTotal [ user_id ] += 1 objInfo [ \"o\" ][ 0 ] = \"Projects without Queries\" objInfo [ \"p\" ][ 0 ] = \"New Project\" objInfo [ \"u\" ][ 0 ] = \"\" objInfo [ \"q\" ] = projectQueries countOrg [ 0 ] = 0 countProject [ 0 ][ 0 ] = 0 for ( orgName , org_id ) in porg : if org_id in objInfo [ \"o\" ]: continue countSet [ \"o\" ] . add ( org_id ) objInfo [ \"o\" ][ org_id ] = orgName tree [ org_id ] = collections . OrderedDict () for ( projectName , project_id ) in project : if project_id in objInfo [ \"p\" ]: continue countSet [ \"o\" ] . add ( 0 ) countSet [ \"p\" ] . add ( project_id ) objInfo [ \"p\" ][ project_id ] = projectName tree . setdefault ( 0 , collections . OrderedDict ())[ project_id ] = collections . OrderedDict () categoryCount = dict (( x [ 0 ], len ( x [ 1 ])) for x in countSet . items ()) categoryCount [ \"user_id\" ] = myId title = titleBadge ( None , None , countPub , countGood , count , count ) dest = [ dict ( title = str ( title ), folder = True , children = [], data = categoryCount )] curDest = dest [ - 1 ][ \"children\" ] curSource = tree for org_id in curSource : orgN = countOrg [ org_id ] orgPub = countOrgPub [ org_id ] orgGood = countOrgGood [ org_id ] orgTot = countOrgTotal [ org_id ] orgTitle = titleBadge ( org_id , \"o\" , orgPub , orgGood , orgN , orgTot ) curDest . append ( dict ( title = str ( orgTitle ), folder = True , children = [])) curOrgDest = curDest [ - 1 ][ \"children\" ] curOrgSource = curSource [ org_id ] for project_id in curOrgSource : projectN = countProject [ org_id ][ project_id ] projectPub = countProjectPub [ org_id ][ project_id ] projectPub = countProjectGood [ org_id ][ project_id ] projectTot = countProjectTotal [ project_id ] projectTitle = titleBadge ( project_id , \"p\" , projectPub , projectPub , projectN , projectTot ) curOrgDest . append ( dict ( title = str ( projectTitle ), folder = True , children = []) ) curProjectDest = curOrgDest [ - 1 ][ \"children\" ] curProjectSource = curOrgSource [ project_id ] for user_id in curProjectSource : userN = countUser [ org_id ][ project_id ][ user_id ] userPub = countUserPub [ org_id ][ project_id ][ user_id ] userGood = countUserGood [ org_id ][ project_id ][ user_id ] userTot = countUserTotal [ user_id ] userTitle = titleBadge ( user_id , \"u\" , userPub , userGood , userN , userTot ) curProjectDest . append ( dict ( title = str ( userTitle ), folder = True , children = []) ) curUserDest = curProjectDest [ - 1 ][ \"children\" ] curUserSource = curProjectSource [ user_id ] for query_id in curUserSource : projectQueryInfo = objInfo [ \"q\" ][ query_id ] ( orgName , org_id , projectName , project_id , userName , user_id , queryName , queryShared , queryOwn , ) = projectQueryInfo [ \"\" ] queryPub = projectQueryInfo [ \"publ\" ] queryGood = projectQueryInfo [ \"good\" ] queryVersions = projectQueryInfo [ \"v\" ] queryOwnRep = \"r\" if queryOwn else \"v\" queryMyRep = \"qmy\" if queryOwn else \"\" querySharedRep = \"\" if queryShared else \"qpriv\" queryIdRep = iEncode ( \"q\" , query_id ) rename = dedent ( f \"\"\"<a class=\" { queryOwnRep } _q\" obj_id=\" { queryIdRep } \" href=\"#\"></a>\"\"\" ) versionRep = \" \" . join ( formatVersion ( \"q\" , query_id , v , queryVersions [ VERSION_INDEX [ v ]] ) for v in VERSION_ORDER ) curUserDest . append ( dict ( title = dedent ( f \"\"\" { versionRep } <a class=\"q { queryMyRep } { querySharedRep } \" n=\"1\" query_id=\" { query_id } \" href=\"#\"> { hEsc ( queryName ) } </a> <a class=\"md\" href=\"#\"></a> { rename } \"\"\" ), key = f \"q { query_id } \" , folder = False , ) ) return dict ( data = json . dumps ( dest ))","title":"get()"},{"location":"server/bymodule/record/","text":"record \u00b6 RECORD \u00b6 Handles record data. This is about some aspects of query and note records and organization and project records by which they are organized. And it is about word records. It is called by controllers that fetch sidebar material, see M:RECORD.body . body ( self ) \u00b6 Produce data that will get sidebar material later via AJAX. Web2py device We use a web2py device here that shields the mechanics of an AJAX call. That leads to code that is not very clear. These calls are hidden in Web2Py javascript, and you will not find them in the SHEBANQ client app code. This is where the controllers C:hebrew.sidewordbody , C:hebrew.sidequerybody and C:hebrew.sidenotebody will be used. These calls are used when the user requests a record page directly. The web2py device takes care that when the sidebar is editable, the edits will be submitted via AJAX. So far so good. However, when a user navigates between main pages and record pages, the pages are not served from scratch, and new sidebar material has to be fetched through AJAX as well. In the SHEBANQ code we do these AJAX calls explicitly client code: {sidecontent.fetch} . Since I was not able to use the Web2py approach for this part of the use case, it is probably a good idea ditch this usage of the web2py mechanism altogehter in favour fo the more explicit way, which is already in our code. Now we have two ways of doing the same thing! My apologies. Source code in modules/record.py def body ( self ): \"\"\"Produce data that will get sidebar material later via AJAX. !!! caution \"Web2py device\" We use a [web2py device]({{web2pycomponents}}) here that shields the mechanics of an AJAX call. That leads to code that is not very clear. These calls are hidden in Web2Py javascript, and you will not find them in the SHEBANQ client app code. This is where the controllers [C:hebrew.sidewordbody][controllers.hebrew.sidewordbody], [C:hebrew.sidequerybody][controllers.hebrew.sidequerybody] and [C:hebrew.sidenotebody][controllers.hebrew.sidenotebody] will be used. These calls are used when the user requests a **record** page directly. The web2py device takes care that when the sidebar is editable, the edits will be submitted via AJAX. So far so good. However, when a user navigates between **main** pages and **record** pages, the pages are not served from scratch, and new sidebar material has to be fetched through AJAX as well. In the SHEBANQ code we do these AJAX calls explicitly client code: [{sidecontent.fetch}][sidecontentfetch]. Since I was not able to use the Web2py approach for this part of the use case, it is probably a good idea ditch this usage of the web2py mechanism altogehter in favour fo the more explicit way, which is already in our code. Now we have two ways of doing the same thing! My apologies. \"\"\" # noqa E501 Check = current . Check LOAD = current . LOAD iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) vr = Check . field ( \"material\" , \"\" , \"version\" ) mr = Check . field ( \"material\" , \"\" , \"mr\" ) qw = Check . field ( \"material\" , \"\" , \"qw\" ) kind = \"word\" if qw == \"w\" else \"query\" if qw == \"q\" else \"note\" ( authorized , msg ) = self . authRead ( mr , qw , iidRep ) if authorized : msg = f \"fetching { kind } \" return dict ( load = LOAD ( \"hebrew\" , f \"side { kind } body\" , extension = \"load\" , vars = dict ( mr = \"r\" , qw = \"w\" , version = vr , iid = iidRep ), ajax = False , ajax_trap = True , target = f \" { kind } body\" , content = msg , ) ) setItem ( self ) \u00b6 Saves a record to the database. Meant for: objects that organize the notes and query overviews: organizations and projects. Can also save query records. Note records and word records Word records are readonly and will nver be saved. There are no such things as note records. Notes are organized in sets bases on keywords and authoring users, but a notes set does not have an embodiment as record in the database. Source code in modules/record.py def setItem ( self ): \"\"\"Saves a record to the database. Meant for: objects that organize the notes and query overviews: organizations and projects. Can also save query records. !!! hint \"Note records and word records\" Word records are readonly and will nver be saved. There are no such things as note records. Notes are organized in sets bases on keywords and authoring users, but a notes set does not have an embodiment as record in the database. \"\"\" Check = current . Check auth = current . auth msgs = [] orgRecord = {} projectRecord = {} good = False orgGood = False projectGood = False obj_id = None label = None table = None fields = None myId = auth . user . id if auth . user is not None else None requestVars = current . request . vars for x in [ 1 ]: tp = requestVars . tp if tp not in TPS : msgs . append (( \"error\" , f \"unknown type { tp } !\" )) break ( label , table ) = TPS [ tp ] obj_id = Check . isId ( \"obj_id\" , tp , label , msgs ) upd = requestVars . upd if obj_id is None : break if upd not in { \"true\" , \"false\" }: msgs . append (( \"error\" , f \"invalid instruction { upd } !\" )) break upd = True if upd == \"true\" else False if upd and not myId : msgs . append (( \"error\" , \"for updating you have to be logged in!\" )) break fields = [ \"name\" ] if tp == \"q\" : Query = self . Query fields . append ( \"organization\" ) fields . append ( \"project\" ) else : fields . append ( \"website\" ) if upd : ( authorized , msg ) = ( Query . authWrite ( obj_id ) if tp == \"q\" else self . authWriteGeneric ( label ) ) else : ( authorized , msg ) = ( Query . authRead ( obj_id ) if tp == \"q\" else self . authReadGeneric ( label ) ) if not authorized : msgs . append (( \"error\" , msg )) break if upd : if tp == \"q\" : subfields = [ \"name\" , \"website\" ] fieldValues = [ requestVars . name ] doNewOrg = requestVars . doNewOrg doNewProject = requestVars . doNewProject if doNewOrg not in { \"true\" , \"false\" }: msgs . append ( ( \"error\" , f \"invalid instruction for organization { doNewOrg } !\" , ) ) break doNewOrg = doNewOrg == \"true\" if doNewProject not in { \"true\" , \"false\" }: msgs . append ( ( \"error\" , f \"invalid instruction for project { doNewProject } !\" , ) ) break doNewProject = doNewProject == \"true\" orgGood = True if doNewOrg : ( orgGood , org_id ) = self . update ( \"o\" , 0 , myId , subfields , [ requestVars . org_name , requestVars . org_website ], msgs , ) if orgGood : orgRecord = dict ( id = org_id , name = requestVars . org_name , website = requestVars . org_website , ) else : org_id = Check . isId ( \"org_id\" , \"o\" , TPS [ \"o\" ][ 0 ], msgs ) projectGood = True if doNewProject : ( projectGood , project_id ) = self . update ( \"p\" , 0 , myId , subfields , [ requestVars . project_name , requestVars . project_website ], msgs , ) if projectGood : projectRecord = dict ( id = project_id , name = requestVars . project_name , website = requestVars . project_website , ) else : project_id = Check . isId ( \"project_id\" , \"p\" , TPS [ \"o\" ][ 0 ], msgs ) if not orgGood or not projectGood : break if org_id is None or project_id is None : break fieldValues . extend ([ org_id , project_id ]) else : fieldValues = [ requestVars [ field ] for field in fields ] ( good , obj_idNew ) = self . update ( tp , obj_id , myId , fields , fieldValues , msgs ) if not good : break obj_id = obj_idNew else : good = True record = self . make ( tp , label , table , fields , obj_id , good , msgs ) return dict ( data = json . dumps ( dict ( record = record , orgRecord = orgRecord , projectRecord = projectRecord , msgs = msgs , good = good , orgGood = orgGood , projectGood = projectGood , ) ) )","title":"Record"},{"location":"server/bymodule/record/#record","text":"","title":"record"},{"location":"server/bymodule/record/#record.RECORD","text":"Handles record data. This is about some aspects of query and note records and organization and project records by which they are organized. And it is about word records. It is called by controllers that fetch sidebar material, see M:RECORD.body .","title":"RECORD"},{"location":"server/bymodule/record/#record.RECORD.body","text":"Produce data that will get sidebar material later via AJAX. Web2py device We use a web2py device here that shields the mechanics of an AJAX call. That leads to code that is not very clear. These calls are hidden in Web2Py javascript, and you will not find them in the SHEBANQ client app code. This is where the controllers C:hebrew.sidewordbody , C:hebrew.sidequerybody and C:hebrew.sidenotebody will be used. These calls are used when the user requests a record page directly. The web2py device takes care that when the sidebar is editable, the edits will be submitted via AJAX. So far so good. However, when a user navigates between main pages and record pages, the pages are not served from scratch, and new sidebar material has to be fetched through AJAX as well. In the SHEBANQ code we do these AJAX calls explicitly client code: {sidecontent.fetch} . Since I was not able to use the Web2py approach for this part of the use case, it is probably a good idea ditch this usage of the web2py mechanism altogehter in favour fo the more explicit way, which is already in our code. Now we have two ways of doing the same thing! My apologies. Source code in modules/record.py def body ( self ): \"\"\"Produce data that will get sidebar material later via AJAX. !!! caution \"Web2py device\" We use a [web2py device]({{web2pycomponents}}) here that shields the mechanics of an AJAX call. That leads to code that is not very clear. These calls are hidden in Web2Py javascript, and you will not find them in the SHEBANQ client app code. This is where the controllers [C:hebrew.sidewordbody][controllers.hebrew.sidewordbody], [C:hebrew.sidequerybody][controllers.hebrew.sidequerybody] and [C:hebrew.sidenotebody][controllers.hebrew.sidenotebody] will be used. These calls are used when the user requests a **record** page directly. The web2py device takes care that when the sidebar is editable, the edits will be submitted via AJAX. So far so good. However, when a user navigates between **main** pages and **record** pages, the pages are not served from scratch, and new sidebar material has to be fetched through AJAX as well. In the SHEBANQ code we do these AJAX calls explicitly client code: [{sidecontent.fetch}][sidecontentfetch]. Since I was not able to use the Web2py approach for this part of the use case, it is probably a good idea ditch this usage of the web2py mechanism altogehter in favour fo the more explicit way, which is already in our code. Now we have two ways of doing the same thing! My apologies. \"\"\" # noqa E501 Check = current . Check LOAD = current . LOAD iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) vr = Check . field ( \"material\" , \"\" , \"version\" ) mr = Check . field ( \"material\" , \"\" , \"mr\" ) qw = Check . field ( \"material\" , \"\" , \"qw\" ) kind = \"word\" if qw == \"w\" else \"query\" if qw == \"q\" else \"note\" ( authorized , msg ) = self . authRead ( mr , qw , iidRep ) if authorized : msg = f \"fetching { kind } \" return dict ( load = LOAD ( \"hebrew\" , f \"side { kind } body\" , extension = \"load\" , vars = dict ( mr = \"r\" , qw = \"w\" , version = vr , iid = iidRep ), ajax = False , ajax_trap = True , target = f \" { kind } body\" , content = msg , ) )","title":"body()"},{"location":"server/bymodule/record/#record.RECORD.setItem","text":"Saves a record to the database. Meant for: objects that organize the notes and query overviews: organizations and projects. Can also save query records. Note records and word records Word records are readonly and will nver be saved. There are no such things as note records. Notes are organized in sets bases on keywords and authoring users, but a notes set does not have an embodiment as record in the database. Source code in modules/record.py def setItem ( self ): \"\"\"Saves a record to the database. Meant for: objects that organize the notes and query overviews: organizations and projects. Can also save query records. !!! hint \"Note records and word records\" Word records are readonly and will nver be saved. There are no such things as note records. Notes are organized in sets bases on keywords and authoring users, but a notes set does not have an embodiment as record in the database. \"\"\" Check = current . Check auth = current . auth msgs = [] orgRecord = {} projectRecord = {} good = False orgGood = False projectGood = False obj_id = None label = None table = None fields = None myId = auth . user . id if auth . user is not None else None requestVars = current . request . vars for x in [ 1 ]: tp = requestVars . tp if tp not in TPS : msgs . append (( \"error\" , f \"unknown type { tp } !\" )) break ( label , table ) = TPS [ tp ] obj_id = Check . isId ( \"obj_id\" , tp , label , msgs ) upd = requestVars . upd if obj_id is None : break if upd not in { \"true\" , \"false\" }: msgs . append (( \"error\" , f \"invalid instruction { upd } !\" )) break upd = True if upd == \"true\" else False if upd and not myId : msgs . append (( \"error\" , \"for updating you have to be logged in!\" )) break fields = [ \"name\" ] if tp == \"q\" : Query = self . Query fields . append ( \"organization\" ) fields . append ( \"project\" ) else : fields . append ( \"website\" ) if upd : ( authorized , msg ) = ( Query . authWrite ( obj_id ) if tp == \"q\" else self . authWriteGeneric ( label ) ) else : ( authorized , msg ) = ( Query . authRead ( obj_id ) if tp == \"q\" else self . authReadGeneric ( label ) ) if not authorized : msgs . append (( \"error\" , msg )) break if upd : if tp == \"q\" : subfields = [ \"name\" , \"website\" ] fieldValues = [ requestVars . name ] doNewOrg = requestVars . doNewOrg doNewProject = requestVars . doNewProject if doNewOrg not in { \"true\" , \"false\" }: msgs . append ( ( \"error\" , f \"invalid instruction for organization { doNewOrg } !\" , ) ) break doNewOrg = doNewOrg == \"true\" if doNewProject not in { \"true\" , \"false\" }: msgs . append ( ( \"error\" , f \"invalid instruction for project { doNewProject } !\" , ) ) break doNewProject = doNewProject == \"true\" orgGood = True if doNewOrg : ( orgGood , org_id ) = self . update ( \"o\" , 0 , myId , subfields , [ requestVars . org_name , requestVars . org_website ], msgs , ) if orgGood : orgRecord = dict ( id = org_id , name = requestVars . org_name , website = requestVars . org_website , ) else : org_id = Check . isId ( \"org_id\" , \"o\" , TPS [ \"o\" ][ 0 ], msgs ) projectGood = True if doNewProject : ( projectGood , project_id ) = self . update ( \"p\" , 0 , myId , subfields , [ requestVars . project_name , requestVars . project_website ], msgs , ) if projectGood : projectRecord = dict ( id = project_id , name = requestVars . project_name , website = requestVars . project_website , ) else : project_id = Check . isId ( \"project_id\" , \"p\" , TPS [ \"o\" ][ 0 ], msgs ) if not orgGood or not projectGood : break if org_id is None or project_id is None : break fieldValues . extend ([ org_id , project_id ]) else : fieldValues = [ requestVars [ field ] for field in fields ] ( good , obj_idNew ) = self . update ( tp , obj_id , myId , fields , fieldValues , msgs ) if not good : break obj_id = obj_idNew else : good = True record = self . make ( tp , label , table , fields , obj_id , good , msgs ) return dict ( data = json . dumps ( dict ( record = record , orgRecord = orgRecord , projectRecord = projectRecord , msgs = msgs , good = good , orgGood = orgGood , projectGood = projectGood , ) ) )","title":"setItem()"},{"location":"server/bymodule/side/","text":"side \u00b6","title":"Side"},{"location":"server/bymodule/side/#side","text":"","title":"side"},{"location":"server/bymodule/test/","text":"test \u00b6","title":"Test"},{"location":"server/bymodule/test/#test","text":"","title":"test"},{"location":"server/bymodule/urls/","text":"urls \u00b6","title":"Urls"},{"location":"server/bymodule/urls/#urls","text":"","title":"urls"},{"location":"server/bymodule/verse/","text":"verse \u00b6 VERSE \u00b6 Get verse data of a verse. The verse data are the linguistic feature data for the words in a verse. get ( self ) \u00b6 Get linguistic data of a verse. Source code in modules/verse.py def get ( self ): \"\"\"Get linguistic data of a verse. \"\"\" extension = current . request . extension if extension == \"json\" : return self . getJson () Check = current . Check Caching = current . Caching vr = Check . field ( \"material\" , \"\" , \"version\" ) bk = Check . field ( \"material\" , \"\" , \"book\" ) ch = Check . field ( \"material\" , \"\" , \"chapter\" ) vs = Check . field ( \"material\" , \"\" , \"verse\" ) tr = Check . field ( \"material\" , \"\" , \"tr\" ) if vs is None : return dict ( good = False , msgs = []) return Caching . get ( f \"verse_ { vr } _ { bk } _ { ch } _ { vs } _ { tr } _\" , lambda : self . get_c ( vr , bk , ch , vs , tr ), None , )","title":"Verse"},{"location":"server/bymodule/verse/#verse","text":"","title":"verse"},{"location":"server/bymodule/verse/#verse.VERSE","text":"Get verse data of a verse. The verse data are the linguistic feature data for the words in a verse.","title":"VERSE"},{"location":"server/bymodule/verse/#verse.VERSE.get","text":"Get linguistic data of a verse. Source code in modules/verse.py def get ( self ): \"\"\"Get linguistic data of a verse. \"\"\" extension = current . request . extension if extension == \"json\" : return self . getJson () Check = current . Check Caching = current . Caching vr = Check . field ( \"material\" , \"\" , \"version\" ) bk = Check . field ( \"material\" , \"\" , \"book\" ) ch = Check . field ( \"material\" , \"\" , \"chapter\" ) vs = Check . field ( \"material\" , \"\" , \"verse\" ) tr = Check . field ( \"material\" , \"\" , \"tr\" ) if vs is None : return dict ( good = False , msgs = []) return Caching . get ( f \"verse_ { vr } _ { bk } _ { ch } _ { vs } _ { tr } _\" , lambda : self . get_c ( vr , bk , ch , vs , tr ), None , )","title":"get()"},{"location":"server/bymodule/versecontent/","text":"versecontent \u00b6 VerseContent \u00b6 __init__ ( self , vr , book_name , chapter_num , verse_num , xml = None , wordData = None , tp = None , tr = None , mr = None , lang = 'en' ) special \u00b6 Handle a single verse. It can retrieve word data from the database and render it in various textual formats. Source code in modules/versecontent.py def __init__ ( self , vr , book_name , chapter_num , verse_num , xml = None , wordData = None , tp = None , tr = None , mr = None , lang = \"en\" , ): \"\"\"Handle a single verse. It can retrieve word data from the database and render it in various textual formats. \"\"\" self . version = vr self . tp = tp self . tr = tr self . mr = mr self . lang = lang self . book_name = book_name self . chapter_num = chapter_num self . verse_num = verse_num self . xml = xml self . wordData = wordData self . process ()","title":"Versecontent"},{"location":"server/bymodule/versecontent/#versecontent","text":"","title":"versecontent"},{"location":"server/bymodule/versecontent/#versecontent.VerseContent","text":"","title":"VerseContent"},{"location":"server/bymodule/versecontent/#versecontent.VerseContent.__init__","text":"Handle a single verse. It can retrieve word data from the database and render it in various textual formats. Source code in modules/versecontent.py def __init__ ( self , vr , book_name , chapter_num , verse_num , xml = None , wordData = None , tp = None , tr = None , mr = None , lang = \"en\" , ): \"\"\"Handle a single verse. It can retrieve word data from the database and render it in various textual formats. \"\"\" self . version = vr self . tp = tp self . tr = tr self . mr = mr self . lang = lang self . book_name = book_name self . chapter_num = chapter_num self . verse_num = verse_num self . xml = xml self . wordData = wordData self . process ()","title":"__init__()"},{"location":"server/bymodule/versescontent/","text":"versescontent \u00b6 VersesContent \u00b6 __init__ ( self , vr , mr , verseIds = None , chapter = None , tp = None , tr = None , lang = 'en' ) special \u00b6 my docs Source code in modules/versescontent.py def __init__ ( self , vr , mr , verseIds = None , chapter = None , tp = None , tr = None , lang = \"en\" , ): \"\"\"my docs\"\"\" if tr is None : tr = \"hb\" self . version = vr self . mr = mr self . tp = tp self . tr = tr self . lang = lang self . chapter = chapter self . verseIds = verseIds self . process ()","title":"Versescontent"},{"location":"server/bymodule/versescontent/#versescontent","text":"","title":"versescontent"},{"location":"server/bymodule/versescontent/#versescontent.VersesContent","text":"","title":"VersesContent"},{"location":"server/bymodule/versescontent/#versescontent.VersesContent.__init__","text":"my docs Source code in modules/versescontent.py def __init__ ( self , vr , mr , verseIds = None , chapter = None , tp = None , tr = None , lang = \"en\" , ): \"\"\"my docs\"\"\" if tr is None : tr = \"hb\" self . version = vr self . mr = mr self . tp = tp self . tr = tr self . lang = lang self . chapter = chapter self . verseIds = verseIds self . process ()","title":"__init__()"},{"location":"server/bymodule/viewdefs/","text":"viewdefs \u00b6","title":"Viewdefs"},{"location":"server/bymodule/viewdefs/#viewdefs","text":"","title":"viewdefs"},{"location":"server/bymodule/viewsettings/","text":"viewsettings \u00b6 VIEWSETTINGS \u00b6 Handles the settings that customize the look and feel on the page. In fact, all parameters that originate from the user are treated here. They are stored in local storage in the browser, to when a page is loaded, these stored settings will be merged with the incoming request variables, and the outcome of that will again be stored in LocalStorage. page ( self ) \u00b6 Determines all settings and writes them out to Javascript. This is the start of rendering a page. At the client, the Javascript picks up the data and uses it to customise the view. Client code: {viewstate} Source code in modules/viewsettings.py def page ( self ): \"\"\"Determines all settings and writes them out to Javascript. This is the start of rendering a page. At the client, the Javascript picks up the data and uses it to customise the view. Client code: [{viewstate}][viewstate] \"\"\" ViewDefs = current . ViewDefs pageConfig = self . writeConfig () return dict ( pageConfig = pageConfig , colorPicker = ViewDefs . colorPicker , legend = LEGEND , tabLabels = ViewDefs . tabLabels , trLabels = ViewDefs . trLabels , nTabViews = ViewDefs . nTabViews , trInfo = ViewDefs . trInfo , )","title":"Viewsettings"},{"location":"server/bymodule/viewsettings/#viewsettings","text":"","title":"viewsettings"},{"location":"server/bymodule/viewsettings/#viewsettings.VIEWSETTINGS","text":"Handles the settings that customize the look and feel on the page. In fact, all parameters that originate from the user are treated here. They are stored in local storage in the browser, to when a page is loaded, these stored settings will be merged with the incoming request variables, and the outcome of that will again be stored in LocalStorage.","title":"VIEWSETTINGS"},{"location":"server/bymodule/viewsettings/#viewsettings.VIEWSETTINGS.page","text":"Determines all settings and writes them out to Javascript. This is the start of rendering a page. At the client, the Javascript picks up the data and uses it to customise the view. Client code: {viewstate} Source code in modules/viewsettings.py def page ( self ): \"\"\"Determines all settings and writes them out to Javascript. This is the start of rendering a page. At the client, the Javascript picks up the data and uses it to customise the view. Client code: [{viewstate}][viewstate] \"\"\" ViewDefs = current . ViewDefs pageConfig = self . writeConfig () return dict ( pageConfig = pageConfig , colorPicker = ViewDefs . colorPicker , legend = LEGEND , tabLabels = ViewDefs . tabLabels , trLabels = ViewDefs . trLabels , nTabViews = ViewDefs . nTabViews , trInfo = ViewDefs . trInfo , )","title":"page()"},{"location":"server/bymodule/word/","text":"word \u00b6 WORD \u00b6 body ( self ) \u00b6 Retrieves a query word based on parameters. Source code in modules/word.py def body ( self ): \"\"\"Retrieves a query word based on parameters. \"\"\" Check = current . Check vr = Check . field ( \"material\" , \"\" , \"version\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) ( iid , keywords ) = iDecode ( \"w\" , iidRep ) ( authorized , msg ) = self . authRead ( vr , iid ) msgs = [] if not authorized : msgs . append (( \"error\" , msg )) return dict ( wordRecord = dict (), word = json . dumps ( dict ()), msgs = json . dumps ( msgs ), ) wordRecord = self . getInfo ( iid , vr , msgs ) return dict ( vr = vr , wordRecord = wordRecord , word = json . dumps ( wordRecord ), msgs = json . dumps ( msgs ), )","title":"Word"},{"location":"server/bymodule/word/#word","text":"","title":"word"},{"location":"server/bymodule/word/#word.WORD","text":"","title":"WORD"},{"location":"server/bymodule/word/#word.WORD.body","text":"Retrieves a query word based on parameters. Source code in modules/word.py def body ( self ): \"\"\"Retrieves a query word based on parameters. \"\"\" Check = current . Check vr = Check . field ( \"material\" , \"\" , \"version\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) ( iid , keywords ) = iDecode ( \"w\" , iidRep ) ( authorized , msg ) = self . authRead ( vr , iid ) msgs = [] if not authorized : msgs . append (( \"error\" , msg )) return dict ( wordRecord = dict (), word = json . dumps ( dict ()), msgs = json . dumps ( msgs ), ) wordRecord = self . getInfo ( iid , vr , msgs ) return dict ( vr = vr , wordRecord = wordRecord , word = json . dumps ( wordRecord ), msgs = json . dumps ( msgs ), )","title":"body()"}]}