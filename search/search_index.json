{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Technical Home \u00b6 What it is, how it is designed, how it works and how it can be installed and maintained. About \u00b6 SHEBANQ is a website built as an application in the Web2Py framework. It uses MySQL databases to store its dynamic data, which is generated by users, and its static data, which consists of the text of the hebrew Bible and linguistic annotations of the ETCBC . The static data is delivered via the BHSA repository, where it arrived through a pipeline ) from the source data as it sits on ETCBC servers. The specialty of SHEBANQ is that it offers users the facility to run queries against the data and to store those queries so theat they can be shared and published. The query engine for this is Emdros which sits on top of MySQL and speaks with it. Shebanq and the pipeline have been constructed using Text-Fabric as the main tool. There are several kinds of documentation of SHEBANQ, see documentation where it is decribed how to maintain that information. In order to develop effectively, we use a test framework, see testing . Quickly jump to a topic below, or use the navigation controls. Conventions \u00b6 Code references \u00b6 This documentation contains many references to all kind of things. Some references have shapes that help you recognize to what they refer: [\u2208 element] refers to a page element called element ; it links to its documentation; [M:XXX.yyy] refers to Python code for yyy in module modules/xxx.py ; [C:xxx.yyy] refers to Python controller yyy() in file controllers/xx;x.py [{xxx.yyy}] refers to Javascript code for yyy in file static/js/app/x;xx.js Topics \u00b6 Elements of the page Installation on personal computers and servers Maintenance Testing","title":"Technical Home"},{"location":"#technical-home","text":"What it is, how it is designed, how it works and how it can be installed and maintained.","title":"Technical Home"},{"location":"#about","text":"SHEBANQ is a website built as an application in the Web2Py framework. It uses MySQL databases to store its dynamic data, which is generated by users, and its static data, which consists of the text of the hebrew Bible and linguistic annotations of the ETCBC . The static data is delivered via the BHSA repository, where it arrived through a pipeline ) from the source data as it sits on ETCBC servers. The specialty of SHEBANQ is that it offers users the facility to run queries against the data and to store those queries so theat they can be shared and published. The query engine for this is Emdros which sits on top of MySQL and speaks with it. Shebanq and the pipeline have been constructed using Text-Fabric as the main tool. There are several kinds of documentation of SHEBANQ, see documentation where it is decribed how to maintain that information. In order to develop effectively, we use a test framework, see testing . Quickly jump to a topic below, or use the navigation controls.","title":"About"},{"location":"#conventions","text":"","title":"Conventions"},{"location":"#code-references","text":"This documentation contains many references to all kind of things. Some references have shapes that help you recognize to what they refer: [\u2208 element] refers to a page element called element ; it links to its documentation; [M:XXX.yyy] refers to Python code for yyy in module modules/xxx.py ; [C:xxx.yyy] refers to Python controller yyy() in file controllers/xx;x.py [{xxx.yyy}] refers to Javascript code for yyy in file static/js/app/x;xx.js","title":"Code references"},{"location":"#topics","text":"Elements of the page Installation on personal computers and servers Maintenance Testing","title":"Topics"},{"location":"news/","text":"News \u00b6 2021-10-05 Big update is due. New ETCBC dataversion 2021 Migration to Python3 New versions of Emdros and Web2Py and MySQL Completely refactored codebase: all Python, Javascript and CSS code chopped up in managable chunks. Install and maintenance scripts Mkdocs framework for technical documentation Maintenance documentation written Shebanq software documentation just started See also older news","title":"News"},{"location":"news/#news","text":"2021-10-05 Big update is due. New ETCBC dataversion 2021 Migration to Python3 New versions of Emdros and Web2Py and MySQL Completely refactored codebase: all Python, Javascript and CSS code chopped up in managable chunks. Install and maintenance scripts Mkdocs framework for technical documentation Maintenance documentation written Shebanq software documentation just started See also older news","title":"News"},{"location":"client/","text":"Client \u00b6 This is the part of SHEBANQ that works in the browser. Its main parts are the CSS files Javascript files","title":"Client"},{"location":"client/#client","text":"This is the part of SHEBANQ that works in the browser. Its main parts are the CSS files Javascript files","title":"Client"},{"location":"client/css/","text":"CSS organization \u00b6 The styling of SHEBANQ is organized in a bunch of CSS files that each take care of a certain aspect of the layout.","title":"CSS organization"},{"location":"client/css/#css-organization","text":"The styling of SHEBANQ is organized in a bunch of CSS files that each take care of a certain aspect of the layout.","title":"CSS organization"},{"location":"client/js/","text":"Javascript organization \u00b6 The interaction with SHEBANQ is taken care of by a modern Javascript app. SHEBANQ uses vanilla Javascript (ES6 and higher), without any code preprocessing. The Javascript source is directly included by the HTML. We only use a few Javascript libraries: fancytree for the overview pages of notes and queries; jQuery almost everywhere. Most of the code is organized in modules under static/js/app . The modules are individually documented by jsdocstrings in the code. Entry point \u00b6 The entry point is main.js . It has the following responsibilities: Pick up a bunch of settings from the server Set up LocalStorage in the browser to remember those settings Make the settings available in an ViewState object that is globally accessible Construct a Page object Start the dynamics of the Page object Objects in general \u00b6 Most of the objects defined in the javascript app share a general way of working: Constructor \u00b6 Object constructors do simple work, and do not depend on the outcomes of asynchronous actions of other objects. So it is always safe to construct an object. Initialization \u00b6 If objects need initialization that depends on asynchronous work of other objects, it should be put in an init() method. These can be triggered by the process() methods of other objects. Fetch \u00b6 If objects need to interact with the server, they use AJAX to send/fetch data. When the response from the server has come back, a callback is executed in wich the method process() is called. Process \u00b6 Everything that needs to be done with data that has been fetched from the server, is done in this method. Things to do are typically: generate HTML out of JSON dress up the DOM with events Apply \u00b6 Whenever the ViewState changes, objects maybe affected. Objects do not listen to the state themselves. Whichever object changes the state must trigger the apply() method of affected objects.","title":"Javascript organization"},{"location":"client/js/#javascript-organization","text":"The interaction with SHEBANQ is taken care of by a modern Javascript app. SHEBANQ uses vanilla Javascript (ES6 and higher), without any code preprocessing. The Javascript source is directly included by the HTML. We only use a few Javascript libraries: fancytree for the overview pages of notes and queries; jQuery almost everywhere. Most of the code is organized in modules under static/js/app . The modules are individually documented by jsdocstrings in the code.","title":"Javascript organization"},{"location":"client/js/#entry-point","text":"The entry point is main.js . It has the following responsibilities: Pick up a bunch of settings from the server Set up LocalStorage in the browser to remember those settings Make the settings available in an ViewState object that is globally accessible Construct a Page object Start the dynamics of the Page object","title":"Entry point"},{"location":"client/js/#objects-in-general","text":"Most of the objects defined in the javascript app share a general way of working:","title":"Objects in general"},{"location":"client/js/#constructor","text":"Object constructors do simple work, and do not depend on the outcomes of asynchronous actions of other objects. So it is always safe to construct an object.","title":"Constructor"},{"location":"client/js/#initialization","text":"If objects need initialization that depends on asynchronous work of other objects, it should be put in an init() method. These can be triggered by the process() methods of other objects.","title":"Initialization"},{"location":"client/js/#fetch","text":"If objects need to interact with the server, they use AJAX to send/fetch data. When the response from the server has come back, a callback is executed in wich the method process() is called.","title":"Fetch"},{"location":"client/js/#process","text":"Everything that needs to be done with data that has been fetched from the server, is done in this method. Things to do are typically: generate HTML out of JSON dress up the DOM with events","title":"Process"},{"location":"client/js/#apply","text":"Whenever the ViewState changes, objects maybe affected. Objects do not listen to the state themselves. Whichever object changes the state must trigger the apply() method of affected objects.","title":"Apply"},{"location":"client/bymodule/","text":"About modules \u00b6 Javascript modules support the dynamic aspects of widgets on the SHEBANQ pages. Use the navigation menu to jump to the individual modules.","title":"About modules"},{"location":"client/bymodule/#about-modules","text":"Javascript modules support the dynamic aspects of widgets on the SHEBANQ pages. Use the navigation menu to jump to the individual modules.","title":"About modules"},{"location":"client/bymodule/chart/","text":"chart \u00b6 chart static .Chart .apply() .fetch() inner ~chartCols chart.Chart \u00b6 Class for chart slection and generation Kind : static class of chart See : also the server code M:CHART . .Chart .apply() .fetch() chart.apply() \u00b6 Method for chart slection and generation Kind : instance method of Chart chart.fetch() \u00b6 get the material by AJAX if needed, and process the material afterward Kind : instance method of Chart See : Triggers C:hebrew.chart chart~chartCols \u00b6 number of chapters in a row in a chart Kind : inner constant of chart","title":"Chart"},{"location":"client/bymodule/chart/#chart","text":"chart static .Chart .apply() .fetch() inner ~chartCols","title":"chart"},{"location":"client/bymodule/chart/#chartchart","text":"Class for chart slection and generation Kind : static class of chart See : also the server code M:CHART . .Chart .apply() .fetch()","title":"chart.Chart"},{"location":"client/bymodule/chart/#chartapply","text":"Method for chart slection and generation Kind : instance method of Chart","title":"chart.apply()"},{"location":"client/bymodule/chart/#chartfetch","text":"get the material by AJAX if needed, and process the material afterward Kind : instance method of Chart See : Triggers C:hebrew.chart","title":"chart.fetch()"},{"location":"client/bymodule/chart/#chartchartcols","text":"number of chapters in a row in a chart Kind : inner constant of chart","title":"chart~chartCols"},{"location":"client/bymodule/colorpicker/","text":"colorpicker \u00b6 colorpicker .ColorPicker1 .ColorPicker2 colorpicker.ColorPicker1 \u00b6 The ColorPicker associated with individual items These pickers show up in lists of items (in mq and mw sidebars) and near individual items (in rq and rw sidebars). They also have a checkbox, stating whether the color counts as customized. Customized colors are held in a global colorMap, which is saved in a cookie upon every picking action. All actions are processed by the highlight2 (!) method of the associated Settings object. Kind : static class of colorpicker See \u2208 highlight-select-single-color \u2208 highlight-select-color colorpicker.ColorPicker2 \u00b6 The ColorPicker associated with the view settings in a sidebar These pickers show up at the top of the individual sidebars, only on mq and mw sidebars. They are used to control the uniform color with which the results are to be painted. They can be configured for dealing with background or foreground painting. The paint actions depend on the mode of coloring that the user has selected in settings. So the paint logic is more involved. But there is no associated checkbox. The selected color is stored in the highlight settings, which are synchronized in a cookie. All actions are processed by the highlight2 method of the associated Settings object. Kind : static class of colorpicker See : \u2208 highlight-select-single-color","title":"Colorpicker"},{"location":"client/bymodule/colorpicker/#colorpicker","text":"colorpicker .ColorPicker1 .ColorPicker2","title":"colorpicker"},{"location":"client/bymodule/colorpicker/#colorpickercolorpicker1","text":"The ColorPicker associated with individual items These pickers show up in lists of items (in mq and mw sidebars) and near individual items (in rq and rw sidebars). They also have a checkbox, stating whether the color counts as customized. Customized colors are held in a global colorMap, which is saved in a cookie upon every picking action. All actions are processed by the highlight2 (!) method of the associated Settings object. Kind : static class of colorpicker See \u2208 highlight-select-single-color \u2208 highlight-select-color","title":"colorpicker.ColorPicker1"},{"location":"client/bymodule/colorpicker/#colorpickercolorpicker2","text":"The ColorPicker associated with the view settings in a sidebar These pickers show up at the top of the individual sidebars, only on mq and mw sidebars. They are used to control the uniform color with which the results are to be painted. They can be configured for dealing with background or foreground painting. The paint actions depend on the mode of coloring that the user has selected in settings. So the paint logic is more involved. But there is no associated checkbox. The selected color is stored in the highlight settings, which are synchronized in a cookie. All actions are processed by the highlight2 method of the associated Settings object. Kind : static class of colorpicker See : \u2208 highlight-select-single-color","title":"colorpicker.ColorPicker2"},{"location":"client/bymodule/diagnostics/","text":"diagnostics \u00b6 diagnostics.Diagnostics \u00b6 Handles diagnostic messages on the HTML page. When something goes wrong, messages can be displayed in divs. There will also be a control to clear those messages. Kind : static class of diagnostics","title":"Diagnostics"},{"location":"client/bymodule/diagnostics/#diagnostics","text":"","title":"diagnostics"},{"location":"client/bymodule/diagnostics/#diagnosticsdiagnostics","text":"Handles diagnostic messages on the HTML page. When something goes wrong, messages can be displayed in divs. There will also be a control to clear those messages. Kind : static class of diagnostics","title":"diagnostics.Diagnostics"},{"location":"client/bymodule/featuresettings/","text":"featuresettings \u00b6 featuresettings~FeatureSetting \u00b6 Handles the display a single lingusitic feature. Kind : inner class of featuresettings","title":"Featuresettings"},{"location":"client/bymodule/featuresettings/#featuresettings","text":"","title":"featuresettings"},{"location":"client/bymodule/featuresettings/#featuresettingsfeaturesetting","text":"Handles the display a single lingusitic feature. Kind : inner class of featuresettings","title":"featuresettings~FeatureSetting"},{"location":"client/bymodule/helpers/","text":"helpers \u00b6 helpers static .escHT .putMarkdown .toggleDetail .specialLinks .colorDefault .closeDialog inner ~mEscape() helpers.escHT \u00b6 Escape the & < > in strings that must be rendered as HTML. Kind : static constant of helpers helpers.putMarkdown \u00b6 Display markdown The markdown is formatted as HTML, where shebanq-specific links are resolved into working hyperlinks. Kind : static constant of helpers Param Description wdg A div in the HTML This div has a subdiv with the source markdown in it and a destination div which gets the result of the conversion helpers.toggleDetail \u00b6 Hide and expand material Kind : static constant of helpers helpers.specialLinks \u00b6 Resolve shebanq-specific links into working hyperlinks Kind : static constant of helpers helpers.colorDefault \u00b6 Computes the default color The data for the computation comes from the server and is stored in the javascript global variable Config colorsDefault, nDefaultClrCols, nDefaultClrRows Kind : static constant of helpers helpers.closeDialog \u00b6 Close a dialog box Kind : static constant of helpers helpers~mEscape() \u00b6 Escape the _ character in strings that must be rendered as markdown. Kind : inner method of helpers","title":"Helpers"},{"location":"client/bymodule/helpers/#helpers","text":"helpers static .escHT .putMarkdown .toggleDetail .specialLinks .colorDefault .closeDialog inner ~mEscape()","title":"helpers"},{"location":"client/bymodule/helpers/#helpersescht","text":"Escape the & < > in strings that must be rendered as HTML. Kind : static constant of helpers","title":"helpers.escHT"},{"location":"client/bymodule/helpers/#helpersputmarkdown","text":"Display markdown The markdown is formatted as HTML, where shebanq-specific links are resolved into working hyperlinks. Kind : static constant of helpers Param Description wdg A div in the HTML This div has a subdiv with the source markdown in it and a destination div which gets the result of the conversion","title":"helpers.putMarkdown"},{"location":"client/bymodule/helpers/#helperstoggledetail","text":"Hide and expand material Kind : static constant of helpers","title":"helpers.toggleDetail"},{"location":"client/bymodule/helpers/#helpersspeciallinks","text":"Resolve shebanq-specific links into working hyperlinks Kind : static constant of helpers","title":"helpers.specialLinks"},{"location":"client/bymodule/helpers/#helperscolordefault","text":"Computes the default color The data for the computation comes from the server and is stored in the javascript global variable Config colorsDefault, nDefaultClrCols, nDefaultClrRows Kind : static constant of helpers","title":"helpers.colorDefault"},{"location":"client/bymodule/helpers/#helpersclosedialog","text":"Close a dialog box Kind : static constant of helpers","title":"helpers.closeDialog"},{"location":"client/bymodule/helpers/#helpersmescape","text":"Escape the _ character in strings that must be rendered as markdown. Kind : inner method of helpers","title":"helpers~mEscape()"},{"location":"client/bymodule/localstorage/","text":"localstorage \u00b6 localstorage.LStorage \u00b6 Set up sections of local storage for several kinds of settings: notes settings, and which notes are muted queries settings, and which queries are muted Kind : static class of localstorage","title":"Localstorage"},{"location":"client/bymodule/localstorage/#localstorage","text":"","title":"localstorage"},{"location":"client/bymodule/localstorage/#localstoragelstorage","text":"Set up sections of local storage for several kinds of settings: notes settings, and which notes are muted queries settings, and which queries are muted Kind : static class of localstorage","title":"localstorage.LStorage"},{"location":"client/bymodule/main/","text":"main \u00b6","title":"Main"},{"location":"client/bymodule/main/#main","text":"","title":"main"},{"location":"client/bymodule/material/","text":"material \u00b6 material .Material .fetch() .addVerseRefs() material.Material \u00b6 Controls the main area of the page. Kind : static class of material See M:MATERIAL page elements: \u2208 book , \u2208 chapter , \u2208 page , \u2208 goto-chapter , .Material .fetch() .addVerseRefs() material.fetch() \u00b6 get the material by AJAX if needed, and process the material afterward Kind : instance method of Material See : Triggers C:hebrew.material material.addVerseRefs() \u00b6 add a click event to the verse number by which linguistic features for the words in that verse can be retrieved from the server. Kind : instance method of Material See Triggers C:hebrew.verse . \u2208 show-verse-data","title":"Material"},{"location":"client/bymodule/material/#material","text":"material .Material .fetch() .addVerseRefs()","title":"material"},{"location":"client/bymodule/material/#materialmaterial","text":"Controls the main area of the page. Kind : static class of material See M:MATERIAL page elements: \u2208 book , \u2208 chapter , \u2208 page , \u2208 goto-chapter , .Material .fetch() .addVerseRefs()","title":"material.Material"},{"location":"client/bymodule/material/#materialfetch","text":"get the material by AJAX if needed, and process the material afterward Kind : instance method of Material See : Triggers C:hebrew.material","title":"material.fetch()"},{"location":"client/bymodule/material/#materialaddverserefs","text":"add a click event to the verse number by which linguistic features for the words in that verse can be retrieved from the server. Kind : instance method of Material See Triggers C:hebrew.verse . \u2208 show-verse-data","title":"material.addVerseRefs()"},{"location":"client/bymodule/materialcontent/","text":"materialcontent \u00b6 materialcontent.MaterialContent \u00b6 Deals with the actual Hebrew content. It provides a name for material, such as the name of the query of which the material is a result verse list. It can cycle through the Hebrew and phonetic representations of the material. Kind : static class of materialcontent","title":"Materialcontent"},{"location":"client/bymodule/materialcontent/#materialcontent","text":"","title":"materialcontent"},{"location":"client/bymodule/materialcontent/#materialcontentmaterialcontent","text":"Deals with the actual Hebrew content. It provides a name for material, such as the name of the query of which the material is a result verse list. It can cycle through the Hebrew and phonetic representations of the material. Kind : static class of materialcontent","title":"materialcontent.MaterialContent"},{"location":"client/bymodule/materialsettings/","text":"materialsettings \u00b6 materialsettings.MaterialSettings \u00b6 MATERIAL SETTINGS (for choosing between plain text and tabbed data, etc) \u2208 text-presentation \u2208 text-representation \u2208 feature-legend Kind : static class of materialsettings","title":"Materialsettings"},{"location":"client/bymodule/materialsettings/#materialsettings","text":"","title":"materialsettings"},{"location":"client/bymodule/materialsettings/#materialsettingsmaterialsettings","text":"MATERIAL SETTINGS (for choosing between plain text and tabbed data, etc) \u2208 text-presentation \u2208 text-representation \u2208 feature-legend Kind : static class of materialsettings","title":"materialsettings.MaterialSettings"},{"location":"client/bymodule/message/","text":"message \u00b6 message.Message \u00b6 Diagnostic output Kind : static class of message","title":"Message"},{"location":"client/bymodule/message/#message","text":"","title":"message"},{"location":"client/bymodule/message/#messagemessage","text":"Diagnostic output Kind : static class of message","title":"message.Message"},{"location":"client/bymodule/notes/","text":"notes \u00b6 notes static .Notes inner ~NoteVerse .fetch() .sendnotes() notes.Notes \u00b6 Controls notes on text pages Kind : static class of notes See : [notetree] for the notes overview page. notes~NoteVerse \u00b6 Controls the notes belonging to a single verse. Kind : inner class of notes ~NoteVerse .fetch() .sendnotes() noteVerse.fetch() \u00b6 get the notes belonging to the current verse. Kind : instance method of NoteVerse See : Triggers C:hebrew.getversenotes noteVerse.sendnotes() \u00b6 sends edited notes to the server in order to be saved. Kind : instance method of NoteVerse See : Triggers C:hebrew.putversenotes","title":"Notes"},{"location":"client/bymodule/notes/#notes","text":"notes static .Notes inner ~NoteVerse .fetch() .sendnotes()","title":"notes"},{"location":"client/bymodule/notes/#notesnotes","text":"Controls notes on text pages Kind : static class of notes See : [notetree] for the notes overview page.","title":"notes.Notes"},{"location":"client/bymodule/notes/#notesnoteverse","text":"Controls the notes belonging to a single verse. Kind : inner class of notes ~NoteVerse .fetch() .sendnotes()","title":"notes~NoteVerse"},{"location":"client/bymodule/notes/#noteversefetch","text":"get the notes belonging to the current verse. Kind : instance method of NoteVerse See : Triggers C:hebrew.getversenotes","title":"noteVerse.fetch()"},{"location":"client/bymodule/notes/#noteversesendnotes","text":"sends edited notes to the server in order to be saved. Kind : instance method of NoteVerse See : Triggers C:hebrew.putversenotes","title":"noteVerse.sendnotes()"},{"location":"client/bymodule/notetree/","text":"notetree \u00b6 notetree ~View ~Level ~Filter ~Tree new Tree() ~Upload .submit() ~subtractForNotesPage notetree~View \u00b6 Advanced or simple view of the tree of notes. In advanced views there are more sophisticated counts. Kind : inner class of notetree notetree~Level \u00b6 The tree can be shown at different levels: user noteset Kind : inner class of notetree notetree~Filter \u00b6 The tree can be filtered. This is a full text search on the texts of the nodes. Kind : inner class of notetree notetree~Tree \u00b6 Handles the tree of note sets Kind : inner class of notetree See : Triggers C:hebrew.notetree new Tree() \u00b6 Initializes the notes tree Stores a url to fetch content from the server. notetree~Upload \u00b6 Controls the bulk-uploading of notes Kind : inner class of notetree upload.submit() \u00b6 Submits a csv file with notes to the server Kind : instance method of Upload See : Triggers C:hebrew.noteupload . notetree~subtractForNotesPage \u00b6 the canvas holding the material gets a height equal to the window height minus this amount Kind : inner constant of notetree","title":"Notetree"},{"location":"client/bymodule/notetree/#notetree","text":"notetree ~View ~Level ~Filter ~Tree new Tree() ~Upload .submit() ~subtractForNotesPage","title":"notetree"},{"location":"client/bymodule/notetree/#notetreeview","text":"Advanced or simple view of the tree of notes. In advanced views there are more sophisticated counts. Kind : inner class of notetree","title":"notetree~View"},{"location":"client/bymodule/notetree/#notetreelevel","text":"The tree can be shown at different levels: user noteset Kind : inner class of notetree","title":"notetree~Level"},{"location":"client/bymodule/notetree/#notetreefilter","text":"The tree can be filtered. This is a full text search on the texts of the nodes. Kind : inner class of notetree","title":"notetree~Filter"},{"location":"client/bymodule/notetree/#notetreetree","text":"Handles the tree of note sets Kind : inner class of notetree See : Triggers C:hebrew.notetree","title":"notetree~Tree"},{"location":"client/bymodule/notetree/#new-tree","text":"Initializes the notes tree Stores a url to fetch content from the server.","title":"new Tree()"},{"location":"client/bymodule/notetree/#notetreeupload","text":"Controls the bulk-uploading of notes Kind : inner class of notetree","title":"notetree~Upload"},{"location":"client/bymodule/notetree/#uploadsubmit","text":"Submits a csv file with notes to the server Kind : instance method of Upload See : Triggers C:hebrew.noteupload .","title":"upload.submit()"},{"location":"client/bymodule/notetree/#notetreesubtractfornotespage","text":"the canvas holding the material gets a height equal to the window height minus this amount Kind : inner constant of notetree","title":"notetree~subtractForNotesPage"},{"location":"client/bymodule/page/","text":"page \u00b6 page.Page \u00b6 The one and only page object This object manages the skeleton of the page, and acts as a director of the updates that are needed when the user is navigating from main pages to record pages. It only gives top-level commands to the objects that handle individual parts of the pages. Kind : static class of page","title":"Page"},{"location":"client/bymodule/page/#page","text":"","title":"page"},{"location":"client/bymodule/page/#pagepage","text":"The one and only page object This object manages the skeleton of the page, and acts as a director of the updates that are needed when the user is navigating from main pages to record pages. It only gives top-level commands to the objects that handle individual parts of the pages. Kind : static class of page","title":"page.Page"},{"location":"client/bymodule/queryrecent/","text":"queryrecent \u00b6 queryrecent .QueryRecent .fetch() queryrecent.QueryRecent \u00b6 Controls the widget for recent queries on the query overview page. Kind : static class of queryrecent queryRecent.fetch() \u00b6 get the material by AJAX if needed, and process the material afterward Kind : instance method of QueryRecent See : Triggers C:hebrew.queriesr","title":"Queryrecent"},{"location":"client/bymodule/queryrecent/#queryrecent","text":"queryrecent .QueryRecent .fetch()","title":"queryrecent"},{"location":"client/bymodule/queryrecent/#queryrecentqueryrecent","text":"Controls the widget for recent queries on the query overview page. Kind : static class of queryrecent","title":"queryrecent.QueryRecent"},{"location":"client/bymodule/queryrecent/#queryrecentfetch","text":"get the material by AJAX if needed, and process the material afterward Kind : instance method of QueryRecent See : Triggers C:hebrew.queriesr","title":"queryRecent.fetch()"},{"location":"client/bymodule/querytree/","text":"querytree \u00b6 querytree ~View ~Level ~Filter ~Tree new Tree() .record() ~subtractForQueriesPage ~controlHeight querytree~View \u00b6 Advanced or simple view of the tree of queries. In advanced views there are more sophisticated counts. Kind : inner class of querytree querytree~Level \u00b6 The tree can be shown at different levels: organization project user query Kind : inner class of querytree querytree~Filter \u00b6 The tree can be filtered. This is a full text search on the texts of the nodes. Kind : inner class of querytree querytree~Tree \u00b6 Handles the tree of queries Kind : inner class of querytree See : Triggers C:hebrew.querytree ~Tree new Tree() .record() new Tree() \u00b6 Initializes the query tree Stores a url to fetch content from the server. tree.record() \u00b6 Sends a record to the database to be saved Kind : instance method of Tree See : Triggers C:hebrew.itemrecord querytree~subtractForQueriesPage \u00b6 the canvas holding the material gets a height equal to the window height minus this amount Kind : inner constant of querytree querytree~controlHeight \u00b6 height for messages and controls Kind : inner constant of querytree","title":"Querytree"},{"location":"client/bymodule/querytree/#querytree","text":"querytree ~View ~Level ~Filter ~Tree new Tree() .record() ~subtractForQueriesPage ~controlHeight","title":"querytree"},{"location":"client/bymodule/querytree/#querytreeview","text":"Advanced or simple view of the tree of queries. In advanced views there are more sophisticated counts. Kind : inner class of querytree","title":"querytree~View"},{"location":"client/bymodule/querytree/#querytreelevel","text":"The tree can be shown at different levels: organization project user query Kind : inner class of querytree","title":"querytree~Level"},{"location":"client/bymodule/querytree/#querytreefilter","text":"The tree can be filtered. This is a full text search on the texts of the nodes. Kind : inner class of querytree","title":"querytree~Filter"},{"location":"client/bymodule/querytree/#querytreetree","text":"Handles the tree of queries Kind : inner class of querytree See : Triggers C:hebrew.querytree ~Tree new Tree() .record()","title":"querytree~Tree"},{"location":"client/bymodule/querytree/#new-tree","text":"Initializes the query tree Stores a url to fetch content from the server.","title":"new Tree()"},{"location":"client/bymodule/querytree/#treerecord","text":"Sends a record to the database to be saved Kind : instance method of Tree See : Triggers C:hebrew.itemrecord","title":"tree.record()"},{"location":"client/bymodule/querytree/#querytreesubtractforqueriespage","text":"the canvas holding the material gets a height equal to the window height minus this amount Kind : inner constant of querytree","title":"querytree~subtractForQueriesPage"},{"location":"client/bymodule/querytree/#querytreecontrolheight","text":"height for messages and controls Kind : inner constant of querytree","title":"querytree~controlHeight"},{"location":"client/bymodule/select/","text":"select \u00b6 select static .SelectPassage .apply() .selectVersion() .SelectResultPage .SelectLanguage inner ~SelectBook ~SelectItems select.SelectPassage \u00b6 Handles book and chapter selection Kind : static class of select .SelectPassage .apply() .selectVersion() selectPassage.apply() \u00b6 apply current passage selection New material is fetched from the current data version; The link to the feature documentation is adapted the data version. Caution But currently the docs are no longer dependent on the data version. The links to other applications are adapted to the new passage selection: bol = Bible Online Learner pbl = ParaBible Kind : instance method of SelectPassage See : Page elements: \u2208 info \u2208 version \u2208 links selectPassage.selectVersion() \u00b6 Switch to another version of the ETCBC data, such as 4b or 2021 \u2208 version Kind : instance method of SelectPassage select.SelectResultPage \u00b6 Handles selection of a result page Kind : static class of select select.SelectLanguage \u00b6 Handles selection of the language in which the names of bible books are presented. Kind : static class of select See M:blang . \u2208 language . select~SelectBook \u00b6 Handles book selection Kind : inner class of select See : \u2208 book select~SelectItems \u00b6 Handles selection of chapters and result pages. Kind : inner class of select See : \u2208 chapter , \u2208 page","title":"Select"},{"location":"client/bymodule/select/#select","text":"select static .SelectPassage .apply() .selectVersion() .SelectResultPage .SelectLanguage inner ~SelectBook ~SelectItems","title":"select"},{"location":"client/bymodule/select/#selectselectpassage","text":"Handles book and chapter selection Kind : static class of select .SelectPassage .apply() .selectVersion()","title":"select.SelectPassage"},{"location":"client/bymodule/select/#selectpassageapply","text":"apply current passage selection New material is fetched from the current data version; The link to the feature documentation is adapted the data version. Caution But currently the docs are no longer dependent on the data version. The links to other applications are adapted to the new passage selection: bol = Bible Online Learner pbl = ParaBible Kind : instance method of SelectPassage See : Page elements: \u2208 info \u2208 version \u2208 links","title":"selectPassage.apply()"},{"location":"client/bymodule/select/#selectpassageselectversion","text":"Switch to another version of the ETCBC data, such as 4b or 2021 \u2208 version Kind : instance method of SelectPassage","title":"selectPassage.selectVersion()"},{"location":"client/bymodule/select/#selectselectresultpage","text":"Handles selection of a result page Kind : static class of select","title":"select.SelectResultPage"},{"location":"client/bymodule/select/#selectselectlanguage","text":"Handles selection of the language in which the names of bible books are presented. Kind : static class of select See M:blang . \u2208 language .","title":"select.SelectLanguage"},{"location":"client/bymodule/select/#selectselectbook","text":"Handles book selection Kind : inner class of select See : \u2208 book","title":"select~SelectBook"},{"location":"client/bymodule/select/#selectselectitems","text":"Handles selection of chapters and result pages. Kind : inner class of select See : \u2208 chapter , \u2208 page","title":"select~SelectItems"},{"location":"client/bymodule/share/","text":"<a name=\"share Provides stable urls for citing words, queries, note sets.module_\"> share \u00b6 Provides stable urls for citing words, queries, note sets. See : \u2208 cite-slider","title":"Share"},{"location":"client/bymodule/share/#share","text":"Provides stable urls for citing words, queries, note sets. See : \u2208 cite-slider","title":"share"},{"location":"client/bymodule/sidebars/","text":"sidebars \u00b6 sidebars static .Sidebars inner ~Sidebar sidebars.Sidebars \u00b6 Handles the sidebars. Any kind is handled. But it only manages the administration of whether content has been fetched for the sidebar. All things that depend on the kind of sidebar are delegated to the {sidebar} object. Kind : static class of sidebars sidebars~Sidebar \u00b6 Handles specific sidebars. The mr and qw types are frozen into the object Kind : inner class of sidebars","title":"Sidebars"},{"location":"client/bymodule/sidebars/#sidebars","text":"sidebars static .Sidebars inner ~Sidebar","title":"sidebars"},{"location":"client/bymodule/sidebars/#sidebarssidebars","text":"Handles the sidebars. Any kind is handled. But it only manages the administration of whether content has been fetched for the sidebar. All things that depend on the kind of sidebar are delegated to the {sidebar} object. Kind : static class of sidebars","title":"sidebars.Sidebars"},{"location":"client/bymodule/sidebars/#sidebarssidebar","text":"Handles specific sidebars. The mr and qw types are frozen into the object Kind : inner class of sidebars","title":"sidebars~Sidebar"},{"location":"client/bymodule/sidecontent/","text":"sidecontent \u00b6 sidecontent .SideContent .sendVal() .sendVals() .fetch() sidecontent.SideContent \u00b6 Controls the content of a side bar Kind : static class of sidecontent .SideContent .sendVal() .sendVals() .fetch() sideContent.sendVal() \u00b6 Updates a single field of a query. Meant for is_shared and is_published . Note is_shared is a field of a query record. is_published is a field of a query_exe record. Kind : instance method of SideContent See : Triggers C:hebrew.querysharing . sideContent.sendVals() \u00b6 Sends un updated record to the database. Kind : instance method of SideContent See : Triggers C:hebrew.queryupdate . sideContent.fetch() \u00b6 get the material by AJAX if needed, and process the material afterward This method takes into account what kind of sidebar this is: Kind : instance method of SideContent See Triggers C:hebrew.sidematerial Triggers C:hebrew.sideword Triggers C:hebrew.sidequery Triggers C:hebrew.sidenote","title":"Sidecontent"},{"location":"client/bymodule/sidecontent/#sidecontent","text":"sidecontent .SideContent .sendVal() .sendVals() .fetch()","title":"sidecontent"},{"location":"client/bymodule/sidecontent/#sidecontentsidecontent","text":"Controls the content of a side bar Kind : static class of sidecontent .SideContent .sendVal() .sendVals() .fetch()","title":"sidecontent.SideContent"},{"location":"client/bymodule/sidecontent/#sidecontentsendval","text":"Updates a single field of a query. Meant for is_shared and is_published . Note is_shared is a field of a query record. is_published is a field of a query_exe record. Kind : instance method of SideContent See : Triggers C:hebrew.querysharing .","title":"sideContent.sendVal()"},{"location":"client/bymodule/sidecontent/#sidecontentsendvals","text":"Sends un updated record to the database. Kind : instance method of SideContent See : Triggers C:hebrew.queryupdate .","title":"sideContent.sendVals()"},{"location":"client/bymodule/sidecontent/#sidecontentfetch","text":"get the material by AJAX if needed, and process the material afterward This method takes into account what kind of sidebar this is: Kind : instance method of SideContent See Triggers C:hebrew.sidematerial Triggers C:hebrew.sideword Triggers C:hebrew.sidequery Triggers C:hebrew.sidenote","title":"sideContent.fetch()"},{"location":"client/bymodule/sidesettings/","text":"sidesettings \u00b6 sidesettings.SideSettings \u00b6 Handles the view controls belonging to a side bar with a list of items Kind : static class of sidesettings See [M:viewdefs.Make] Page elements: \u2208 highlight-published \u2208 highlight-reset \u2208 highlight-many \u2208 highlight-custom \u2208 highlight-one \u2208 highlight-off \u2208 highlight-select-single-color","title":"Sidesettings"},{"location":"client/bymodule/sidesettings/#sidesettings","text":"","title":"sidesettings"},{"location":"client/bymodule/sidesettings/#sidesettingssidesettings","text":"Handles the view controls belonging to a side bar with a list of items Kind : static class of sidesettings See [M:viewdefs.Make] Page elements: \u2208 highlight-published \u2208 highlight-reset \u2208 highlight-many \u2208 highlight-custom \u2208 highlight-one \u2208 highlight-off \u2208 highlight-select-single-color","title":"sidesettings.SideSettings"},{"location":"client/bymodule/viewstate/","text":"viewstate \u00b6 viewstate .ViewState .csvUrl() viewstate.ViewState \u00b6 Handles settings that cusomise the view of the page Kind : static class of viewstate See : Corresponds to M:VIEWSETTINGS.page . viewState.csvUrl() \u00b6 Sets the precise url by which the user can request a csv download from the server. Kind : instance method of ViewState See : Triggers C:hebrew.item .","title":"Viewstate"},{"location":"client/bymodule/viewstate/#viewstate","text":"viewstate .ViewState .csvUrl()","title":"viewstate"},{"location":"client/bymodule/viewstate/#viewstateviewstate","text":"Handles settings that cusomise the view of the page Kind : static class of viewstate See : Corresponds to M:VIEWSETTINGS.page .","title":"viewstate.ViewState"},{"location":"client/bymodule/viewstate/#viewstatecsvurl","text":"Sets the precise url by which the user can request a csv download from the server. Kind : instance method of ViewState See : Triggers C:hebrew.item .","title":"viewState.csvUrl()"},{"location":"client/bymodule/words/","text":"words \u00b6 words ~View .selectVersion() words~View \u00b6 Handles a words overview page Kind : inner class of words view.selectVersion() \u00b6 Switch to another version Kind : instance method of View See : \u2208 version","title":"Words"},{"location":"client/bymodule/words/#words","text":"words ~View .selectVersion()","title":"words"},{"location":"client/bymodule/words/#wordsview","text":"Handles a words overview page Kind : inner class of words","title":"words~View"},{"location":"client/bymodule/words/#viewselectversion","text":"Switch to another version Kind : instance method of View See : \u2208 version","title":"view.selectVersion()"},{"location":"deploy/computer/","text":"Computer \u00b6 This article describes the installation of SHEBANQ on your computer. This guide is written for macos computers! Linux The macos system offers a unix system under the hood, which is much like linux . Certain elements of the installation are the same under macos , linux PC, and linux server. Windows Although everything that SHEBANQ depends on also runs on Windows, I have never taken the trouble to put the whole process together in a guide, hindered as I am by not having a Windos computer. Especially the step of compiling Emdros might be a serious thing to get going. In the context of your own computer some things will be simpler than on a server. Your computer will serve SHEBANQ in your own browser, not over the internet. Motivation \u00b6 When developing SHEBANQ, the best way to inspect what happens behind the screens is to have it running on your local computer. So it is an integral part of the maintainability of SHEBANQ that you can install it locally. Preparation and information \u00b6 Before the actual installation of SHEBANQ, we need several software components. We describe what they are and what you have to do first. After that we point you to a script that completes the installation. Computer and operating system \u00b6 You have a modern Mac, running Catalina or higher. Commandline tools \u00b6 The key asset is the command-line, and on macos that is offered by the Terminal app. If you are not familiar with that, here is some reading . However, you will be doing deep system things, such as compiling software. For that, you need to boost your command-line by tools provided by Apple. It is easy but not obvious how to get those commandline tools on your computer. Here is a guide . Even here several options are given. From all those options, choose the following: From a command prompt Open the Terminal app on your mac. Give the following command: git This is an advance command, and it will trigger a prompt offering you to download and istall the commandline tools. Do it! It may take 5-10 minutes. After this, you have commands to interact with GitHub, to compile software, etc. Homebrew \u00b6 We need a package manager for macos, in order to install a mysql client later on. Install Homebrew by following the instructions on its home page and then do brew install mysql-client Python \u00b6 You need Python installed, at least 3.6.3. Preferably from python.org . After that, install the markdown module: pip3 install markdown Database \u00b6 We need the MySQL database system. We are very particular about the details of installing and configuring MySQL here. No previous MySQL on your Mac Preferably you do not have already MySQL installed. If you already have MySQL on your computer, backup your databases and remove it. After the install procedure for MySQL, you can import these backups into the new MySQL system. There are several ways to get MySQL, but only one of them works with Emdros , as I found out the hard way! You need to download the community edition . Take care to pick the download that matches the architecture of your mac ( arm64 for the newer macs, x86_64 for the usual Intel macs). and install it in the macos way (clicking on the package in your downloads folder and following instructions). Do not customise anything! And leave the root password empty. The installation process is described here , and it shows where you can control your databases. Shebanq repository \u00b6 The installation script is in the Shebanq repository, so you have to clone the repo first. We assume you do that under a directory github in your home folder. If you do not want that, you can do it somewhere else, but then you have to tweak a setting in a configuration script later. mkdir -p ~/github/etcbc cd ~/github/etcbc git clone https://github.com/etcbc/shebanq cd shebanq/scripts/computer Now we can do work. Finish MySQL configuration \u00b6 In a terminal, do this (still in the same directory as above): ./mysql.sh Then restart the terminal. Then restart the MySQL (via its preference pane in System Preferences). Now your database is fully functional for the purposes of SHEBANQ. Components \u00b6 Before you run the installation script, here is some information about what gets installed. Emdros \u00b6 Emdros is the software that makes the MQL queries possible which are so typical for SHEBANQ. It sits in the middle of your MQL queries and the MySQL database. The software is already packaged in the SHEBANQ repo. The install script will take it out, unpack it, and compile it, a lengthy process. Dynamic data \u00b6 Dynamic data is the data that is accumulated in the database of the website as a consequence of the actions of the users. Think of the user accounts and the saved queries and notes. For the local install of SHEBANQ we start fill the relevant databases with empty data. Static data \u00b6 Static data is the frozen data offered by the ETCBC: the text and linguistic features of the Hebrew Bible in several versions. That data is in the BHSA repository that we clone, and will be imported from there, a lengthy process. Web2py \u00b6 Our web framework is web2py , a Python based system to build web applications. We install it from GitHub, and after that we plug SHEBANQ into it. Web2Py comes with its own local webserver, so we do not have to set up complicated webservers such as Apache. Instead, we can rely on the built-in webserver that comes with Web2py . Run install script \u00b6 In a terminal, do this): cd ~/github/etcbc/shebanq/scripts/computer ./installmacos.sh At the end, the SHEBANQ web server will be started and a first visit to the local SHEBANQ website will be made. Starting and stopping SHEBANQ \u00b6 You stop SHEBANQ by pressing Ctrl + C in the terminal from where you started SHEBANQ. You start SHEBANQ by double-clicking on the file shebanq.command in your home folder, under Applications/SHEBANQ . not the system-wide applications folder Go to your home folder and find an applications folder in it. That is the one that contains SHEBANQ and there you find shebanq.command . shortcut You can drag this file into the side bar of the Finder. That way you have an easy shortcut to the shebanq webapp. Debugging \u00b6 When you browse shebanq, you might see messages in the terminal window, and when you change the Python code in SHEBANQ and add statements that print messages, they will show up here. Updating \u00b6 You can update SHEBANQ by doing this in a terminal cd ~/Applications/SHEBANQ ./update.sh Selective installation \u00b6 You can install individual pieces. View the options of the install script. cd ~/github/etcbc/shebanq/scripts/computer ./installmacos --help","title":"Computer"},{"location":"deploy/computer/#computer","text":"This article describes the installation of SHEBANQ on your computer. This guide is written for macos computers! Linux The macos system offers a unix system under the hood, which is much like linux . Certain elements of the installation are the same under macos , linux PC, and linux server. Windows Although everything that SHEBANQ depends on also runs on Windows, I have never taken the trouble to put the whole process together in a guide, hindered as I am by not having a Windos computer. Especially the step of compiling Emdros might be a serious thing to get going. In the context of your own computer some things will be simpler than on a server. Your computer will serve SHEBANQ in your own browser, not over the internet.","title":"Computer"},{"location":"deploy/computer/#motivation","text":"When developing SHEBANQ, the best way to inspect what happens behind the screens is to have it running on your local computer. So it is an integral part of the maintainability of SHEBANQ that you can install it locally.","title":"Motivation"},{"location":"deploy/computer/#preparation-and-information","text":"Before the actual installation of SHEBANQ, we need several software components. We describe what they are and what you have to do first. After that we point you to a script that completes the installation.","title":"Preparation and information"},{"location":"deploy/computer/#computer-and-operating-system","text":"You have a modern Mac, running Catalina or higher.","title":"Computer and operating system"},{"location":"deploy/computer/#commandline-tools","text":"The key asset is the command-line, and on macos that is offered by the Terminal app. If you are not familiar with that, here is some reading . However, you will be doing deep system things, such as compiling software. For that, you need to boost your command-line by tools provided by Apple. It is easy but not obvious how to get those commandline tools on your computer. Here is a guide . Even here several options are given. From all those options, choose the following: From a command prompt Open the Terminal app on your mac. Give the following command: git This is an advance command, and it will trigger a prompt offering you to download and istall the commandline tools. Do it! It may take 5-10 minutes. After this, you have commands to interact with GitHub, to compile software, etc.","title":"Commandline tools"},{"location":"deploy/computer/#homebrew","text":"We need a package manager for macos, in order to install a mysql client later on. Install Homebrew by following the instructions on its home page and then do brew install mysql-client","title":"Homebrew"},{"location":"deploy/computer/#python","text":"You need Python installed, at least 3.6.3. Preferably from python.org . After that, install the markdown module: pip3 install markdown","title":"Python"},{"location":"deploy/computer/#database","text":"We need the MySQL database system. We are very particular about the details of installing and configuring MySQL here. No previous MySQL on your Mac Preferably you do not have already MySQL installed. If you already have MySQL on your computer, backup your databases and remove it. After the install procedure for MySQL, you can import these backups into the new MySQL system. There are several ways to get MySQL, but only one of them works with Emdros , as I found out the hard way! You need to download the community edition . Take care to pick the download that matches the architecture of your mac ( arm64 for the newer macs, x86_64 for the usual Intel macs). and install it in the macos way (clicking on the package in your downloads folder and following instructions). Do not customise anything! And leave the root password empty. The installation process is described here , and it shows where you can control your databases.","title":"Database"},{"location":"deploy/computer/#shebanq-repository","text":"The installation script is in the Shebanq repository, so you have to clone the repo first. We assume you do that under a directory github in your home folder. If you do not want that, you can do it somewhere else, but then you have to tweak a setting in a configuration script later. mkdir -p ~/github/etcbc cd ~/github/etcbc git clone https://github.com/etcbc/shebanq cd shebanq/scripts/computer Now we can do work.","title":"Shebanq repository"},{"location":"deploy/computer/#finish-mysql-configuration","text":"In a terminal, do this (still in the same directory as above): ./mysql.sh Then restart the terminal. Then restart the MySQL (via its preference pane in System Preferences). Now your database is fully functional for the purposes of SHEBANQ.","title":"Finish MySQL configuration"},{"location":"deploy/computer/#components","text":"Before you run the installation script, here is some information about what gets installed.","title":"Components"},{"location":"deploy/computer/#emdros","text":"Emdros is the software that makes the MQL queries possible which are so typical for SHEBANQ. It sits in the middle of your MQL queries and the MySQL database. The software is already packaged in the SHEBANQ repo. The install script will take it out, unpack it, and compile it, a lengthy process.","title":"Emdros"},{"location":"deploy/computer/#dynamic-data","text":"Dynamic data is the data that is accumulated in the database of the website as a consequence of the actions of the users. Think of the user accounts and the saved queries and notes. For the local install of SHEBANQ we start fill the relevant databases with empty data.","title":"Dynamic data"},{"location":"deploy/computer/#static-data","text":"Static data is the frozen data offered by the ETCBC: the text and linguistic features of the Hebrew Bible in several versions. That data is in the BHSA repository that we clone, and will be imported from there, a lengthy process.","title":"Static data"},{"location":"deploy/computer/#web2py","text":"Our web framework is web2py , a Python based system to build web applications. We install it from GitHub, and after that we plug SHEBANQ into it. Web2Py comes with its own local webserver, so we do not have to set up complicated webservers such as Apache. Instead, we can rely on the built-in webserver that comes with Web2py .","title":"Web2py"},{"location":"deploy/computer/#run-install-script","text":"In a terminal, do this): cd ~/github/etcbc/shebanq/scripts/computer ./installmacos.sh At the end, the SHEBANQ web server will be started and a first visit to the local SHEBANQ website will be made.","title":"Run install script"},{"location":"deploy/computer/#starting-and-stopping-shebanq","text":"You stop SHEBANQ by pressing Ctrl + C in the terminal from where you started SHEBANQ. You start SHEBANQ by double-clicking on the file shebanq.command in your home folder, under Applications/SHEBANQ . not the system-wide applications folder Go to your home folder and find an applications folder in it. That is the one that contains SHEBANQ and there you find shebanq.command . shortcut You can drag this file into the side bar of the Finder. That way you have an easy shortcut to the shebanq webapp.","title":"Starting and stopping SHEBANQ"},{"location":"deploy/computer/#debugging","text":"When you browse shebanq, you might see messages in the terminal window, and when you change the Python code in SHEBANQ and add statements that print messages, they will show up here.","title":"Debugging"},{"location":"deploy/computer/#updating","text":"You can update SHEBANQ by doing this in a terminal cd ~/Applications/SHEBANQ ./update.sh","title":"Updating"},{"location":"deploy/computer/#selective-installation","text":"You can install individual pieces. View the options of the install script. cd ~/github/etcbc/shebanq/scripts/computer ./installmacos --help","title":"Selective installation"},{"location":"deploy/documentation/","text":"Documentation \u00b6 User documentation \u00b6 User guide of SHEBANQ \u00b6 How to use SHEBANQ is documented on the wiki of the SHEBANQ repository on Github . People with access can edit those pages directly in the browser, if they are logged in with GitHub. You can also clone the wiki: cd ~/github/etcbc git clone https://github.com/ETCBC/shebanq/wiki Then you can make as many edits as you like, in whatever tool you like, and save it back to the online version by cd ~/github/etcbc/shebanq.wiki git add --all . git commit \"updated docs\" git push origin master Feature documentation of the BHSA \u00b6 This is stored in the BHSA repository and published via its GitHub pages method. The source docs are in its docs directory. If you have cloned you can edit the docs locally, and then build the docs via mkdocs . You install mkdocs by pip3 install mkdocs pip3 install mkdocs-material In order to build the documentation you do cd ~/github/etcbc/bhsa mkdocs build In order to publish it, you do cd ~/github/etcbc/bhsa mkdocs gh-deploy Note that publishing will trigger a build, so if you want to publish, you can leave out the build step. Finally, you can commit the changes to the doc sources by: cd ~/github/etcbc/bhsa git add --all . git commit \"updated feature docs\" git push origin master Technical documentation \u00b6 The technical documentation of SHEBANQ is also by means of mkdocs. In order to modify it, you have to install it, and a plugin: pip3 install mkdocs pip3 install mkdocs-material pip3 install mkdocstrings pip3 install 'pytkdocs[numpy-style]' You need an extra tool for Javascript documentation: npm install -g jsdoc npm install -g jsdoc-to-markdown Apart from a nest of markdown files, the documentation consists also of special comments extract from the Python and Javascript code. We get the Python docstrings by means of the mkdocs plugin mkdocstrings. We get the Javascript docstrings by means of jsdoc and jsdoc-to-markdown. We have build script to automate the maintenance steps, and it also takes care of documentation handling. Just do cd ~/github/etcbc/shebanq python3 build.py --help to look at the options, or inspect the source code . Why mkdocs? \u00b6 One of the advantages of mkdocs is that you can 'invoke' docstring documentation from within markdown files. It will then inject the formatted docstrings at that place in the documentation. That is handy, because this SHEBANQ is not a usual Python package, such as Text-Fabric is. For example, automatically building documentation for the whole SHEBANQ using pdoc3 is not possible, in contrast to Text-Fabric. A second good point is that mkdocstrings is potentially capable of doing Javascript as well. At the moment, there is not yet a handler for Javascript, so this advantage does not yet materialize. But still ... We extract the Javascript documentation using jsdoc(to markdown) and dump it into our source docs folder. From there it will be seen by mkdocs, and formatted with the other stuff. And the excellent thing is the autorefs plugin of mkdocs, by which we can easily cross-reference between all doc sources. That means that we can put a reference to a Javascript class right in the docstring of a Python class, and vice versa .","title":"Documentation"},{"location":"deploy/documentation/#documentation","text":"","title":"Documentation"},{"location":"deploy/documentation/#user-documentation","text":"","title":"User documentation"},{"location":"deploy/documentation/#user-guide-of-shebanq","text":"How to use SHEBANQ is documented on the wiki of the SHEBANQ repository on Github . People with access can edit those pages directly in the browser, if they are logged in with GitHub. You can also clone the wiki: cd ~/github/etcbc git clone https://github.com/ETCBC/shebanq/wiki Then you can make as many edits as you like, in whatever tool you like, and save it back to the online version by cd ~/github/etcbc/shebanq.wiki git add --all . git commit \"updated docs\" git push origin master","title":"User guide of SHEBANQ"},{"location":"deploy/documentation/#feature-documentation-of-the-bhsa","text":"This is stored in the BHSA repository and published via its GitHub pages method. The source docs are in its docs directory. If you have cloned you can edit the docs locally, and then build the docs via mkdocs . You install mkdocs by pip3 install mkdocs pip3 install mkdocs-material In order to build the documentation you do cd ~/github/etcbc/bhsa mkdocs build In order to publish it, you do cd ~/github/etcbc/bhsa mkdocs gh-deploy Note that publishing will trigger a build, so if you want to publish, you can leave out the build step. Finally, you can commit the changes to the doc sources by: cd ~/github/etcbc/bhsa git add --all . git commit \"updated feature docs\" git push origin master","title":"Feature documentation of the BHSA"},{"location":"deploy/documentation/#technical-documentation","text":"The technical documentation of SHEBANQ is also by means of mkdocs. In order to modify it, you have to install it, and a plugin: pip3 install mkdocs pip3 install mkdocs-material pip3 install mkdocstrings pip3 install 'pytkdocs[numpy-style]' You need an extra tool for Javascript documentation: npm install -g jsdoc npm install -g jsdoc-to-markdown Apart from a nest of markdown files, the documentation consists also of special comments extract from the Python and Javascript code. We get the Python docstrings by means of the mkdocs plugin mkdocstrings. We get the Javascript docstrings by means of jsdoc and jsdoc-to-markdown. We have build script to automate the maintenance steps, and it also takes care of documentation handling. Just do cd ~/github/etcbc/shebanq python3 build.py --help to look at the options, or inspect the source code .","title":"Technical documentation"},{"location":"deploy/documentation/#why-mkdocs","text":"One of the advantages of mkdocs is that you can 'invoke' docstring documentation from within markdown files. It will then inject the formatted docstrings at that place in the documentation. That is handy, because this SHEBANQ is not a usual Python package, such as Text-Fabric is. For example, automatically building documentation for the whole SHEBANQ using pdoc3 is not possible, in contrast to Text-Fabric. A second good point is that mkdocstrings is potentially capable of doing Javascript as well. At the moment, there is not yet a handler for Javascript, so this advantage does not yet materialize. But still ... We extract the Javascript documentation using jsdoc(to markdown) and dump it into our source docs folder. From there it will be seen by mkdocs, and formatted with the other stuff. And the excellent thing is the autorefs plugin of mkdocs, by which we can easily cross-reference between all doc sources. That means that we can put a reference to a Javascript class right in the docstring of a Python class, and vice versa .","title":"Why mkdocs?"},{"location":"deploy/maintenance/","text":"Installation and maintenance \u00b6 Motivation \u00b6 The promise of SHEBANQ to its users is that the queries and notes they have saved on SHEBANQ will be accessible by a fixed URL for the indefinite future. Therefore it is vitally important to backup this data and store those backups in a variety of places, not only on the server that hosts SHEBANQ, however well that server is being managed. The following tasks must be addressed: Server migration Servers do not have eternal life, so every now and then SHEBANQ has to migrate from one server to another. 'Foreign' servers We encourage people to host their own SHEBANQ, so we must support new installations on third party servers. Those servers must be equally maintainable as the offical servers. Software updates In order to keep SHEBANQ alive over the years, software updates must be carried out, not only of the webapp, but also of its supporting systems, Emdros , Web2Py , Python , and MariaDB (a replacement of MySQL ). Data updates The ETCBC , as the provider of the textual and linguistic data of the Hebrew Bible, produces data updates through its BHSA repository. These data updates must be applied to the servers that host SHEBANQ. There are some additional requirements which are vital for the long-term support of SHEBANQ. Security SHEBANQ servers should be secure. They must be hardened against attacks, and the user data must be kept safe, even if only the bare minimum of personal data is stored (names, email addresses, password hashes). Automation Maintaining a server requires countless nitty-gritty steps, which are easily forgotten. That is the prime reason to automate all these steps. People that are new to SHEBANQ should be able to maintain SHEBANQ in a straightforward way. Documentation The maintenance of SHEBANQ should be well documented . Together with automation it is the best help we can offer to the maintainers of SHEBANQ in the years to come. Testing Whenever parts of the SHEBANQ codebase are changed, it is immensely helpful to run a battery of tests as an indication that nothing has been broken by the changes. This is in an early stage of development. We have set up the framework and implemented a couple of tests, just to show the mechanism. The test themselves are also documented. See (testing)[../tests/index.md] Operation \u00b6 SHEBANQ has a build script by which you can take care of a few standard maintenance tasks: documentation building and publishing committing changes to GitHub Just do cd ~/github/etcbc/shebanq python3 build.py --help to look at the options, or inspect the source code . Shell function Write a shell function and put it into your .zshrc or bashrc like this function shb { cd ~/github/etcbc/shebanq python3 build.py \"$@\" } now you can run shb (i.e. shebanq-build) from any directory.","title":"Installation and maintenance"},{"location":"deploy/maintenance/#installation-and-maintenance","text":"","title":"Installation and maintenance"},{"location":"deploy/maintenance/#motivation","text":"The promise of SHEBANQ to its users is that the queries and notes they have saved on SHEBANQ will be accessible by a fixed URL for the indefinite future. Therefore it is vitally important to backup this data and store those backups in a variety of places, not only on the server that hosts SHEBANQ, however well that server is being managed. The following tasks must be addressed: Server migration Servers do not have eternal life, so every now and then SHEBANQ has to migrate from one server to another. 'Foreign' servers We encourage people to host their own SHEBANQ, so we must support new installations on third party servers. Those servers must be equally maintainable as the offical servers. Software updates In order to keep SHEBANQ alive over the years, software updates must be carried out, not only of the webapp, but also of its supporting systems, Emdros , Web2Py , Python , and MariaDB (a replacement of MySQL ). Data updates The ETCBC , as the provider of the textual and linguistic data of the Hebrew Bible, produces data updates through its BHSA repository. These data updates must be applied to the servers that host SHEBANQ. There are some additional requirements which are vital for the long-term support of SHEBANQ. Security SHEBANQ servers should be secure. They must be hardened against attacks, and the user data must be kept safe, even if only the bare minimum of personal data is stored (names, email addresses, password hashes). Automation Maintaining a server requires countless nitty-gritty steps, which are easily forgotten. That is the prime reason to automate all these steps. People that are new to SHEBANQ should be able to maintain SHEBANQ in a straightforward way. Documentation The maintenance of SHEBANQ should be well documented . Together with automation it is the best help we can offer to the maintainers of SHEBANQ in the years to come. Testing Whenever parts of the SHEBANQ codebase are changed, it is immensely helpful to run a battery of tests as an indication that nothing has been broken by the changes. This is in an early stage of development. We have set up the framework and implemented a couple of tests, just to show the mechanism. The test themselves are also documented. See (testing)[../tests/index.md]","title":"Motivation"},{"location":"deploy/maintenance/#operation","text":"SHEBANQ has a build script by which you can take care of a few standard maintenance tasks: documentation building and publishing committing changes to GitHub Just do cd ~/github/etcbc/shebanq python3 build.py --help to look at the options, or inspect the source code . Shell function Write a shell function and put it into your .zshrc or bashrc like this function shb { cd ~/github/etcbc/shebanq python3 build.py \"$@\" } now you can run shb (i.e. shebanq-build) from any directory.","title":"Operation"},{"location":"deploy/server/","text":"Server \u00b6 This article describes the installation and maintenance of SHEBANQ of a secure RedHat Fedora linux server. Ubuntu If you prefer Ubuntu, that should be easier. You need to change a few things: yum becomes apt-get , the names of installation packages might be slightly different. You can leave out typical selinux commands such as chcon and setsebool . Various locations maybe a little bit different. Tools \u00b6 This repository contains a set of shell scripts to perform installation and maintenance tasks on SHEBANQ servers. It also has most of the assets needed for installation. The remaining assets are available through the BHSA repository. Requirements Read first to the end of this document, and take note of the requirements . SELINUX might not be the most obvious choice to host SHEBANQ on, because it is considerably more difficult to work with than Ubuntu. However, there are a few key advantages you enjoy after the installation: prime security You have SHEBANQ running on a top-notch secure system. head-ache-free software updates Much of supporting software (Python, MySQL, Apache) can be updated without the risk of breaking things, because the current versions of them are supported for an extra long time. Often, new security updates are back-ported to older versions, so that you can avoid upgrading to newer but incompatible versions. The latter advantage is quite convenient for SHEBANQ, because the Emdros software is compiled against de MySQL libraries. So when MySQL is upgraded to a new version, Emdros has to be recompiled. And that is something we do not want to do too often. Requirements \u00b6 Server \u00b6 The server on which SHEBANQ is installed is a Security Enhanced Linux Server (SELINUX) . You must be able to access this server by means of ssh and scp , using a certificate , so that you are not prompted for passwords. You must have sudo rights on this server. We assume that the Apache webserver is already installed and: its config files reside in /etc/httpd ; the relevant certificates are installed in /etc/pki/tls/certs and /etc/pki/tls/private mod_wsgi is not yet installed. the ports 80 and 443 are open to the outside world Caution The installation procedure installs an Apache config file for SHEBANQ. It claims 1 process and 5 threads. You can modify this later on, manually. But keep the number of processes to 1 Because SHEBANQ stores global data in a cache that is local to the process. See Model: CACHING We assume that the following packages can be installed with yum . That means that you must have the right package repositories enabled. python36 python36-devel python3-markdown mod_wsgi mariadb mariadb-devel mariadb-server Local computer \u00b6 You have cloned the shebanq and bhsa repositories from Github to your local computer: cd ~/github/etcbc git clone https://github.com/etcbc/shebanq git clone https://github.com/etcbc/bhsa If you have cloned these long ago, you can make them up to date by pulling them again: cd ~/github/etcbc/shebanq git pull origin master cd ~/github/etcbc/bhsa git pull origin master You can choose to place the github directory somewhere else, see below, but the structure within the github directory must be as prescribed. The _local directory \u00b6 The scripts in ~/github/etcbc/scripts/maintenance have generic content. Before working with it, the file configtemplate must be edited to reflect your actual situation. Do this as follows: cd ~/github/etcbc/shebanq/scripts/maintenance ./localize.sh Now you have a directory ~/github/etcbc/shebanq/_local And the command tells you what to do next: copy configtemplate.sh to config.sh edit config.sh What needs to be done is: adapt the serverOther variables to your situation: provide the name of the database host server (typically: localhost) provide passwords for mysql users named shebanq and shebanq_admin ; these users will be created and later in the installation process shebanq_admin is used for importing data, and after installation the webapp will use shebanq to fetch data in response to requests by web users. provide the locations where the https-certificates are installed in Apache; these will be used in in the httpd config file for the webapp. The _local directory is never pushed online (because of the .gitignore file in the shebanq repo), so your local setup remains private. Also, when you tweak files in your _local directory, you can still pull new versions of the shebanq repository without overwriting your local changes. When you run a maintenance script, you should run them from this _local directory, to be sure that you run your adapted version. These local files are also the ones that are sent to the server in the provisioning step below. The scripts can be run from any directory, because they do not depend on the current working directory. The scripts \u00b6 The originals of the maintenance scripts are in the shebanq repository in the scripts/maintenance directory. In the previous step you have copied them to the _local directory. You can run all scripts with --help to view the options and arguments it accepts. backup.sh Run it on the server. Backs up the databases that have dynamic web data: shebanq_web shebanq_note save.sh Run it on your local computer. It will retrieve data from the server. Saves backups of dynamic web data from the shebanq server to a directory on your local computer where you hold backups. The backup is saved in a subfolder yyyy-mm-ddT-hh-mm-ss (the datetime of the backup). provision.sh Run it on your local computer. It will send data to the server. Copies all files needed for installation from your local computer to the shebanq server. These files end up in shebanq-install under your home directory there. The maintenance scripts themselves will be copied over from your _local directory to your home directory on the server. The latest backup of dynamic data from will be taken from your local computer and copied over to the server. You can run this script in single steps by passing an option. install.sh Run it on the server. Installs required software (MySQL, Python, ModWsgi, Emdros, Web2py, and Shebanq itself) and loads data into the databases. A user group shebanq will be created if it does not exist; the user who is you and the apache users are added to the members of this group. * You can run this script in single steps by passing an option. uninstall.sh Run it on the server. Uninstalls what install.sh has installed. You can run this script in single steps by passing an option. restore.sh Run it on the server. Restores the databases that have dynamic web data: shebanq_web shebanq_note They are restored from a previous backup. update.sh Run it on the server. Updates the shebanq webapp, i.e. the web-app as it is hung into the web2py framework. The situations \u00b6 There are several situations, depending on the server that hosts SHEBANQ: Production p url: shebanq.ancient-data.org hosted by DANS on a KNAW server publicly accessible, the one and only offical shebanq website Production (new) pn url: server.dans.knaw.nl hosted by DANS on a KNAW server, as a successor of the current production server not yet publicly accessible, not yet the one and only offical shebanq website Test t url: test.shebanq.ancient-data.org hosted by DANS on a KNAW server only accessible from within the DANS-KNAW network the one and only offical shebanq test website Other o url: to be configured by you hosted on your server access managed by you an unoffical shebanq website (very welcome, thanks for taking the trouble) Other (new) on url: to be configured by you hosted on your new server, as a successor to your current server access managed by you an unoffical shebanq website The scenarios \u00b6 The maintenance scripts can be used in several identified scenarios, which we spell out below. In all situations, when on the server, you must sudo the invocations of the scripts or run them as root. It might be the case, especially on production servers, that you do not have general sudo rights and that the script as a whole can not be run with root privileges. In that case you need to have rights for specific commands to run them under sudo. That is why in some scripts the word sudo still appears. If it does not work for your situation, you can tweak your local copy of the script. Install SHEBANQ on a new server \u00b6 Situation Other (first time) \u00b6 This is likely your case: you want to install SHEBANQ on a server of your choice. For the sake of simplicity we assume that the database resides on the server itself and we will transport and import all data needed. We assume that this there is no previous dynamic data to be imported. (local computer) ./provision.sh o upload all needed installation files to the server; there will also be (big) data transfers of the static databases. (server) ./install.sh perform the complete installation of shebanq Arrange with your internet provider to let the domain name point to the IP address of the server Other (migrating) \u00b6 You have a server with SHEBANQ running and want to migrate to a new server. (current server) ./backup.sh make a backup of user data (local computer) ./save.sh o save backup to local computer (local computer) ./provision.sh on upload all needed installation files to the server; the backup of the current server will be imported; there will also be (big) data transfers of the static databases. (new server) ./install.sh perform the complete installation of shebanq Arrange with your internet provider to let the domain name point to the IP address of the new server (local computer) Tweak config.sh and put the name of the new server into serverOther . Test \u00b6 The database resides on the test server itself, data operations will be performed. (production server) ./backup.sh make a backup of user data (only to get meaningful content in the databases) (local computer) ./save.sh p save backup to local computer (only to get meaningful content in the databases) (local computer) ./provision.sh t upload all needed installation files to the server; there will also be (big) data transfers of the static databases. (test server) ./install.sh perform the complete installation of shebanq Production (migrating) \u00b6 The database resides on a separate database server, no data operations needed. (current production server) ./backup.sh make a backup of user data (only for safety, if all goes well, we do not need it) (local computer) ./save.sh p save backup from current production server to local computer (only for safety, if all goes well, we do not need it) (local computer) ./provision.sh pn upload all needed installation files to the new production server; the static database files will be skipped. url configuration The shebanq configuration file that is hung into apache will specify a virtual host with the server name as url, not shebanq.ancient-data.org . In this way, the new server can be tested before changing the DNS. (new production server) ./install.sh perform the complete installation of shebanq (local computer) Tweak config.sh If all went well, and shebanq works on the new machine, change your _local/config.sh and put the server name of the new machine in the serverProd variable (it was in the serverProdNew variable). (local computer) ./provision.sh p --scripts upload the scripts again. Note that we use p now, and not pn . This has the effect that the url of the virtual host in the Apache config file of shebanq will be set to shebanq.ancient-data.nl . (new production server) ./install.sh --apache This puts the updated config file in place. Arrange with your internet provider to let the domain name point to the IP address of the new production server Update SHEBANQ on an existing server \u00b6 This works the same in all situations. We give the steps for the other situation, which is most likely your situation. In all situations, when on the server, you must sudo the invocations of the scripts or run them as root. SHEBANQ code only \u00b6 Do this when you noticed that the SHEBANQ repo has updates. (server) update.sh Pull the SHEBANQ repository from GitHUb That's all. Simple and quick. A version of the static data \u00b6 Do this when a new version of the etcbc data is released or an existing version has got an update. These databases are released through the etcbc/bhsa repository on GitHub, in the directory shebanq . You have them in your local clone of the BHSA. Below, version is the desired data version that you want to import, such as 4 , 4b , c , 2017 , 2021 . (local computer) git pull origin master Do this in your clone of the BHSA repository. And then again in your clone of the SHEBANQ repository (local computer) ./provision.sh o --static version upload all needed data files files to the server; (server) install.sh --static version This imports both the shebanq_passage and shebanq_etcbc databases of that version. (local computer) bulk import additional notes for the new data version There are currently two sets of notes that will be generated alongside an ETCBC data version: crossref and valence . Import them via the instructions mentioned below . Emdros \u00b6 Do this when you noticed that there is a new version of Emdros. In that case, the SHEBANQ repository contains all that is necessary. (local computer) git pull origin master Do this in your clone of the SHEBANQ repository. (local computer) Tweak config.sh Adapt the EMDROS_VERSION variable so that it reflects the Emdros version in question. (local computer) ./provision.sh o --emdros Only transfer the new Emdros distribution. (server) ./install.sh --emdros Install Emdros only. (server) update.sh Pull the SHEBANQ repository from GitHUb Web2py \u00b6 Do this when you noticed that there is a new version of Web2py and if you are sure that it does not break SHEBANQ. In that case, the SHEBANQ repository contains all that is necessary. (local computer) git pull origin master Do this in your clone of the SHEBANQ repository. (local computer) ./provision.sh o --web2py Only transfer the new Web2py distribution. (server) ./install.sh --web2py Install Web2py only. (server) update.sh Pull the SHEBANQ repository from GitHUb Maintain backups of dynamic data \u00b6 The dynamic data of SHEBANQ is stored in two databases: shebanq_web : user data: names and email addresses and password hashes of registered users. query data: meta data and results of queries that have been saved in shebanq shebanq_note : note data: metadata and content of all notes that have been saved in SHEBANQ. Currently, I make occasional backups of the production SHEBANQ and store them on my local computer, which is backed up in multiple ways, offline and online. Backup dynamic data \u00b6 (server) ./backup.sh This will create a fresh backup of the dynamic data and store it on the server in a folder with a time-stamped name. Also, a symbolic link under the name latest will link to that backup. (local computer) ./save.sh o This will fetch the latest backup from the server to your local computer. It will end up in your backup directory there, under the same time-stamped name, and also with a latest link. Restore dynamic data \u00b6 In cases where a server has crashed and data has been lost, it is necessary to restore the latest known dynamic data. (local computer) ./provision.sh o --dynamic This will find the latest dynamic data backup of the server that exists on your local computer and upload it to the server. (server) ./restore.sh This will find the latest dynamic data backup that exists on the server and import it to the databases. Mixing backups If you maintain multiple servers from your local computers, the backups of all these servers end up in the same place. Production and test backups are kept separate In order to avoid the risk of restoring a backup made on the test server to the production server, backups made on a test server are stored in a different directory. When backups are restored, they will never be taken from this directory, not even when restoring on the test server. If you do need to restore a test backup on the test server, you have to manually copy it over to the right place. The same holds for backups that come from the serverOtherNew and serverProdNew servers. These backups have no importance except for testing the processes, so they will be stored in the alternative place. Import massive amounts of notes \u00b6 The notes facility in SHEBANQ can be used for entering personal notes, but also for importing (big) sets of generated notes, such as cross-references, or syntactic annotations. Here is how to enable that function to users. We also point to the note sets that are generated by the pipeline alongside the BHSA and that should be imported with each ETCBC data version. Bulk uploading sets of notes \u00b6 Clone the repos etcbc/parallels and etcbc/valence . Like so: cd ~/github/etcbc git clone https://github.com/etcbc/parallels git clone https://github.com/etcbc/valence Both have a directory shebanq and under that subdirectories for the data versions of the BHSA. Go to the corresponding version, and locate the csv file that you find in each of those places. These are the ones you will upload. You have to be known to SHEBANQ as a bulk uploader . To make somebody into a bulk uploader , see below . Then go to the notes page of shebanq in your browser, and log in. In the right column you see a button to upload a csv file. Use it to upload the files we mentioned above. The notes in those files will be imported into shebanq. See also the user manual . Make somebody a bulk uploader \u00b6 Users have to be added manually to the table uploaders in the shebanq_web database. Only then they are offered to button to upload a csv file with notes. Find the user id in the auth_user table of the same database by select * from auth_user where first_name = 'hey' and last_name = 'you'; Pick your id from the id column. Then insert into uploaders (uid) values (yourid); That's it. Trouble shooting \u00b6 It is very difficult to view messages issued by Python code. print and sys.stderr.write() do not work. Neither does the following work: use the module logging from the standard Python library, and hook it up in the Web2py framework . That is to say: al these methods of logging work on your local computer, but none of these work on the server, and I cannot figure out why, because according to the WSGI documentation they all should work. Somewhere between Apache and WSGI information is lost. The situation is very unsatisfactory. We have a debug helper M: helpers.debug Just say from helpers import debug debug(\"here you are\") Such messages may go to these destinations, dependent on switches. stderr logger (file opt/web-apps/shebanq/log/debug.log ). the response Currently only stderr is switched on. If you are desperate to get output on the server, switch the response on, temporarily. Then you get the messages at the top of your page, after the page has loaded. However, use this only in emergencies or if there are discrepancies between the SHEBANQ on your local computer and the SHEBANQ on the server. The recommended practice is to install Web2Py and SHEBANQ on your local computer , and debug it there. SELINUX violations \u00b6 If you get an internal error, but there are no Web2Py errors listed for the SHEBANQ app, it is probably a permissions error that has nothing to do with the application logic. Try to run the server in permissive mode: setenforce 0 and make a new visit to the website. If all is well, there you have the culprit. Probably all stays well if you now put the mode back to enforcing: setenforce 1 But this is not et the solution. You want to know what permission got violated. On the server you can inspect the audit log ausearch -m avc --start today This gives you the violations for today. It might give you a hint to what went wrong. Probably the webserver needed to write a file for which it had no permissions. Obvious cases in a web2py application are: compilation of Python files. This standard Python behaviour compiles a Python file before running it and saves it in a __pychache__ directory next to the Python scripts. This write action is usually not permitted in directories with code. Some directories should be writable by the webserver, such as logs, uploads, databases. But when these directories are removed and then recreated, their writability might also been gone. To remedy this, our install.sh and update.sh take great care to precompile all possible Python files (under sudo ) and to give the writable directories the right security context, whenever they are created ( httpd_sys_rw_content_t ). Database permissions \u00b6 The next frequent source of errors is when the database cannot be reached. Here is a checklist: The database should be up and running; The required databases should be present in the database; The database must allow connections with the shebanq user on the server; and, during installation, also to the shebanq_admin user; The database should be set up with the right grants to its data; The web app should provide the right credentials; The web app should issue legal SQL statements. If one of these things goes wrong, there will be error messages in the Web2py errors for SHEBANQ.","title":"Server"},{"location":"deploy/server/#server","text":"This article describes the installation and maintenance of SHEBANQ of a secure RedHat Fedora linux server. Ubuntu If you prefer Ubuntu, that should be easier. You need to change a few things: yum becomes apt-get , the names of installation packages might be slightly different. You can leave out typical selinux commands such as chcon and setsebool . Various locations maybe a little bit different.","title":"Server"},{"location":"deploy/server/#tools","text":"This repository contains a set of shell scripts to perform installation and maintenance tasks on SHEBANQ servers. It also has most of the assets needed for installation. The remaining assets are available through the BHSA repository. Requirements Read first to the end of this document, and take note of the requirements . SELINUX might not be the most obvious choice to host SHEBANQ on, because it is considerably more difficult to work with than Ubuntu. However, there are a few key advantages you enjoy after the installation: prime security You have SHEBANQ running on a top-notch secure system. head-ache-free software updates Much of supporting software (Python, MySQL, Apache) can be updated without the risk of breaking things, because the current versions of them are supported for an extra long time. Often, new security updates are back-ported to older versions, so that you can avoid upgrading to newer but incompatible versions. The latter advantage is quite convenient for SHEBANQ, because the Emdros software is compiled against de MySQL libraries. So when MySQL is upgraded to a new version, Emdros has to be recompiled. And that is something we do not want to do too often.","title":"Tools"},{"location":"deploy/server/#requirements","text":"","title":"Requirements"},{"location":"deploy/server/#server_1","text":"The server on which SHEBANQ is installed is a Security Enhanced Linux Server (SELINUX) . You must be able to access this server by means of ssh and scp , using a certificate , so that you are not prompted for passwords. You must have sudo rights on this server. We assume that the Apache webserver is already installed and: its config files reside in /etc/httpd ; the relevant certificates are installed in /etc/pki/tls/certs and /etc/pki/tls/private mod_wsgi is not yet installed. the ports 80 and 443 are open to the outside world Caution The installation procedure installs an Apache config file for SHEBANQ. It claims 1 process and 5 threads. You can modify this later on, manually. But keep the number of processes to 1 Because SHEBANQ stores global data in a cache that is local to the process. See Model: CACHING We assume that the following packages can be installed with yum . That means that you must have the right package repositories enabled. python36 python36-devel python3-markdown mod_wsgi mariadb mariadb-devel mariadb-server","title":"Server"},{"location":"deploy/server/#local-computer","text":"You have cloned the shebanq and bhsa repositories from Github to your local computer: cd ~/github/etcbc git clone https://github.com/etcbc/shebanq git clone https://github.com/etcbc/bhsa If you have cloned these long ago, you can make them up to date by pulling them again: cd ~/github/etcbc/shebanq git pull origin master cd ~/github/etcbc/bhsa git pull origin master You can choose to place the github directory somewhere else, see below, but the structure within the github directory must be as prescribed.","title":"Local computer"},{"location":"deploy/server/#the-_local-directory","text":"The scripts in ~/github/etcbc/scripts/maintenance have generic content. Before working with it, the file configtemplate must be edited to reflect your actual situation. Do this as follows: cd ~/github/etcbc/shebanq/scripts/maintenance ./localize.sh Now you have a directory ~/github/etcbc/shebanq/_local And the command tells you what to do next: copy configtemplate.sh to config.sh edit config.sh What needs to be done is: adapt the serverOther variables to your situation: provide the name of the database host server (typically: localhost) provide passwords for mysql users named shebanq and shebanq_admin ; these users will be created and later in the installation process shebanq_admin is used for importing data, and after installation the webapp will use shebanq to fetch data in response to requests by web users. provide the locations where the https-certificates are installed in Apache; these will be used in in the httpd config file for the webapp. The _local directory is never pushed online (because of the .gitignore file in the shebanq repo), so your local setup remains private. Also, when you tweak files in your _local directory, you can still pull new versions of the shebanq repository without overwriting your local changes. When you run a maintenance script, you should run them from this _local directory, to be sure that you run your adapted version. These local files are also the ones that are sent to the server in the provisioning step below. The scripts can be run from any directory, because they do not depend on the current working directory.","title":"The _local directory"},{"location":"deploy/server/#the-scripts","text":"The originals of the maintenance scripts are in the shebanq repository in the scripts/maintenance directory. In the previous step you have copied them to the _local directory. You can run all scripts with --help to view the options and arguments it accepts. backup.sh Run it on the server. Backs up the databases that have dynamic web data: shebanq_web shebanq_note save.sh Run it on your local computer. It will retrieve data from the server. Saves backups of dynamic web data from the shebanq server to a directory on your local computer where you hold backups. The backup is saved in a subfolder yyyy-mm-ddT-hh-mm-ss (the datetime of the backup). provision.sh Run it on your local computer. It will send data to the server. Copies all files needed for installation from your local computer to the shebanq server. These files end up in shebanq-install under your home directory there. The maintenance scripts themselves will be copied over from your _local directory to your home directory on the server. The latest backup of dynamic data from will be taken from your local computer and copied over to the server. You can run this script in single steps by passing an option. install.sh Run it on the server. Installs required software (MySQL, Python, ModWsgi, Emdros, Web2py, and Shebanq itself) and loads data into the databases. A user group shebanq will be created if it does not exist; the user who is you and the apache users are added to the members of this group. * You can run this script in single steps by passing an option. uninstall.sh Run it on the server. Uninstalls what install.sh has installed. You can run this script in single steps by passing an option. restore.sh Run it on the server. Restores the databases that have dynamic web data: shebanq_web shebanq_note They are restored from a previous backup. update.sh Run it on the server. Updates the shebanq webapp, i.e. the web-app as it is hung into the web2py framework.","title":"The scripts"},{"location":"deploy/server/#the-situations","text":"There are several situations, depending on the server that hosts SHEBANQ: Production p url: shebanq.ancient-data.org hosted by DANS on a KNAW server publicly accessible, the one and only offical shebanq website Production (new) pn url: server.dans.knaw.nl hosted by DANS on a KNAW server, as a successor of the current production server not yet publicly accessible, not yet the one and only offical shebanq website Test t url: test.shebanq.ancient-data.org hosted by DANS on a KNAW server only accessible from within the DANS-KNAW network the one and only offical shebanq test website Other o url: to be configured by you hosted on your server access managed by you an unoffical shebanq website (very welcome, thanks for taking the trouble) Other (new) on url: to be configured by you hosted on your new server, as a successor to your current server access managed by you an unoffical shebanq website","title":"The situations"},{"location":"deploy/server/#the-scenarios","text":"The maintenance scripts can be used in several identified scenarios, which we spell out below. In all situations, when on the server, you must sudo the invocations of the scripts or run them as root. It might be the case, especially on production servers, that you do not have general sudo rights and that the script as a whole can not be run with root privileges. In that case you need to have rights for specific commands to run them under sudo. That is why in some scripts the word sudo still appears. If it does not work for your situation, you can tweak your local copy of the script.","title":"The scenarios"},{"location":"deploy/server/#install-shebanq-on-a-new-server","text":"","title":"Install SHEBANQ on a new server"},{"location":"deploy/server/#situation-other-first-time","text":"This is likely your case: you want to install SHEBANQ on a server of your choice. For the sake of simplicity we assume that the database resides on the server itself and we will transport and import all data needed. We assume that this there is no previous dynamic data to be imported. (local computer) ./provision.sh o upload all needed installation files to the server; there will also be (big) data transfers of the static databases. (server) ./install.sh perform the complete installation of shebanq Arrange with your internet provider to let the domain name point to the IP address of the server","title":"Situation Other (first time)"},{"location":"deploy/server/#other-migrating","text":"You have a server with SHEBANQ running and want to migrate to a new server. (current server) ./backup.sh make a backup of user data (local computer) ./save.sh o save backup to local computer (local computer) ./provision.sh on upload all needed installation files to the server; the backup of the current server will be imported; there will also be (big) data transfers of the static databases. (new server) ./install.sh perform the complete installation of shebanq Arrange with your internet provider to let the domain name point to the IP address of the new server (local computer) Tweak config.sh and put the name of the new server into serverOther .","title":"Other (migrating)"},{"location":"deploy/server/#test","text":"The database resides on the test server itself, data operations will be performed. (production server) ./backup.sh make a backup of user data (only to get meaningful content in the databases) (local computer) ./save.sh p save backup to local computer (only to get meaningful content in the databases) (local computer) ./provision.sh t upload all needed installation files to the server; there will also be (big) data transfers of the static databases. (test server) ./install.sh perform the complete installation of shebanq","title":"Test"},{"location":"deploy/server/#production-migrating","text":"The database resides on a separate database server, no data operations needed. (current production server) ./backup.sh make a backup of user data (only for safety, if all goes well, we do not need it) (local computer) ./save.sh p save backup from current production server to local computer (only for safety, if all goes well, we do not need it) (local computer) ./provision.sh pn upload all needed installation files to the new production server; the static database files will be skipped. url configuration The shebanq configuration file that is hung into apache will specify a virtual host with the server name as url, not shebanq.ancient-data.org . In this way, the new server can be tested before changing the DNS. (new production server) ./install.sh perform the complete installation of shebanq (local computer) Tweak config.sh If all went well, and shebanq works on the new machine, change your _local/config.sh and put the server name of the new machine in the serverProd variable (it was in the serverProdNew variable). (local computer) ./provision.sh p --scripts upload the scripts again. Note that we use p now, and not pn . This has the effect that the url of the virtual host in the Apache config file of shebanq will be set to shebanq.ancient-data.nl . (new production server) ./install.sh --apache This puts the updated config file in place. Arrange with your internet provider to let the domain name point to the IP address of the new production server","title":"Production (migrating)"},{"location":"deploy/server/#update-shebanq-on-an-existing-server","text":"This works the same in all situations. We give the steps for the other situation, which is most likely your situation. In all situations, when on the server, you must sudo the invocations of the scripts or run them as root.","title":"Update SHEBANQ on an existing server"},{"location":"deploy/server/#shebanq-code-only","text":"Do this when you noticed that the SHEBANQ repo has updates. (server) update.sh Pull the SHEBANQ repository from GitHUb That's all. Simple and quick.","title":"SHEBANQ code only"},{"location":"deploy/server/#a-version-of-the-static-data","text":"Do this when a new version of the etcbc data is released or an existing version has got an update. These databases are released through the etcbc/bhsa repository on GitHub, in the directory shebanq . You have them in your local clone of the BHSA. Below, version is the desired data version that you want to import, such as 4 , 4b , c , 2017 , 2021 . (local computer) git pull origin master Do this in your clone of the BHSA repository. And then again in your clone of the SHEBANQ repository (local computer) ./provision.sh o --static version upload all needed data files files to the server; (server) install.sh --static version This imports both the shebanq_passage and shebanq_etcbc databases of that version. (local computer) bulk import additional notes for the new data version There are currently two sets of notes that will be generated alongside an ETCBC data version: crossref and valence . Import them via the instructions mentioned below .","title":"A version of the static data"},{"location":"deploy/server/#emdros","text":"Do this when you noticed that there is a new version of Emdros. In that case, the SHEBANQ repository contains all that is necessary. (local computer) git pull origin master Do this in your clone of the SHEBANQ repository. (local computer) Tweak config.sh Adapt the EMDROS_VERSION variable so that it reflects the Emdros version in question. (local computer) ./provision.sh o --emdros Only transfer the new Emdros distribution. (server) ./install.sh --emdros Install Emdros only. (server) update.sh Pull the SHEBANQ repository from GitHUb","title":"Emdros"},{"location":"deploy/server/#web2py","text":"Do this when you noticed that there is a new version of Web2py and if you are sure that it does not break SHEBANQ. In that case, the SHEBANQ repository contains all that is necessary. (local computer) git pull origin master Do this in your clone of the SHEBANQ repository. (local computer) ./provision.sh o --web2py Only transfer the new Web2py distribution. (server) ./install.sh --web2py Install Web2py only. (server) update.sh Pull the SHEBANQ repository from GitHUb","title":"Web2py"},{"location":"deploy/server/#maintain-backups-of-dynamic-data","text":"The dynamic data of SHEBANQ is stored in two databases: shebanq_web : user data: names and email addresses and password hashes of registered users. query data: meta data and results of queries that have been saved in shebanq shebanq_note : note data: metadata and content of all notes that have been saved in SHEBANQ. Currently, I make occasional backups of the production SHEBANQ and store them on my local computer, which is backed up in multiple ways, offline and online.","title":"Maintain backups of dynamic data"},{"location":"deploy/server/#backup-dynamic-data","text":"(server) ./backup.sh This will create a fresh backup of the dynamic data and store it on the server in a folder with a time-stamped name. Also, a symbolic link under the name latest will link to that backup. (local computer) ./save.sh o This will fetch the latest backup from the server to your local computer. It will end up in your backup directory there, under the same time-stamped name, and also with a latest link.","title":"Backup dynamic data"},{"location":"deploy/server/#restore-dynamic-data","text":"In cases where a server has crashed and data has been lost, it is necessary to restore the latest known dynamic data. (local computer) ./provision.sh o --dynamic This will find the latest dynamic data backup of the server that exists on your local computer and upload it to the server. (server) ./restore.sh This will find the latest dynamic data backup that exists on the server and import it to the databases. Mixing backups If you maintain multiple servers from your local computers, the backups of all these servers end up in the same place. Production and test backups are kept separate In order to avoid the risk of restoring a backup made on the test server to the production server, backups made on a test server are stored in a different directory. When backups are restored, they will never be taken from this directory, not even when restoring on the test server. If you do need to restore a test backup on the test server, you have to manually copy it over to the right place. The same holds for backups that come from the serverOtherNew and serverProdNew servers. These backups have no importance except for testing the processes, so they will be stored in the alternative place.","title":"Restore dynamic data"},{"location":"deploy/server/#import-massive-amounts-of-notes","text":"The notes facility in SHEBANQ can be used for entering personal notes, but also for importing (big) sets of generated notes, such as cross-references, or syntactic annotations. Here is how to enable that function to users. We also point to the note sets that are generated by the pipeline alongside the BHSA and that should be imported with each ETCBC data version.","title":"Import massive amounts of notes"},{"location":"deploy/server/#bulk-uploading-sets-of-notes","text":"Clone the repos etcbc/parallels and etcbc/valence . Like so: cd ~/github/etcbc git clone https://github.com/etcbc/parallels git clone https://github.com/etcbc/valence Both have a directory shebanq and under that subdirectories for the data versions of the BHSA. Go to the corresponding version, and locate the csv file that you find in each of those places. These are the ones you will upload. You have to be known to SHEBANQ as a bulk uploader . To make somebody into a bulk uploader , see below . Then go to the notes page of shebanq in your browser, and log in. In the right column you see a button to upload a csv file. Use it to upload the files we mentioned above. The notes in those files will be imported into shebanq. See also the user manual .","title":"Bulk uploading sets of notes"},{"location":"deploy/server/#make-somebody-a-bulk-uploader","text":"Users have to be added manually to the table uploaders in the shebanq_web database. Only then they are offered to button to upload a csv file with notes. Find the user id in the auth_user table of the same database by select * from auth_user where first_name = 'hey' and last_name = 'you'; Pick your id from the id column. Then insert into uploaders (uid) values (yourid); That's it.","title":"Make somebody a bulk uploader"},{"location":"deploy/server/#trouble-shooting","text":"It is very difficult to view messages issued by Python code. print and sys.stderr.write() do not work. Neither does the following work: use the module logging from the standard Python library, and hook it up in the Web2py framework . That is to say: al these methods of logging work on your local computer, but none of these work on the server, and I cannot figure out why, because according to the WSGI documentation they all should work. Somewhere between Apache and WSGI information is lost. The situation is very unsatisfactory. We have a debug helper M: helpers.debug Just say from helpers import debug debug(\"here you are\") Such messages may go to these destinations, dependent on switches. stderr logger (file opt/web-apps/shebanq/log/debug.log ). the response Currently only stderr is switched on. If you are desperate to get output on the server, switch the response on, temporarily. Then you get the messages at the top of your page, after the page has loaded. However, use this only in emergencies or if there are discrepancies between the SHEBANQ on your local computer and the SHEBANQ on the server. The recommended practice is to install Web2Py and SHEBANQ on your local computer , and debug it there.","title":"Trouble shooting"},{"location":"deploy/server/#selinux-violations","text":"If you get an internal error, but there are no Web2Py errors listed for the SHEBANQ app, it is probably a permissions error that has nothing to do with the application logic. Try to run the server in permissive mode: setenforce 0 and make a new visit to the website. If all is well, there you have the culprit. Probably all stays well if you now put the mode back to enforcing: setenforce 1 But this is not et the solution. You want to know what permission got violated. On the server you can inspect the audit log ausearch -m avc --start today This gives you the violations for today. It might give you a hint to what went wrong. Probably the webserver needed to write a file for which it had no permissions. Obvious cases in a web2py application are: compilation of Python files. This standard Python behaviour compiles a Python file before running it and saves it in a __pychache__ directory next to the Python scripts. This write action is usually not permitted in directories with code. Some directories should be writable by the webserver, such as logs, uploads, databases. But when these directories are removed and then recreated, their writability might also been gone. To remedy this, our install.sh and update.sh take great care to precompile all possible Python files (under sudo ) and to give the writable directories the right security context, whenever they are created ( httpd_sys_rw_content_t ).","title":"SELINUX violations"},{"location":"deploy/server/#database-permissions","text":"The next frequent source of errors is when the database cannot be reached. Here is a checklist: The database should be up and running; The required databases should be present in the database; The database must allow connections with the shebanq user on the server; and, during installation, also to the shebanq_admin user; The database should be set up with the right grants to its data; The web app should provide the right credentials; The web app should issue legal SQL statements. If one of these things goes wrong, there will be error messages in the Web2py errors for SHEBANQ.","title":"Database permissions"},{"location":"elements/","text":"Pages \u00b6 We give an overview of the elements of the typical SHEBANQ pages, and we will name the different parts. These concepts will recur in the discussion of the code, whether it is Python, Javascript, CSS, HTML or SQL. A good introduction into the kinds of pages is the menubar. Main pages \u00b6 There are several kinds of main pages text pages have Hebrew text material words presents the lexicon queries presents the family of saved queries, organized by organization, project and user notes presents the family of saved notes, organized by organization, project and user","title":"Pages"},{"location":"elements/#pages","text":"We give an overview of the elements of the typical SHEBANQ pages, and we will name the different parts. These concepts will recur in the discussion of the code, whether it is Python, Javascript, CSS, HTML or SQL. A good introduction into the kinds of pages is the menubar.","title":"Pages"},{"location":"elements/#main-pages","text":"There are several kinds of main pages text pages have Hebrew text material words presents the lexicon queries presents the family of saved queries, organized by organization, project and user notes presents the family of saved notes, organized by organization, project and user","title":"Main pages"},{"location":"elements/notespage/","text":"Notes pages \u00b6 The notes page contains the list of all note sets in the system that you can see. Those consist of all published and shared notes plus your own notes if you are logged in. You get there from the Notes menu in the navigation bar. Here is a schematic overview: ======================================================================== |all: icon menu login | |all: Text Word Queries Notes | ======================================================================== ====================== ============================ ================== | simple/advanced | | mutebox shared notes | | upload-control | | recent query | | -- mutebox user | ================== | recent query | | --- mutebox keyword link | | recent query | | ... | | recent query | | ... | | recent query | | ... | | recent query | | ... | ====================== | ... | | ... | ====================== | ... | | Filter | | ... | | fulltext box | | ... | | all-matches | | ... | | all-with-children | | ... | | in-my-queries | | ... | | clear-filter | | ... | ---------------------- | ... | | Level | | ... | | organizations | | ... | | projects | | ... | | users | | ... | | queries | | ... | | manual | | ... | ---------------------- | ... | | ... | | ... | | ... | ============================","title":"Notes pages"},{"location":"elements/notespage/#notes-pages","text":"The notes page contains the list of all note sets in the system that you can see. Those consist of all published and shared notes plus your own notes if you are logged in. You get there from the Notes menu in the navigation bar. Here is a schematic overview: ======================================================================== |all: icon menu login | |all: Text Word Queries Notes | ======================================================================== ====================== ============================ ================== | simple/advanced | | mutebox shared notes | | upload-control | | recent query | | -- mutebox user | ================== | recent query | | --- mutebox keyword link | | recent query | | ... | | recent query | | ... | | recent query | | ... | | recent query | | ... | ====================== | ... | | ... | ====================== | ... | | Filter | | ... | | fulltext box | | ... | | all-matches | | ... | | all-with-children | | ... | | in-my-queries | | ... | | clear-filter | | ... | ---------------------- | ... | | Level | | ... | | organizations | | ... | | projects | | ... | | users | | ... | | queries | | ... | | manual | | ... | ---------------------- | ... | | ... | | ... | | ... | ============================","title":"Notes pages"},{"location":"elements/queriespage/","text":"Queries pages \u00b6 The queries page contains the list of all queries in the system that you can see. Those are all published and shared queries plus your own queries if you are logged in. You get there from the Queries menu in the navigation bar. Here is a schematic overview: ================================================================================== |all: icon menu login | |all: Text Word Queries Notes | ================================================================================== ====================== ====================================== ================== | simple/advanced | | mutebox shared queries | | new-query | | refresh RSS Feedly | | - mutebox select organization edit | | name-box | | | | -- mutebox select project edit | | org-control | | recent query | | --- mutebox user edit | | proj-control | | recent query | | ---- mutebox query link edit | ------------------ | recent query | | ... | | cancel save go | | recent query | | ... | ================== | recent query | | ... | | recent query | | ... | ====================== | ... | | ... | ====================== | ... | | Filter | | ... | | fulltext box | | ... | | all-matches | | ... | | all-with-children | | ... | | in-my-queries | | ... | | clear-filter | | ... | ---------------------- | ... | | Level | | ... | | organizations | | ... | | projects | | ... | | users | | ... | | queries | | ... | | manual | | ... | ---------------------- | ... | | ... | | ... | | ... | ======================================","title":"Queries pages"},{"location":"elements/queriespage/#queries-pages","text":"The queries page contains the list of all queries in the system that you can see. Those are all published and shared queries plus your own queries if you are logged in. You get there from the Queries menu in the navigation bar. Here is a schematic overview: ================================================================================== |all: icon menu login | |all: Text Word Queries Notes | ================================================================================== ====================== ====================================== ================== | simple/advanced | | mutebox shared queries | | new-query | | refresh RSS Feedly | | - mutebox select organization edit | | name-box | | | | -- mutebox select project edit | | org-control | | recent query | | --- mutebox user edit | | proj-control | | recent query | | ---- mutebox query link edit | ------------------ | recent query | | ... | | cancel save go | | recent query | | ... | ================== | recent query | | ... | | recent query | | ... | ====================== | ... | | ... | ====================== | ... | | Filter | | ... | | fulltext box | | ... | | all-matches | | ... | | all-with-children | | ... | | in-my-queries | | ... | | clear-filter | | ... | ---------------------- | ... | | Level | | ... | | organizations | | ... | | projects | | ... | | users | | ... | | queries | | ... | | manual | | ... | ---------------------- | ... | | ... | | ... | | ... | ======================================","title":"Queries pages"},{"location":"elements/sidebars/","text":"Sidebars \u00b6 Here we show the elements of sidebars that are specific to the type of sidebar. material page, word list \u00b6 Schematically: selectbox colorpicker expand gloss lexeme and when expanded the expansion is inserted below additional properties of the word in short style material page, queries list \u00b6 Schematically: selectbox colorpicker expand user title and when expanded the expansion is inserted below big-area control full-title full-user full-description mql-query-instruction material page, note sets list \u00b6 Schematically: selectbox expand user keyword and when expanded the expansion is inserted below full-user full-keyword statistics for this chapter record page of type word \u00b6 For all data versions expand version csv-icons chart-icon and when expanded the expansion is inserted below list of properties and values of the word record page of type query \u00b6 link big-area-button full-description shared-status ```` Below that, for all data versions expand version number-of-results and when expanded the expansion is inserted below csv-icons chart-icon mql-doc-link execute edit mql-box properties and values, among which the published status and when editing there the area for the reocrd increases and shows: link name-entry-box description-markdown-entry-box shared-control and then per version collapse csv-controls chart-control mql-doc-link execute save save-close cancel mql-entry-box properties and values, among which the published status ## **record** page of type **note set** link full-user full-keyword ```` Below that, for all data versions expand version csv-icons chart-icon and when expanded the expansion is inserted below the number of notes of this user and with this keyword in that version","title":"Sidebars"},{"location":"elements/sidebars/#sidebars","text":"Here we show the elements of sidebars that are specific to the type of sidebar.","title":"Sidebars"},{"location":"elements/sidebars/#material-page-word-list","text":"Schematically: selectbox colorpicker expand gloss lexeme and when expanded the expansion is inserted below additional properties of the word in short style","title":"material page, word list"},{"location":"elements/sidebars/#material-page-queries-list","text":"Schematically: selectbox colorpicker expand user title and when expanded the expansion is inserted below big-area control full-title full-user full-description mql-query-instruction","title":"material page, queries list"},{"location":"elements/sidebars/#material-page-note-sets-list","text":"Schematically: selectbox expand user keyword and when expanded the expansion is inserted below full-user full-keyword statistics for this chapter","title":"material page, note sets list"},{"location":"elements/sidebars/#record-page-of-type-word","text":"For all data versions expand version csv-icons chart-icon and when expanded the expansion is inserted below list of properties and values of the word","title":"record page of type word"},{"location":"elements/sidebars/#record-page-of-type-query","text":"link big-area-button full-description shared-status ```` Below that, for all data versions expand version number-of-results and when expanded the expansion is inserted below csv-icons chart-icon mql-doc-link execute edit mql-box properties and values, among which the published status and when editing there the area for the reocrd increases and shows: link name-entry-box description-markdown-entry-box shared-control and then per version collapse csv-controls chart-control mql-doc-link execute save save-close cancel mql-entry-box properties and values, among which the published status ## **record** page of type **note set** link full-user full-keyword ```` Below that, for all data versions expand version csv-icons chart-icon and when expanded the expansion is inserted below the number of notes of this user and with this keyword in that version","title":"record page of type query"},{"location":"elements/textpages/","text":"Text pages \u00b6 The text pages are the bread and butter of shebanq, they are subdivided into two kinds: material pages show a chapter of the Hebrew Bible: the left sidebar may show related words, queries, notes the main area shows the text of the chapter, as a list of its verses; record pages show an individual word , query , or note set ; we use the term record to refer to an individual word, query or note set. the left sidebar shows the characteristics of the record, depending on the type of the record, the main area shows the verses that belong to that record, as a list of verses, being: for a word, the verses where it occurs; for a query, shows the verses where it has results; for a note set, the verses where it has members. Operation \u00b6 When a SHEBANQ user navigates on a text page, he can switch between material and record pages. On a material page he sees chapter material, in a sidebar he sees lists of related words, queries, notes. A click on a related query item opens an rq page. There he sees hits of that query. Every hit has a link to the chapter the hit is in. A click on that chapter opens a material page for that chapter. In the sidebars there are again related words, queries, notes. A click on a related word opens an rw page. And so on. Under the hood there is just a single page. All blocks are always present on a text page, but not all are visible. Two parameters regulate which one are visible mr = m or r ( material or record ) qw = w or q or n ( word , query or note set ) Changes in mr and qw trigger the showing and hiding of the appropriate blocks. Moreover, if needed, fresh content for these blocks is fetched from the server by means of AJAX calls and inserted into them. So, during all this navigation, the skeleton of the page does not change, and the server is only accessed by for partial content. The controls for content selection and view settings belong to the skeleton. code type associated names JS materialsettings.MaterialSettings , sideSettings.sideSettings.js view text.html controller hebrew.text() Skeleton \u00b6 All text pages have a left side bar and a main area. Both areas have a header which contains verious controls that influence the selection and presentation of the content. Here is a schematic overview. =============================================================================== |all: icon menu login | |all: Text Word Queries Notes | =============================================================================== ====================== ===================================================== |m:w list controls | |m: material controls book chapter | |m:w word list | |m: verse content verse | |m:w | |m: verse content verse | ---------------------- |m: verse content verse | |m:q list controls | ===================================================== |m:q query list | |rw: material controls word page | |m:q query list | |rw: verse content chapter:verse | |m:q | |rw: verse content verse | ---------------------- |rw: verse content verse | |m:n list controls | ===================================================== |m:n note list | |rq: material controls query page | |m:n | |rq: verse content verse | ====================== |rq: verse content verse | |rw: record control | |rq: verse content verse | |rw: word info | ===================================================== |rw: | |rn: material controls noteset page | ====================== |rn: verse content verse | |rq: record control | |rn: verse content verse | |rq: query info | |rn: verse content verse | |rq: | ===================================================== ====================== |rn: record control | |rn: note set info | ============= |rn: | |text: cite | ====================== ============= Not all blocks occur on all pages. The qualifiers indicate what occurs on what: qualifier page type all: all pages text: all text pages m: all material text pages m:w all material text pages if word sidebar is on m:q all material text pages if query sidebar is on m:n all material text pages if noteset sidebar is on rw: all record text pages of type word rq: all record text pages of type query rn: all record text pages of type noteset Below we give the elements on these pages. However, for the sidebars we show only the generic controls, not the elements that are specific for the kind of sidebar. See sidebars for those details. Material Controls \u00b6 elem-info \u00b6 link to feature docs of BHSA code type associated names views versions.html CSS #select_version , source.ctli code {SelectPassage.apply} elem-version \u00b6 select ETCBC data version code type associated names views versions.html CSS mvradio.ctl code {words.View.selectVersion} , {SelectPassage.apply} , M:VIEWSETTINGS.currentVersion elem-links \u00b6 each chapter has a link to the same chapter in other tools, such as Bible Online Learner and ParaBible , not on record pages. code type associated names views textbody.html CSS #bol_lnk , #pbl_lnk code {SelectPassage.apply} elem-language-info \u00b6 overview of the names of all books in all available languages code type associated names views textbody.html CSS #thelang , #select_control_lang code C: hebrew.books , M:blang elem-language \u00b6 switch between languages in which the names of the books of the bible are presented. code type associated names views textbody.html CSS #thelang , #select_control_lang code {SelectLanguage} , C: hebrew.books , M:blang elem-text-representation \u00b6 select hebrew script or phonetic script code type associated names views textbody.html CSS mtradio.ctl , mhb , mph code tr , {MaterialSettings} , M:VERSECONTENT.plainText elem-text-presentation \u00b6 select normal running text, or one of several tabular formats. The tabular formats present the text by clause atom , one clause atom per line, with extra syntactic information added Notes : with notes displayed Syntax : with indentation according to linguistic embedding Abstract : with letter mapped to just a few symbols code type associated names views textbody.html CSS mhradio.ctl , #mtxtp . mtxt1 , #mtxt2 , mtxt3 code tp , {MaterialSettings} , M:VERSECONTENT.tab1Text , tab2 , tab3 elem-book \u00b6 select a book of the bible, not on record pages code type associated names views textbody.html CSS #select_control_book , #thebook code book , {Material} , {SelectBook} , {SelectPassage} , {share} , M:MATERIAL , M:BOOKS elem-chapter \u00b6 select a chapter within the current book, not on record pages, with controls to go to next/previous chapters code type associated names views textbody.html CSS #select_control_chapter , #thechapter code chapter , {Material} , {SelectItems} , {SelectPassage} , {share} , M:MATERIAL elem-page \u00b6 select a page within the list of items associated with the current record (word/query/note set), not on material pages, with controls to go to next/previous pages code type associated names views textbody.html CSS #select_control_page , #thepage code page , {Material} , {SelectItems} , {share} , M:MATERIAL List Controls \u00b6 elem-highlight-published \u00b6 show published items only; not in word item lists code type associated names views textsidebar.html CSS #hlpub[qn] , [qn]pradio.ctl code {SideSettings} , {NoteVerse} , M:viewdefs.Make elem-highlight-reset \u00b6 reset the highlighting of all items in this list; not in note item lists code type associated names views textsidebar.html CSS #hlreset[wq] , [wq]hradio.ctl code {SideSettings} , M:viewdefs.Make elem-highlight-many \u00b6 highlight all items in this list; not in note item lists code type associated names views textsidebar.html CSS #hlmany[wq] , [wq]hradio.ctl code {SideSettings} , M:viewdefs.Make elem-highlight-custom \u00b6 highlight only selected items in this list; not in note item lists code type associated names views textsidebar.html CSS #hlcustom[wq] , [wq]hradio.ctl code {SideSettings} , M:viewdefs.Make elem-highlight-one \u00b6 highlight the selected items in this list and use only one color for that, to be selected in the box next to it; not in note item lists code type associated names views textsidebar.html CSS #hlone[wq] , [wq]hradio.ctl code {SideSettings} , M:viewdefs.Make elem-highlight-off \u00b6 turn highlighting off for all items in this list ; not in note item lists code type associated names views textsidebar.html CSS #hloff[wq] , [wq]hradio.ctl code {SideSettings} , M:viewdefs.Make elem-highlight-select-single-color \u00b6 if highlight one is chosen, pick the color used for all highlights; not in note item lists code type associated names views textsidebar.html CSS #sel[wq]_one , colorselect_[wq] code {SideSettings} , {ColorPicker1} , {ColorPicker2} , {viewState} , M:viewdefs.Make Record Control \u00b6 elem-highlight-select-color \u00b6 pick the color used to highlight items of this record, i.e. occurrences of this word or hits of this query; not in note item lists code type associated names views textsidebar.html CSS #sel[wq]_me , colorselect_[wq] code {SideSettings} , {ColorPicker1} , {viewState} Content \u00b6 The main area presents a verse list. The verses are those of a chapter for a material page, and those of a record for an record page. Think of query results and word occurrences and notes from a note set. elem-goto-chapter \u00b6 record pages show book-chapter indications next to the verses, which link to the material pages of the corresponding book chapters. code type associated names views material.html CSS cref code {Material} elem-show-verse-data \u00b6 Both material and record pages show verse numbers next to the verses, which are clickable and open a data view of the corresponding verses, together with a legend button. code type associated names views material.html CSS vradio , #datalegend_control code {Material.addVerseRefs} elem-feature-legend \u00b6 The legend can be used to control which features are displayed in data view. The feature labels in the legend link to the feature documentation in the BHSA repo. code type associated names views textbody.html, material.html CSS #datalegend_control code {Material} , {MaterialSettings} , [M:boiler.LEGEND] Citation \u00b6 elem-cite-slider \u00b6 At the bottom-right corner of the page is a slider control from where the user can pick urls for citation. Which urls are shown is dependent on the contents of the page. code type associated names CSS #citeh code {share}","title":"Text pages"},{"location":"elements/textpages/#text-pages","text":"The text pages are the bread and butter of shebanq, they are subdivided into two kinds: material pages show a chapter of the Hebrew Bible: the left sidebar may show related words, queries, notes the main area shows the text of the chapter, as a list of its verses; record pages show an individual word , query , or note set ; we use the term record to refer to an individual word, query or note set. the left sidebar shows the characteristics of the record, depending on the type of the record, the main area shows the verses that belong to that record, as a list of verses, being: for a word, the verses where it occurs; for a query, shows the verses where it has results; for a note set, the verses where it has members.","title":"Text pages"},{"location":"elements/textpages/#operation","text":"When a SHEBANQ user navigates on a text page, he can switch between material and record pages. On a material page he sees chapter material, in a sidebar he sees lists of related words, queries, notes. A click on a related query item opens an rq page. There he sees hits of that query. Every hit has a link to the chapter the hit is in. A click on that chapter opens a material page for that chapter. In the sidebars there are again related words, queries, notes. A click on a related word opens an rw page. And so on. Under the hood there is just a single page. All blocks are always present on a text page, but not all are visible. Two parameters regulate which one are visible mr = m or r ( material or record ) qw = w or q or n ( word , query or note set ) Changes in mr and qw trigger the showing and hiding of the appropriate blocks. Moreover, if needed, fresh content for these blocks is fetched from the server by means of AJAX calls and inserted into them. So, during all this navigation, the skeleton of the page does not change, and the server is only accessed by for partial content. The controls for content selection and view settings belong to the skeleton. code type associated names JS materialsettings.MaterialSettings , sideSettings.sideSettings.js view text.html controller hebrew.text()","title":"Operation"},{"location":"elements/textpages/#skeleton","text":"All text pages have a left side bar and a main area. Both areas have a header which contains verious controls that influence the selection and presentation of the content. Here is a schematic overview. =============================================================================== |all: icon menu login | |all: Text Word Queries Notes | =============================================================================== ====================== ===================================================== |m:w list controls | |m: material controls book chapter | |m:w word list | |m: verse content verse | |m:w | |m: verse content verse | ---------------------- |m: verse content verse | |m:q list controls | ===================================================== |m:q query list | |rw: material controls word page | |m:q query list | |rw: verse content chapter:verse | |m:q | |rw: verse content verse | ---------------------- |rw: verse content verse | |m:n list controls | ===================================================== |m:n note list | |rq: material controls query page | |m:n | |rq: verse content verse | ====================== |rq: verse content verse | |rw: record control | |rq: verse content verse | |rw: word info | ===================================================== |rw: | |rn: material controls noteset page | ====================== |rn: verse content verse | |rq: record control | |rn: verse content verse | |rq: query info | |rn: verse content verse | |rq: | ===================================================== ====================== |rn: record control | |rn: note set info | ============= |rn: | |text: cite | ====================== ============= Not all blocks occur on all pages. The qualifiers indicate what occurs on what: qualifier page type all: all pages text: all text pages m: all material text pages m:w all material text pages if word sidebar is on m:q all material text pages if query sidebar is on m:n all material text pages if noteset sidebar is on rw: all record text pages of type word rq: all record text pages of type query rn: all record text pages of type noteset Below we give the elements on these pages. However, for the sidebars we show only the generic controls, not the elements that are specific for the kind of sidebar. See sidebars for those details.","title":"Skeleton"},{"location":"elements/textpages/#material-controls","text":"","title":"Material Controls"},{"location":"elements/textpages/#elem-info","text":"link to feature docs of BHSA code type associated names views versions.html CSS #select_version , source.ctli code {SelectPassage.apply}","title":"elem-info"},{"location":"elements/textpages/#elem-version","text":"select ETCBC data version code type associated names views versions.html CSS mvradio.ctl code {words.View.selectVersion} , {SelectPassage.apply} , M:VIEWSETTINGS.currentVersion","title":"elem-version"},{"location":"elements/textpages/#elem-links","text":"each chapter has a link to the same chapter in other tools, such as Bible Online Learner and ParaBible , not on record pages. code type associated names views textbody.html CSS #bol_lnk , #pbl_lnk code {SelectPassage.apply}","title":"elem-links"},{"location":"elements/textpages/#elem-language-info","text":"overview of the names of all books in all available languages code type associated names views textbody.html CSS #thelang , #select_control_lang code C: hebrew.books , M:blang","title":"elem-language-info"},{"location":"elements/textpages/#elem-language","text":"switch between languages in which the names of the books of the bible are presented. code type associated names views textbody.html CSS #thelang , #select_control_lang code {SelectLanguage} , C: hebrew.books , M:blang","title":"elem-language"},{"location":"elements/textpages/#elem-text-representation","text":"select hebrew script or phonetic script code type associated names views textbody.html CSS mtradio.ctl , mhb , mph code tr , {MaterialSettings} , M:VERSECONTENT.plainText","title":"elem-text-representation"},{"location":"elements/textpages/#elem-text-presentation","text":"select normal running text, or one of several tabular formats. The tabular formats present the text by clause atom , one clause atom per line, with extra syntactic information added Notes : with notes displayed Syntax : with indentation according to linguistic embedding Abstract : with letter mapped to just a few symbols code type associated names views textbody.html CSS mhradio.ctl , #mtxtp . mtxt1 , #mtxt2 , mtxt3 code tp , {MaterialSettings} , M:VERSECONTENT.tab1Text , tab2 , tab3","title":"elem-text-presentation"},{"location":"elements/textpages/#elem-book","text":"select a book of the bible, not on record pages code type associated names views textbody.html CSS #select_control_book , #thebook code book , {Material} , {SelectBook} , {SelectPassage} , {share} , M:MATERIAL , M:BOOKS","title":"elem-book"},{"location":"elements/textpages/#elem-chapter","text":"select a chapter within the current book, not on record pages, with controls to go to next/previous chapters code type associated names views textbody.html CSS #select_control_chapter , #thechapter code chapter , {Material} , {SelectItems} , {SelectPassage} , {share} , M:MATERIAL","title":"elem-chapter"},{"location":"elements/textpages/#elem-page","text":"select a page within the list of items associated with the current record (word/query/note set), not on material pages, with controls to go to next/previous pages code type associated names views textbody.html CSS #select_control_page , #thepage code page , {Material} , {SelectItems} , {share} , M:MATERIAL","title":"elem-page"},{"location":"elements/textpages/#list-controls","text":"","title":"List Controls"},{"location":"elements/textpages/#elem-highlight-published","text":"show published items only; not in word item lists code type associated names views textsidebar.html CSS #hlpub[qn] , [qn]pradio.ctl code {SideSettings} , {NoteVerse} , M:viewdefs.Make","title":"elem-highlight-published"},{"location":"elements/textpages/#elem-highlight-reset","text":"reset the highlighting of all items in this list; not in note item lists code type associated names views textsidebar.html CSS #hlreset[wq] , [wq]hradio.ctl code {SideSettings} , M:viewdefs.Make","title":"elem-highlight-reset"},{"location":"elements/textpages/#elem-highlight-many","text":"highlight all items in this list; not in note item lists code type associated names views textsidebar.html CSS #hlmany[wq] , [wq]hradio.ctl code {SideSettings} , M:viewdefs.Make","title":"elem-highlight-many"},{"location":"elements/textpages/#elem-highlight-custom","text":"highlight only selected items in this list; not in note item lists code type associated names views textsidebar.html CSS #hlcustom[wq] , [wq]hradio.ctl code {SideSettings} , M:viewdefs.Make","title":"elem-highlight-custom"},{"location":"elements/textpages/#elem-highlight-one","text":"highlight the selected items in this list and use only one color for that, to be selected in the box next to it; not in note item lists code type associated names views textsidebar.html CSS #hlone[wq] , [wq]hradio.ctl code {SideSettings} , M:viewdefs.Make","title":"elem-highlight-one"},{"location":"elements/textpages/#elem-highlight-off","text":"turn highlighting off for all items in this list ; not in note item lists code type associated names views textsidebar.html CSS #hloff[wq] , [wq]hradio.ctl code {SideSettings} , M:viewdefs.Make","title":"elem-highlight-off"},{"location":"elements/textpages/#elem-highlight-select-single-color","text":"if highlight one is chosen, pick the color used for all highlights; not in note item lists code type associated names views textsidebar.html CSS #sel[wq]_one , colorselect_[wq] code {SideSettings} , {ColorPicker1} , {ColorPicker2} , {viewState} , M:viewdefs.Make","title":"elem-highlight-select-single-color"},{"location":"elements/textpages/#record-control","text":"","title":"Record Control"},{"location":"elements/textpages/#elem-highlight-select-color","text":"pick the color used to highlight items of this record, i.e. occurrences of this word or hits of this query; not in note item lists code type associated names views textsidebar.html CSS #sel[wq]_me , colorselect_[wq] code {SideSettings} , {ColorPicker1} , {viewState}","title":"elem-highlight-select-color"},{"location":"elements/textpages/#content","text":"The main area presents a verse list. The verses are those of a chapter for a material page, and those of a record for an record page. Think of query results and word occurrences and notes from a note set.","title":"Content"},{"location":"elements/textpages/#elem-goto-chapter","text":"record pages show book-chapter indications next to the verses, which link to the material pages of the corresponding book chapters. code type associated names views material.html CSS cref code {Material}","title":"elem-goto-chapter"},{"location":"elements/textpages/#elem-show-verse-data","text":"Both material and record pages show verse numbers next to the verses, which are clickable and open a data view of the corresponding verses, together with a legend button. code type associated names views material.html CSS vradio , #datalegend_control code {Material.addVerseRefs}","title":"elem-show-verse-data"},{"location":"elements/textpages/#elem-feature-legend","text":"The legend can be used to control which features are displayed in data view. The feature labels in the legend link to the feature documentation in the BHSA repo. code type associated names views textbody.html, material.html CSS #datalegend_control code {Material} , {MaterialSettings} , [M:boiler.LEGEND]","title":"elem-feature-legend"},{"location":"elements/textpages/#citation","text":"","title":"Citation"},{"location":"elements/textpages/#elem-cite-slider","text":"At the bottom-right corner of the page is a slider control from where the user can pick urls for citation. Which urls are shown is dependent on the contents of the page. code type associated names CSS #citeh code {share}","title":"elem-cite-slider"},{"location":"elements/wordspage/","text":"Words pages \u00b6 The words pages are the entrance to the lexicon. You get there from the Words menu in the navigation bar. Or when you click on a word item in the sidebar of a text page. Here is a schematic overview: =========================================================== |navigation bar with menus login | |all: Text Word Queries Notes | =========================================================== ============================ ============================ |version controls theLetter| |word word word word word | |Aramaic Hebrew stats | |word word word word word | |letter letter | |word word word word word | |letter letter | |word word word word word | |letter letter | |word word word word word | |letter letter | |word word word word word | |letter letter | |word word word word word | |letter letter | |word word word word word | |letter letter | |word word word word word | ============================ |word word word word word | |word word word word word | |word word word word word | |word word word word word | |word word word word word | |word word word word word | |word word word word word | ============================","title":"Words pages"},{"location":"elements/wordspage/#words-pages","text":"The words pages are the entrance to the lexicon. You get there from the Words menu in the navigation bar. Or when you click on a word item in the sidebar of a text page. Here is a schematic overview: =========================================================== |navigation bar with menus login | |all: Text Word Queries Notes | =========================================================== ============================ ============================ |version controls theLetter| |word word word word word | |Aramaic Hebrew stats | |word word word word word | |letter letter | |word word word word word | |letter letter | |word word word word word | |letter letter | |word word word word word | |letter letter | |word word word word word | |letter letter | |word word word word word | |letter letter | |word word word word word | |letter letter | |word word word word word | ============================ |word word word word word | |word word word word word | |word word word word word | |word word word word word | |word word word word word | |word word word word word | |word word word word word | ============================","title":"Words pages"},{"location":"server/","text":"Server \u00b6 This is the part of SHEBANQ that works on the server. It consists of controllers that are triggered by urls. The actual work of the controllers is implemented in the modules . The result of that work is data, in the form of dictionaries. These dictionaries are fed into views , which are chunks of HTML with placeholders that are filled by the key value pairs in the dictionary. For every controller function like def xxx(): produce a dictionary there is a view with the same name: xxx.html , in which the result of xxx() will be filled in. Not strict There might be more functions in a controller file than are controllers: auxiliary functions are allowed. There might be more html files in the views directory than are proper views: views may include sub views.","title":"Server"},{"location":"server/#server","text":"This is the part of SHEBANQ that works on the server. It consists of controllers that are triggered by urls. The actual work of the controllers is implemented in the modules . The result of that work is data, in the form of dictionaries. These dictionaries are fed into views , which are chunks of HTML with placeholders that are filled by the key value pairs in the dictionary. For every controller function like def xxx(): produce a dictionary there is a view with the same name: xxx.html , in which the result of xxx() will be filled in. Not strict There might be more functions in a controller file than are controllers: auxiliary functions are allowed. There might be more html files in the views directory than are proper views: views may include sub views.","title":"Server"},{"location":"server/controllers/","text":"Controllers \u00b6 The controllers can be grouped as follows. Default \u00b6 controllers.default \u00b6 EXPIRE \u00b6 auth \u00b6 cache \u00b6 Dummy \u00b6 action ( self ) \u00b6 Source code in controllers/default.py def action ( self ): return lambda f : f requires_signature ( self ) \u00b6 Source code in controllers/default.py def requires_signature ( self ): return lambda f : f index () \u00b6 Serves the home page. Corresponds with the SHEBANQ logo in the navigation bar. Source code in controllers/default.py def index (): \"\"\"Serves the **home** page. Corresponds with the SHEBANQ logo in the navigation bar. \"\"\" session . forget ( response ) response . title = T ( \"SHEBANQ\" ) response . subtitle = T ( \"Query the Hebrew Bible through the BHSA database\" ) return dict () user () \u00b6 Unchanged from web2py. exposes: http://..../[app]/default/user/login http://..../[app]/default/user/logout http://..../[app]/default/user/register http://..../[app]/default/user/profile http://..../[app]/default/user/retrieve_password http://..../[app]/default/user/change_password http://..../[app]/default/user/manage_users (requires membership in use @auth.requires_login() @auth.requires_membership('group name') @auth.requires_permission('read','table name',record_id) to decorate functions that need access control Source code in controllers/default.py def user (): \"\"\"Unchanged from web2py. ``` exposes: http://..../[app]/default/user/login http://..../[app]/default/user/logout http://..../[app]/default/user/register http://..../[app]/default/user/profile http://..../[app]/default/user/retrieve_password http://..../[app]/default/user/change_password http://..../[app]/default/user/manage_users (requires membership in use @auth.requires_login() @auth.requires_membership('group name') @auth.requires_permission('read','table name',record_id) to decorate functions that need access control ``` \"\"\" response . title = T ( \"User Profile\" ) return dict ( form = auth ()) download () \u00b6 Unchanged from web2py. allows downloading of uploaded files http://..../[app]/default/download/[filename] Source code in controllers/default.py @cache . action () def download (): \"\"\"Unchanged from web2py. ``` allows downloading of uploaded files http://..../[app]/default/download/[filename] ``` \"\"\" return response . download ( request , db ) call () \u00b6 Unchanged from web2py. exposes services. for example: http://..../[app]/default/call/jsonrpc decorate with @services.jsonrpc the functions to expose supports xml, json, xmlrpc, jsonrpc, amfrpc, rss, csv Source code in controllers/default.py def call (): \"\"\"Unchanged from web2py. ``` exposes services. for example: http://..../[app]/default/call/jsonrpc decorate with @services.jsonrpc the functions to expose supports xml, json, xmlrpc, jsonrpc, amfrpc, rss, csv ``` \"\"\" return service () # noqa F821 data () \u00b6 Unchanged from web2py. http://..../[app]/default/data/tables http://..../[app]/default/data/create/[table] http://..../[app]/default/data/read/[table]/[id] http://..../[app]/default/data/update/[table]/[id] http://..../[app]/default/data/delete/[table]/[id] http://..../[app]/default/data/select/[table] http://..../[app]/default/data/search/[table] but URLs must be signed, i.e. linked with A('table',_href=URL('data/tables',user_signature=True)) or with the signed load operator LOAD('default','data.load',args='tables',ajax=True,user_signature=True) Source code in controllers/default.py @auth . requires_signature () def data (): \"\"\"Unchanged from web2py. ``` http://..../[app]/default/data/tables http://..../[app]/default/data/create/[table] http://..../[app]/default/data/read/[table]/[id] http://..../[app]/default/data/update/[table]/[id] http://..../[app]/default/data/delete/[table]/[id] http://..../[app]/default/data/select/[table] http://..../[app]/default/data/search/[table] but URLs must be signed, i.e. linked with A('table',_href=URL('data/tables',user_signature=True)) or with the signed load operator LOAD('default','data.load',args='tables',ajax=True,user_signature=True) ``` \"\"\" return dict ( form = crud ()) # noqa F821 Feed \u00b6 controllers.feed \u00b6 atom () \u00b6 Serves an RSS feed of recently saved shared queries. See also M:QUERYRECENT . Source code in controllers/feed.py def atom (): \"\"\"Serves an RSS feed of recently saved shared queries. See also [M:QUERYRECENT][queryrecent.QUERYRECENT]. \"\"\" session . forget ( response ) U = Urls () QueryRecent = QUERYRECENT () queries = QueryRecent . feed () icon = URL ( \"static\" , \"images/shebanq_logo_xxsmall.png\" , host = True ) cover = URL ( \"static\" , \"images/shebanq_cover.png\" , host = True ) base = URL ( \"xxx\" , \"yyy\" , host = True , extension = \"\" )[ 0 : - 8 ] feed = URL ( \"feed\" , \"atom\" , host = True , extension = \"\" ) xml = [] xml . append ( \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?> \"\"\" ) xml . append ( dedent ( \"\"\" <feed xmlns=\"http://www.w3.org/2005/Atom\" xmlns:webfeeds=\"http://webfeeds.org/rss/1.0\" > \"\"\" ) ) xml . append ( dedent ( f \"\"\" <title>SHEBANQ</title> <subtitle>Shared queries, recently executed</subtitle> <link href=\" { hEsc ( feed ) } \" rel=\"self\" title=\"SHEBANQ - Shared Queries\" type=\"application/atom+xml\"/> <link href=\" { hEsc ( base ) } \" rel=\"alternate\" type=\"text/html\"/> <id> { hEsc ( base + \"/hebrew/queries\" ) } </id> <updated> { isodt () } </updated> <category term=\"bible study\"/> <category term=\"biblical studies\"/> <category term=\"text\"/> <category term=\"linguistic\"/> <category term=\"hebrew\"/> <category term=\"bible\"/> <category term=\"query\"/> <category term=\"database\"/> <category term=\"research\"/> <category term=\"scholar\"/> <category term=\"annotation\"/> <category term=\"digital bible\"/> <category term=\"digital\"/> <category term=\"religion\"/> <category term=\"theology\"/> <icon> { hEsc ( icon ) } </icon> <webfeeds:icon> { hEsc ( icon ) } </webfeeds:icon> <logo> { hEsc ( cover ) } </logo> <webfeeds:cover image=\" { hEsc ( cover ) } \"/> <webfeeds:accentColor>DDBB00</webfeeds:accentColor> \"\"\" ) ) for ( query_id , first_name , last_name , query_name , description , qvid , qexe , qver , ) in queries : descHtml = U . specialLinks ( sanitize ( markdown ( hEsc ( description or \"No description given\" ), output_format = \"xhtml5\" ) ) ) # we add a standard cover image if the description does not contain any image standardImage = ( f \"\"\"<p><img src=\" { cover } \"/></p>\"\"\" if \"<img \" not in descHtml else \"\" ) href = hEsc ( URL ( \"hebrew\" , \"query\" , vars = dict ( id = query_id , version = qver ), host = True , extension = \"\" , ) ) tag = f \"tag:shebanq.ancient-data.org,2016-01-01: { query_id } / { qvid } / { qver } \" name = hEsc ( f \" { first_name } { last_name } \" ) xml . append ( dedent ( f \"\"\" <entry> <title> { hEsc ( query_name ) } </title> <link href=\" { href } \" rel=\"alternate\" type=\"text/html\"/> <id> { tag } </id> <updated> { isodt ( qexe ) } </updated> <category term=\"query\"/> <content type=\"xhtml\"> <div xmlns=\"http://www.w3.org/1999/xhtml\"> { standardImage } { descHtml } </div> </content> <author><name> { name } </name></author> </entry> \"\"\" ) ) xml . append ( dedent ( \"\"\" </feed> \"\"\" ) ) return dict ( xml = \"\" . join ( xml )) Hebrew \u00b6 In hebrew.py . The significant controllers are all here. Their bodies are very short, because they all call a function from the modules, which does all the work. The modules are individually documented by docstrings in the code. controllers.hebrew \u00b6 init () \u00b6 Source code in controllers/hebrew.py def init (): QueryChapter = QUERYCHAPTER () QueryChapter . makeQCindexes () books () \u00b6 Get all bible book names in all their translations. See also M:BOOKS.getNames . See \u2208 language-info . Source code in controllers/hebrew.py def books (): \"\"\"Get all bible book names in all their translations. See also [M:BOOKS.getNames][books.BOOKS.getNames]. See [\u2208 language-info][elem-language-info]. \"\"\" Books = BOOKS () session . forget ( response ) return Books . getNames () text () \u00b6 Serves a text page. Corresponds with Text in the menu bar. Only the skeleton of the page is fetched. See also M:VIEWSETTINGS.page . Source code in controllers/hebrew.py def text (): \"\"\"Serves a **text** page. Corresponds with `Text` in the menu bar. Only the skeleton of the page is fetched. See also [M:VIEWSETTINGS.page][viewsettings.VIEWSETTINGS.page]. \"\"\" session . forget ( response ) init () Books = BOOKS () ViewSettings = VIEWSETTINGS ( Books ) ViewSettings . initState () return ViewSettings . page () words () \u00b6 Serves words overview pages. Corresponds with Words in the menu bar. The words are fetched in pages off all words starting with the same letter. Source code in controllers/hebrew.py def words (): \"\"\"Serves **words** overview pages. Corresponds with `Words` in the menu bar. The words are fetched in pages off all words starting with the same letter. \"\"\" session . forget ( response ) init () Books = BOOKS () ViewSettings = VIEWSETTINGS ( Books ) ViewSettings . initState () Word = WORD () return Word . page ( ViewSettings ) queries () \u00b6 Serves the queries overview page. Corresponds with Queries in the menu bar. The main part is the tree of queries. There is also a widget with recent queries and a control to add new queries. Source code in controllers/hebrew.py def queries (): \"\"\"Serves the **queries** overview page. Corresponds with `Queries` in the menu bar. The main part is the tree of queries. There is also a widget with recent queries and a control to add new queries. \"\"\" session . forget ( response ) init () Books = BOOKS () ViewSettings = VIEWSETTINGS ( Books ) ViewSettings . initState () Query = QUERY () return Query . page ( ViewSettings ) notes () \u00b6 Serves the notes overview page. Corresponds with Notes in the menu bar. The main part is the tree of note sets. There is also a widget for bulk uploading sets of notes. Source code in controllers/hebrew.py def notes (): \"\"\"Serves the **notes** overview page. Corresponds with `Notes` in the menu bar. The main part is the tree of note sets. There is also a widget for bulk uploading sets of notes. \"\"\" session . forget ( response ) init () Books = BOOKS () ViewSettings = VIEWSETTINGS ( Books ) ViewSettings . initState () Note = NOTE ( Books ) return Note . page ( ViewSettings ) word () \u00b6 Serves a word record page. Usually an overview page or from a shared link. The page consists of a sidebar with the details of the word, and the main area displays the occurrences. Source code in controllers/hebrew.py def word (): \"\"\"Serves a *word* **record** page. Usually an overview page or from a shared link. The page consists of a sidebar with the details of the word, and the main area displays the occurrences. \"\"\" session . forget ( response ) request . vars [ \"mr\" ] = \"r\" request . vars [ \"qw\" ] = \"w\" request . vars [ \"page\" ] = 1 return text () query () \u00b6 Serves a query record page. Usually an overview page or from a shared link. The page consists of a sidebar with the details of the query, and the main area displays the results. Source code in controllers/hebrew.py def query (): \"\"\"Serves a *query* **record** page. Usually an overview page or from a shared link. The page consists of a sidebar with the details of the query, and the main area displays the results. \"\"\" session . forget ( response ) request . vars [ \"mr\" ] = \"r\" request . vars [ \"qw\" ] = \"q\" if request . extension == \"json\" : Query = QUERY () return Query . bodyJson () else : request . vars [ \"page\" ] = 1 return text () note () \u00b6 Serves a notes set record page. Usually from an overview page or a shared link. The page consists of a sidebar with the details of the notes set, and the main area displays the notes between the verses. Source code in controllers/hebrew.py def note (): \"\"\"Serves a *notes set* **record** page. Usually from an overview page or a shared link. The page consists of a sidebar with the details of the notes set, and the main area displays the notes between the verses. \"\"\" session . forget ( response ) request . vars [ \"mr\" ] = \"r\" request . vars [ \"qw\" ] = \"n\" request . vars [ \"page\" ] = 1 return text () material () \u00b6 Serves AJAX call for HTML content for the main area. Client code: {material.fetch} . Source code in controllers/hebrew.py def material (): \"\"\"Serves AJAX call for HTML content for the main area. Client code: [{material.fetch}][materialfetch]. \"\"\" session . forget ( response ) Books = BOOKS () Word = WORD () Query = QUERY () Note = NOTE ( Books ) RecordQuery = RECORDQUERY ( Query ) Material = MATERIAL ( RecordQuery , Word , Query , Note ) return Material . page () verse () \u00b6 Get the linguistic data of a verse. See also M:VERSE.get . Client code: {material.addverserefs} . Source code in controllers/hebrew.py def verse (): \"\"\"Get the linguistic data of a verse. See also [M:VERSE.get][verse.VERSE.get]. Client code: [{material.addverserefs}][materialaddverserefs]. \"\"\" session . forget ( response ) Verse = VERSE () return Verse . get () sidematerial () \u00b6 Serves AJAX call for HTML content for the sidebar ( material page). Client code: {sidecontent.fetch} . Source code in controllers/hebrew.py def sidematerial (): \"\"\"Serves AJAX call for HTML content for the sidebar (**material** page). Client code: [{sidecontent.fetch}][sidecontentfetch]. \"\"\" session . forget ( response ) Books = BOOKS () Word = WORD () Query = QUERY () Note = NOTE ( Books ) RecordQuery = RECORDQUERY ( Query ) Material = MATERIAL ( RecordQuery , Word , Query , Note ) Side = SIDE ( Material , Word , Query , Note ) return Side . page () sideword () \u00b6 Serves AJAX call for HTML content for the sidebar ( word record page). Used when the user is switching between material and record pages. See also M:RECORD.body . Client code: {sidecontent.fetch} . Source code in controllers/hebrew.py def sideword (): \"\"\"Serves AJAX call for HTML content for the sidebar (*word* **record** page). Used when the user is switching between **material** and **record** pages. See also [M:RECORD.body][record.RECORD.body]. Client code: [{sidecontent.fetch}][sidecontentfetch]. \"\"\" session . forget ( response ) Record = RECORD () return Record . body () sidequery () \u00b6 Serves AJAX call for HTML content for the sidebar ( query record page). Used when the user is switching between material and record pages. See also M:RECORD.body . Client code: {sidecontent.fetch} . Source code in controllers/hebrew.py def sidequery (): \"\"\"Serves AJAX call for HTML content for the sidebar (*query* **record** page). Used when the user is switching between **material** and **record** pages. See also [M:RECORD.body][record.RECORD.body]. Client code: [{sidecontent.fetch}][sidecontentfetch]. \"\"\" session . forget ( response ) Record = RECORD () return Record . body () sidenote () \u00b6 Serves AJAX call for HTML content for the sidebar ( note set record page). Used when the user is switching between material and record pages. See also M:RECORD.body . Client code: {sidecontent.fetch} . Source code in controllers/hebrew.py def sidenote (): \"\"\"Serves AJAX call for HTML content for the sidebar (*note set* **record** page). Used when the user is switching between **material** and **record** pages. See also [M:RECORD.body][record.RECORD.body]. Client code: [{sidecontent.fetch}][sidecontentfetch]. \"\"\" session . forget ( response ) Record = RECORD () return Record . body () sidewordbody () \u00b6 Serves AJAX call for HTML content for the sidebar ( word record page). Used when the user is loading word page directly. See also M:WORD.body . Source code in controllers/hebrew.py def sidewordbody (): \"\"\"Serves AJAX call for HTML content for the sidebar (*word* **record** page). Used when the user is loading *word* page directly. See also [M:WORD.body][word.WORD.body]. \"\"\" session . forget ( response ) if not request . ajax : redirect ( URL ( \"hebrew\" , \"word\" , extension = \"\" , vars = request . vars )) Word = WORD () return Word . body () sidequerybody () \u00b6 Serves AJAX call for HTML content for the sidebar ( query record page). Used when the user is loading a query page directly. See also M:QUERY.body . Source code in controllers/hebrew.py def sidequerybody (): \"\"\"Serves AJAX call for HTML content for the sidebar (*query* **record** page). Used when the user is loading a *query* page directly. See also [M:QUERY.body][query.QUERY.body]. \"\"\" session . forget ( response ) if not request . ajax : redirect ( URL ( \"hebrew\" , \"query\" , extension = \"\" , vars = request . vars )) Query = QUERY () return Query . body () sidenotebody () \u00b6 Serves AJAX call for HTML content for the sidebar ( notes set record page). Used when the user is loading a notes set page directly. See also M:NOTE.body . Source code in controllers/hebrew.py def sidenotebody (): \"\"\"Serves AJAX call for HTML content for the sidebar (*notes set* **record** page). Used when the user is loading a *notes set* page directly. See also [M:NOTE.body][note.NOTE.body]. \"\"\" session . forget ( response ) if not request . ajax : redirect ( URL ( \"hebrew\" , \"note\" , extension = \"\" , vars = request . vars )) Books = BOOKS () Note = NOTE ( Books ) return Note . body () queriesr () \u00b6 Serves AJAX call for json data for recently saved shared queries. See also [queryrecent.QUERYRECENT.recent]. Client code: {queryrecent.fetch} Source code in controllers/hebrew.py def queriesr (): \"\"\"Serves AJAX call for json data for recently saved shared queries. See also [queryrecent.QUERYRECENT.recent]. Client code: [{queryrecent.fetch}][queryrecentfetch] \"\"\" session . forget ( response ) QueryRecent = QUERYRECENT () return QueryRecent . recent () querytree () \u00b6 Serves AJAX call for json data for the tree overview of queries. See also M:QUERYTREE.get . Client code: {querytree.Tree} Source code in controllers/hebrew.py def querytree (): \"\"\"Serves AJAX call for json data for the tree overview of queries. See also [M:QUERYTREE.get][querytree.QUERYTREE.get]. Client code: [{querytree.Tree}][querytreetree] \"\"\" session . forget ( response ) QueryTree = QUERYTREE () return QueryTree . get () notetree () \u00b6 Serves AJAX call for json data for the tree overview of notes sets. See also M:NOTETREE.get . Client code: {notetree.Tree} Source code in controllers/hebrew.py def notetree (): \"\"\"Serves AJAX call for json data for the tree overview of notes sets. See also [M:NOTETREE.get][notetree.NOTETREE.get]. Client code: [{notetree.Tree}][notetreetree] \"\"\" session . forget ( response ) NoteTree = NOTETREE () return NoteTree . get () getversenotes () \u00b6 Serves AJAX call for json data for all notes belonging to a single verse. See also M:NOTE.getVerseNotes . Client code: {noteverse.fetch} Source code in controllers/hebrew.py def getversenotes (): \"\"\"Serves AJAX call for json data for all notes belonging to a single verse. See also [M:NOTE.getVerseNotes][note.NOTE.getVerseNotes]. Client code: [{noteverse.fetch}][noteversefetch] \"\"\" session . forget ( response ) Books = BOOKS () Note = NOTE ( Books ) return Note . getVerseNotes () putversenotes () \u00b6 Serves AJAX call for json data to save notes. See also M:NOTESAVE.putVerseNotes . Client code: {noteverse.sendnotes} Source code in controllers/hebrew.py def putversenotes (): \"\"\"Serves AJAX call for json data to save notes. See also [M:NOTESAVE.putVerseNotes][notesave.NOTESAVE.putVerseNotes]. Client code: [{noteverse.sendnotes}][noteversesendnotes] \"\"\" session . forget ( response ) Books = BOOKS () Note = NOTE ( Books ) NoteSave = NOTESAVE ( Note ) return NoteSave . putVerseNotes () noteupload () \u00b6 Receives bulk-uploaded notes and stores them. See also M:NOTESUPLOAD.upload . Client code: {notetree.Upload.submit} . Source code in controllers/hebrew.py def noteupload (): \"\"\"Receives bulk-uploaded notes and stores them. See also [M:NOTESUPLOAD.upload][notesupload.NOTESUPLOAD.upload]. Client code: [{notetree.Upload.submit}][uploadsubmit]. \"\"\" session . forget ( response ) Books = BOOKS () Note = NOTE ( Books ) NotesUpload = NOTESUPLOAD ( Books , Note ) return NotesUpload . upload () item () \u00b6 Get csv data of the items associated with a record. Items are: the occurrences of a word, the results of a query, the notes of a notes set. See also M:CSVDATA.page . Client code: {viewstate.csvUrl} . Source code in controllers/hebrew.py def item (): \"\"\"Get csv data of the items associated with a record. Items are: the occurrences of a word, the results of a query, the notes of a notes set. See also [M:CSVDATA.page][csvdata.CSVDATA.page]. Client code: [{viewstate.csvUrl}][viewstatecsvurl]. \"\"\" session . forget ( response ) Word = WORD () Query = QUERY () RecordQuery = RECORDQUERY ( Query ) CsvData = CSVDATA ( RecordQuery , Word , Query ) return CsvData . page () chart () \u00b6 Get a heat map of the items associated to a record. Items are: the occurrences of a word, the results of a query, the notes of a notes set. See also M:CHART.page . Client code: {chart.fetch} . Source code in controllers/hebrew.py def chart (): # controller to produce a chart of query results or lexeme occurrences \"\"\"Get a heat map of the items associated to a record. Items are: the occurrences of a word, the results of a query, the notes of a notes set. See also [M:CHART.page][chart.CHART.page]. Client code: [{chart.fetch}][chartfetch]. \"\"\" session . forget ( response ) Books = BOOKS () Word = WORD () Query = QUERY () Note = NOTE ( Books ) RecordQuery = RECORDQUERY ( Query ) Chart = CHART ( Books , RecordQuery , Word , Query , Note ) return Chart . page () itemrecord () \u00b6 Saves a record to the database, typically organizations, projects, queries. See also M:RECORD.setItem . Client code: {querytree.Tree.record} . Source code in controllers/hebrew.py def itemrecord (): \"\"\"Saves a record to the database, typically organizations, projects, queries. See also [M:RECORD.setItem][record.RECORD.setItem]. Client code: [{querytree.Tree.record}][treerecord]. \"\"\" session . forget ( response ) Query = QUERY () RecordQuery = RECORDQUERY ( Query ) return RecordQuery . setItem () querysharing () \u00b6 Saves the shared status of a query to the database. See also M:QUERYSAVE.sharing . Client code: {sidecontent.sendval} . Source code in controllers/hebrew.py def querysharing (): \"\"\"Saves the shared status of a query to the database. See also [M:QUERYSAVE.sharing][querysave.QUERYSAVE.sharing]. Client code: [{sidecontent.sendval}][sidecontentsendval]. \"\"\" session . forget ( response ) Query = QUERY () QueryChapter = QUERYCHAPTER () QuerySave = QUERYSAVE ( Query , QueryChapter ) return QuerySave . sharing () queryupdate () \u00b6 Saves metadata of a query to the database. See also M:QUERYSAVE.putRecord . Client code: {sidecontent.sendvals} . Source code in controllers/hebrew.py def queryupdate (): \"\"\"Saves metadata of a query to the database. See also [M:QUERYSAVE.putRecord][querysave.QUERYSAVE.putRecord]. Client code: [{sidecontent.sendvals}][sidecontentsendvals]. \"\"\" session . forget ( response ) Query = QUERY () QueryChapter = QUERYCHAPTER () QuerySave = QUERYSAVE ( Query , QueryChapter ) return QuerySave . putRecord ()","title":"Controllers"},{"location":"server/controllers/#controllers","text":"The controllers can be grouped as follows.","title":"Controllers"},{"location":"server/controllers/#default","text":"","title":"Default"},{"location":"server/controllers/#controllers.default","text":"","title":"default"},{"location":"server/controllers/#controllers.default.EXPIRE","text":"","title":"EXPIRE"},{"location":"server/controllers/#controllers.default.auth","text":"","title":"auth"},{"location":"server/controllers/#controllers.default.cache","text":"","title":"cache"},{"location":"server/controllers/#controllers.default.Dummy","text":"","title":"Dummy"},{"location":"server/controllers/#controllers.default.Dummy.action","text":"Source code in controllers/default.py def action ( self ): return lambda f : f","title":"action()"},{"location":"server/controllers/#controllers.default.Dummy.requires_signature","text":"Source code in controllers/default.py def requires_signature ( self ): return lambda f : f","title":"requires_signature()"},{"location":"server/controllers/#controllers.default.index","text":"Serves the home page. Corresponds with the SHEBANQ logo in the navigation bar. Source code in controllers/default.py def index (): \"\"\"Serves the **home** page. Corresponds with the SHEBANQ logo in the navigation bar. \"\"\" session . forget ( response ) response . title = T ( \"SHEBANQ\" ) response . subtitle = T ( \"Query the Hebrew Bible through the BHSA database\" ) return dict ()","title":"index()"},{"location":"server/controllers/#controllers.default.user","text":"Unchanged from web2py. exposes: http://..../[app]/default/user/login http://..../[app]/default/user/logout http://..../[app]/default/user/register http://..../[app]/default/user/profile http://..../[app]/default/user/retrieve_password http://..../[app]/default/user/change_password http://..../[app]/default/user/manage_users (requires membership in use @auth.requires_login() @auth.requires_membership('group name') @auth.requires_permission('read','table name',record_id) to decorate functions that need access control Source code in controllers/default.py def user (): \"\"\"Unchanged from web2py. ``` exposes: http://..../[app]/default/user/login http://..../[app]/default/user/logout http://..../[app]/default/user/register http://..../[app]/default/user/profile http://..../[app]/default/user/retrieve_password http://..../[app]/default/user/change_password http://..../[app]/default/user/manage_users (requires membership in use @auth.requires_login() @auth.requires_membership('group name') @auth.requires_permission('read','table name',record_id) to decorate functions that need access control ``` \"\"\" response . title = T ( \"User Profile\" ) return dict ( form = auth ())","title":"user()"},{"location":"server/controllers/#controllers.default.download","text":"Unchanged from web2py. allows downloading of uploaded files http://..../[app]/default/download/[filename] Source code in controllers/default.py @cache . action () def download (): \"\"\"Unchanged from web2py. ``` allows downloading of uploaded files http://..../[app]/default/download/[filename] ``` \"\"\" return response . download ( request , db )","title":"download()"},{"location":"server/controllers/#controllers.default.call","text":"Unchanged from web2py. exposes services. for example: http://..../[app]/default/call/jsonrpc decorate with @services.jsonrpc the functions to expose supports xml, json, xmlrpc, jsonrpc, amfrpc, rss, csv Source code in controllers/default.py def call (): \"\"\"Unchanged from web2py. ``` exposes services. for example: http://..../[app]/default/call/jsonrpc decorate with @services.jsonrpc the functions to expose supports xml, json, xmlrpc, jsonrpc, amfrpc, rss, csv ``` \"\"\" return service () # noqa F821","title":"call()"},{"location":"server/controllers/#controllers.default.data","text":"Unchanged from web2py. http://..../[app]/default/data/tables http://..../[app]/default/data/create/[table] http://..../[app]/default/data/read/[table]/[id] http://..../[app]/default/data/update/[table]/[id] http://..../[app]/default/data/delete/[table]/[id] http://..../[app]/default/data/select/[table] http://..../[app]/default/data/search/[table] but URLs must be signed, i.e. linked with A('table',_href=URL('data/tables',user_signature=True)) or with the signed load operator LOAD('default','data.load',args='tables',ajax=True,user_signature=True) Source code in controllers/default.py @auth . requires_signature () def data (): \"\"\"Unchanged from web2py. ``` http://..../[app]/default/data/tables http://..../[app]/default/data/create/[table] http://..../[app]/default/data/read/[table]/[id] http://..../[app]/default/data/update/[table]/[id] http://..../[app]/default/data/delete/[table]/[id] http://..../[app]/default/data/select/[table] http://..../[app]/default/data/search/[table] but URLs must be signed, i.e. linked with A('table',_href=URL('data/tables',user_signature=True)) or with the signed load operator LOAD('default','data.load',args='tables',ajax=True,user_signature=True) ``` \"\"\" return dict ( form = crud ()) # noqa F821","title":"data()"},{"location":"server/controllers/#feed","text":"","title":"Feed"},{"location":"server/controllers/#controllers.feed","text":"","title":"feed"},{"location":"server/controllers/#controllers.feed.atom","text":"Serves an RSS feed of recently saved shared queries. See also M:QUERYRECENT . Source code in controllers/feed.py def atom (): \"\"\"Serves an RSS feed of recently saved shared queries. See also [M:QUERYRECENT][queryrecent.QUERYRECENT]. \"\"\" session . forget ( response ) U = Urls () QueryRecent = QUERYRECENT () queries = QueryRecent . feed () icon = URL ( \"static\" , \"images/shebanq_logo_xxsmall.png\" , host = True ) cover = URL ( \"static\" , \"images/shebanq_cover.png\" , host = True ) base = URL ( \"xxx\" , \"yyy\" , host = True , extension = \"\" )[ 0 : - 8 ] feed = URL ( \"feed\" , \"atom\" , host = True , extension = \"\" ) xml = [] xml . append ( \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?> \"\"\" ) xml . append ( dedent ( \"\"\" <feed xmlns=\"http://www.w3.org/2005/Atom\" xmlns:webfeeds=\"http://webfeeds.org/rss/1.0\" > \"\"\" ) ) xml . append ( dedent ( f \"\"\" <title>SHEBANQ</title> <subtitle>Shared queries, recently executed</subtitle> <link href=\" { hEsc ( feed ) } \" rel=\"self\" title=\"SHEBANQ - Shared Queries\" type=\"application/atom+xml\"/> <link href=\" { hEsc ( base ) } \" rel=\"alternate\" type=\"text/html\"/> <id> { hEsc ( base + \"/hebrew/queries\" ) } </id> <updated> { isodt () } </updated> <category term=\"bible study\"/> <category term=\"biblical studies\"/> <category term=\"text\"/> <category term=\"linguistic\"/> <category term=\"hebrew\"/> <category term=\"bible\"/> <category term=\"query\"/> <category term=\"database\"/> <category term=\"research\"/> <category term=\"scholar\"/> <category term=\"annotation\"/> <category term=\"digital bible\"/> <category term=\"digital\"/> <category term=\"religion\"/> <category term=\"theology\"/> <icon> { hEsc ( icon ) } </icon> <webfeeds:icon> { hEsc ( icon ) } </webfeeds:icon> <logo> { hEsc ( cover ) } </logo> <webfeeds:cover image=\" { hEsc ( cover ) } \"/> <webfeeds:accentColor>DDBB00</webfeeds:accentColor> \"\"\" ) ) for ( query_id , first_name , last_name , query_name , description , qvid , qexe , qver , ) in queries : descHtml = U . specialLinks ( sanitize ( markdown ( hEsc ( description or \"No description given\" ), output_format = \"xhtml5\" ) ) ) # we add a standard cover image if the description does not contain any image standardImage = ( f \"\"\"<p><img src=\" { cover } \"/></p>\"\"\" if \"<img \" not in descHtml else \"\" ) href = hEsc ( URL ( \"hebrew\" , \"query\" , vars = dict ( id = query_id , version = qver ), host = True , extension = \"\" , ) ) tag = f \"tag:shebanq.ancient-data.org,2016-01-01: { query_id } / { qvid } / { qver } \" name = hEsc ( f \" { first_name } { last_name } \" ) xml . append ( dedent ( f \"\"\" <entry> <title> { hEsc ( query_name ) } </title> <link href=\" { href } \" rel=\"alternate\" type=\"text/html\"/> <id> { tag } </id> <updated> { isodt ( qexe ) } </updated> <category term=\"query\"/> <content type=\"xhtml\"> <div xmlns=\"http://www.w3.org/1999/xhtml\"> { standardImage } { descHtml } </div> </content> <author><name> { name } </name></author> </entry> \"\"\" ) ) xml . append ( dedent ( \"\"\" </feed> \"\"\" ) ) return dict ( xml = \"\" . join ( xml ))","title":"atom()"},{"location":"server/controllers/#hebrew","text":"In hebrew.py . The significant controllers are all here. Their bodies are very short, because they all call a function from the modules, which does all the work. The modules are individually documented by docstrings in the code.","title":"Hebrew"},{"location":"server/controllers/#controllers.hebrew","text":"","title":"hebrew"},{"location":"server/controllers/#controllers.hebrew.init","text":"Source code in controllers/hebrew.py def init (): QueryChapter = QUERYCHAPTER () QueryChapter . makeQCindexes ()","title":"init()"},{"location":"server/controllers/#controllers.hebrew.books","text":"Get all bible book names in all their translations. See also M:BOOKS.getNames . See \u2208 language-info . Source code in controllers/hebrew.py def books (): \"\"\"Get all bible book names in all their translations. See also [M:BOOKS.getNames][books.BOOKS.getNames]. See [\u2208 language-info][elem-language-info]. \"\"\" Books = BOOKS () session . forget ( response ) return Books . getNames ()","title":"books()"},{"location":"server/controllers/#controllers.hebrew.text","text":"Serves a text page. Corresponds with Text in the menu bar. Only the skeleton of the page is fetched. See also M:VIEWSETTINGS.page . Source code in controllers/hebrew.py def text (): \"\"\"Serves a **text** page. Corresponds with `Text` in the menu bar. Only the skeleton of the page is fetched. See also [M:VIEWSETTINGS.page][viewsettings.VIEWSETTINGS.page]. \"\"\" session . forget ( response ) init () Books = BOOKS () ViewSettings = VIEWSETTINGS ( Books ) ViewSettings . initState () return ViewSettings . page ()","title":"text()"},{"location":"server/controllers/#controllers.hebrew.words","text":"Serves words overview pages. Corresponds with Words in the menu bar. The words are fetched in pages off all words starting with the same letter. Source code in controllers/hebrew.py def words (): \"\"\"Serves **words** overview pages. Corresponds with `Words` in the menu bar. The words are fetched in pages off all words starting with the same letter. \"\"\" session . forget ( response ) init () Books = BOOKS () ViewSettings = VIEWSETTINGS ( Books ) ViewSettings . initState () Word = WORD () return Word . page ( ViewSettings )","title":"words()"},{"location":"server/controllers/#controllers.hebrew.queries","text":"Serves the queries overview page. Corresponds with Queries in the menu bar. The main part is the tree of queries. There is also a widget with recent queries and a control to add new queries. Source code in controllers/hebrew.py def queries (): \"\"\"Serves the **queries** overview page. Corresponds with `Queries` in the menu bar. The main part is the tree of queries. There is also a widget with recent queries and a control to add new queries. \"\"\" session . forget ( response ) init () Books = BOOKS () ViewSettings = VIEWSETTINGS ( Books ) ViewSettings . initState () Query = QUERY () return Query . page ( ViewSettings )","title":"queries()"},{"location":"server/controllers/#controllers.hebrew.notes","text":"Serves the notes overview page. Corresponds with Notes in the menu bar. The main part is the tree of note sets. There is also a widget for bulk uploading sets of notes. Source code in controllers/hebrew.py def notes (): \"\"\"Serves the **notes** overview page. Corresponds with `Notes` in the menu bar. The main part is the tree of note sets. There is also a widget for bulk uploading sets of notes. \"\"\" session . forget ( response ) init () Books = BOOKS () ViewSettings = VIEWSETTINGS ( Books ) ViewSettings . initState () Note = NOTE ( Books ) return Note . page ( ViewSettings )","title":"notes()"},{"location":"server/controllers/#controllers.hebrew.word","text":"Serves a word record page. Usually an overview page or from a shared link. The page consists of a sidebar with the details of the word, and the main area displays the occurrences. Source code in controllers/hebrew.py def word (): \"\"\"Serves a *word* **record** page. Usually an overview page or from a shared link. The page consists of a sidebar with the details of the word, and the main area displays the occurrences. \"\"\" session . forget ( response ) request . vars [ \"mr\" ] = \"r\" request . vars [ \"qw\" ] = \"w\" request . vars [ \"page\" ] = 1 return text ()","title":"word()"},{"location":"server/controllers/#controllers.hebrew.query","text":"Serves a query record page. Usually an overview page or from a shared link. The page consists of a sidebar with the details of the query, and the main area displays the results. Source code in controllers/hebrew.py def query (): \"\"\"Serves a *query* **record** page. Usually an overview page or from a shared link. The page consists of a sidebar with the details of the query, and the main area displays the results. \"\"\" session . forget ( response ) request . vars [ \"mr\" ] = \"r\" request . vars [ \"qw\" ] = \"q\" if request . extension == \"json\" : Query = QUERY () return Query . bodyJson () else : request . vars [ \"page\" ] = 1 return text ()","title":"query()"},{"location":"server/controllers/#controllers.hebrew.note","text":"Serves a notes set record page. Usually from an overview page or a shared link. The page consists of a sidebar with the details of the notes set, and the main area displays the notes between the verses. Source code in controllers/hebrew.py def note (): \"\"\"Serves a *notes set* **record** page. Usually from an overview page or a shared link. The page consists of a sidebar with the details of the notes set, and the main area displays the notes between the verses. \"\"\" session . forget ( response ) request . vars [ \"mr\" ] = \"r\" request . vars [ \"qw\" ] = \"n\" request . vars [ \"page\" ] = 1 return text ()","title":"note()"},{"location":"server/controllers/#controllers.hebrew.material","text":"Serves AJAX call for HTML content for the main area. Client code: {material.fetch} . Source code in controllers/hebrew.py def material (): \"\"\"Serves AJAX call for HTML content for the main area. Client code: [{material.fetch}][materialfetch]. \"\"\" session . forget ( response ) Books = BOOKS () Word = WORD () Query = QUERY () Note = NOTE ( Books ) RecordQuery = RECORDQUERY ( Query ) Material = MATERIAL ( RecordQuery , Word , Query , Note ) return Material . page ()","title":"material()"},{"location":"server/controllers/#controllers.hebrew.verse","text":"Get the linguistic data of a verse. See also M:VERSE.get . Client code: {material.addverserefs} . Source code in controllers/hebrew.py def verse (): \"\"\"Get the linguistic data of a verse. See also [M:VERSE.get][verse.VERSE.get]. Client code: [{material.addverserefs}][materialaddverserefs]. \"\"\" session . forget ( response ) Verse = VERSE () return Verse . get ()","title":"verse()"},{"location":"server/controllers/#controllers.hebrew.sidematerial","text":"Serves AJAX call for HTML content for the sidebar ( material page). Client code: {sidecontent.fetch} . Source code in controllers/hebrew.py def sidematerial (): \"\"\"Serves AJAX call for HTML content for the sidebar (**material** page). Client code: [{sidecontent.fetch}][sidecontentfetch]. \"\"\" session . forget ( response ) Books = BOOKS () Word = WORD () Query = QUERY () Note = NOTE ( Books ) RecordQuery = RECORDQUERY ( Query ) Material = MATERIAL ( RecordQuery , Word , Query , Note ) Side = SIDE ( Material , Word , Query , Note ) return Side . page ()","title":"sidematerial()"},{"location":"server/controllers/#controllers.hebrew.sideword","text":"Serves AJAX call for HTML content for the sidebar ( word record page). Used when the user is switching between material and record pages. See also M:RECORD.body . Client code: {sidecontent.fetch} . Source code in controllers/hebrew.py def sideword (): \"\"\"Serves AJAX call for HTML content for the sidebar (*word* **record** page). Used when the user is switching between **material** and **record** pages. See also [M:RECORD.body][record.RECORD.body]. Client code: [{sidecontent.fetch}][sidecontentfetch]. \"\"\" session . forget ( response ) Record = RECORD () return Record . body ()","title":"sideword()"},{"location":"server/controllers/#controllers.hebrew.sidequery","text":"Serves AJAX call for HTML content for the sidebar ( query record page). Used when the user is switching between material and record pages. See also M:RECORD.body . Client code: {sidecontent.fetch} . Source code in controllers/hebrew.py def sidequery (): \"\"\"Serves AJAX call for HTML content for the sidebar (*query* **record** page). Used when the user is switching between **material** and **record** pages. See also [M:RECORD.body][record.RECORD.body]. Client code: [{sidecontent.fetch}][sidecontentfetch]. \"\"\" session . forget ( response ) Record = RECORD () return Record . body ()","title":"sidequery()"},{"location":"server/controllers/#controllers.hebrew.sidenote","text":"Serves AJAX call for HTML content for the sidebar ( note set record page). Used when the user is switching between material and record pages. See also M:RECORD.body . Client code: {sidecontent.fetch} . Source code in controllers/hebrew.py def sidenote (): \"\"\"Serves AJAX call for HTML content for the sidebar (*note set* **record** page). Used when the user is switching between **material** and **record** pages. See also [M:RECORD.body][record.RECORD.body]. Client code: [{sidecontent.fetch}][sidecontentfetch]. \"\"\" session . forget ( response ) Record = RECORD () return Record . body ()","title":"sidenote()"},{"location":"server/controllers/#controllers.hebrew.sidewordbody","text":"Serves AJAX call for HTML content for the sidebar ( word record page). Used when the user is loading word page directly. See also M:WORD.body . Source code in controllers/hebrew.py def sidewordbody (): \"\"\"Serves AJAX call for HTML content for the sidebar (*word* **record** page). Used when the user is loading *word* page directly. See also [M:WORD.body][word.WORD.body]. \"\"\" session . forget ( response ) if not request . ajax : redirect ( URL ( \"hebrew\" , \"word\" , extension = \"\" , vars = request . vars )) Word = WORD () return Word . body ()","title":"sidewordbody()"},{"location":"server/controllers/#controllers.hebrew.sidequerybody","text":"Serves AJAX call for HTML content for the sidebar ( query record page). Used when the user is loading a query page directly. See also M:QUERY.body . Source code in controllers/hebrew.py def sidequerybody (): \"\"\"Serves AJAX call for HTML content for the sidebar (*query* **record** page). Used when the user is loading a *query* page directly. See also [M:QUERY.body][query.QUERY.body]. \"\"\" session . forget ( response ) if not request . ajax : redirect ( URL ( \"hebrew\" , \"query\" , extension = \"\" , vars = request . vars )) Query = QUERY () return Query . body ()","title":"sidequerybody()"},{"location":"server/controllers/#controllers.hebrew.sidenotebody","text":"Serves AJAX call for HTML content for the sidebar ( notes set record page). Used when the user is loading a notes set page directly. See also M:NOTE.body . Source code in controllers/hebrew.py def sidenotebody (): \"\"\"Serves AJAX call for HTML content for the sidebar (*notes set* **record** page). Used when the user is loading a *notes set* page directly. See also [M:NOTE.body][note.NOTE.body]. \"\"\" session . forget ( response ) if not request . ajax : redirect ( URL ( \"hebrew\" , \"note\" , extension = \"\" , vars = request . vars )) Books = BOOKS () Note = NOTE ( Books ) return Note . body ()","title":"sidenotebody()"},{"location":"server/controllers/#controllers.hebrew.queriesr","text":"Serves AJAX call for json data for recently saved shared queries. See also [queryrecent.QUERYRECENT.recent]. Client code: {queryrecent.fetch} Source code in controllers/hebrew.py def queriesr (): \"\"\"Serves AJAX call for json data for recently saved shared queries. See also [queryrecent.QUERYRECENT.recent]. Client code: [{queryrecent.fetch}][queryrecentfetch] \"\"\" session . forget ( response ) QueryRecent = QUERYRECENT () return QueryRecent . recent ()","title":"queriesr()"},{"location":"server/controllers/#controllers.hebrew.querytree","text":"Serves AJAX call for json data for the tree overview of queries. See also M:QUERYTREE.get . Client code: {querytree.Tree} Source code in controllers/hebrew.py def querytree (): \"\"\"Serves AJAX call for json data for the tree overview of queries. See also [M:QUERYTREE.get][querytree.QUERYTREE.get]. Client code: [{querytree.Tree}][querytreetree] \"\"\" session . forget ( response ) QueryTree = QUERYTREE () return QueryTree . get ()","title":"querytree()"},{"location":"server/controllers/#controllers.hebrew.notetree","text":"Serves AJAX call for json data for the tree overview of notes sets. See also M:NOTETREE.get . Client code: {notetree.Tree} Source code in controllers/hebrew.py def notetree (): \"\"\"Serves AJAX call for json data for the tree overview of notes sets. See also [M:NOTETREE.get][notetree.NOTETREE.get]. Client code: [{notetree.Tree}][notetreetree] \"\"\" session . forget ( response ) NoteTree = NOTETREE () return NoteTree . get ()","title":"notetree()"},{"location":"server/controllers/#controllers.hebrew.getversenotes","text":"Serves AJAX call for json data for all notes belonging to a single verse. See also M:NOTE.getVerseNotes . Client code: {noteverse.fetch} Source code in controllers/hebrew.py def getversenotes (): \"\"\"Serves AJAX call for json data for all notes belonging to a single verse. See also [M:NOTE.getVerseNotes][note.NOTE.getVerseNotes]. Client code: [{noteverse.fetch}][noteversefetch] \"\"\" session . forget ( response ) Books = BOOKS () Note = NOTE ( Books ) return Note . getVerseNotes ()","title":"getversenotes()"},{"location":"server/controllers/#controllers.hebrew.putversenotes","text":"Serves AJAX call for json data to save notes. See also M:NOTESAVE.putVerseNotes . Client code: {noteverse.sendnotes} Source code in controllers/hebrew.py def putversenotes (): \"\"\"Serves AJAX call for json data to save notes. See also [M:NOTESAVE.putVerseNotes][notesave.NOTESAVE.putVerseNotes]. Client code: [{noteverse.sendnotes}][noteversesendnotes] \"\"\" session . forget ( response ) Books = BOOKS () Note = NOTE ( Books ) NoteSave = NOTESAVE ( Note ) return NoteSave . putVerseNotes ()","title":"putversenotes()"},{"location":"server/controllers/#controllers.hebrew.noteupload","text":"Receives bulk-uploaded notes and stores them. See also M:NOTESUPLOAD.upload . Client code: {notetree.Upload.submit} . Source code in controllers/hebrew.py def noteupload (): \"\"\"Receives bulk-uploaded notes and stores them. See also [M:NOTESUPLOAD.upload][notesupload.NOTESUPLOAD.upload]. Client code: [{notetree.Upload.submit}][uploadsubmit]. \"\"\" session . forget ( response ) Books = BOOKS () Note = NOTE ( Books ) NotesUpload = NOTESUPLOAD ( Books , Note ) return NotesUpload . upload ()","title":"noteupload()"},{"location":"server/controllers/#controllers.hebrew.item","text":"Get csv data of the items associated with a record. Items are: the occurrences of a word, the results of a query, the notes of a notes set. See also M:CSVDATA.page . Client code: {viewstate.csvUrl} . Source code in controllers/hebrew.py def item (): \"\"\"Get csv data of the items associated with a record. Items are: the occurrences of a word, the results of a query, the notes of a notes set. See also [M:CSVDATA.page][csvdata.CSVDATA.page]. Client code: [{viewstate.csvUrl}][viewstatecsvurl]. \"\"\" session . forget ( response ) Word = WORD () Query = QUERY () RecordQuery = RECORDQUERY ( Query ) CsvData = CSVDATA ( RecordQuery , Word , Query ) return CsvData . page ()","title":"item()"},{"location":"server/controllers/#controllers.hebrew.chart","text":"Get a heat map of the items associated to a record. Items are: the occurrences of a word, the results of a query, the notes of a notes set. See also M:CHART.page . Client code: {chart.fetch} . Source code in controllers/hebrew.py def chart (): # controller to produce a chart of query results or lexeme occurrences \"\"\"Get a heat map of the items associated to a record. Items are: the occurrences of a word, the results of a query, the notes of a notes set. See also [M:CHART.page][chart.CHART.page]. Client code: [{chart.fetch}][chartfetch]. \"\"\" session . forget ( response ) Books = BOOKS () Word = WORD () Query = QUERY () Note = NOTE ( Books ) RecordQuery = RECORDQUERY ( Query ) Chart = CHART ( Books , RecordQuery , Word , Query , Note ) return Chart . page ()","title":"chart()"},{"location":"server/controllers/#controllers.hebrew.itemrecord","text":"Saves a record to the database, typically organizations, projects, queries. See also M:RECORD.setItem . Client code: {querytree.Tree.record} . Source code in controllers/hebrew.py def itemrecord (): \"\"\"Saves a record to the database, typically organizations, projects, queries. See also [M:RECORD.setItem][record.RECORD.setItem]. Client code: [{querytree.Tree.record}][treerecord]. \"\"\" session . forget ( response ) Query = QUERY () RecordQuery = RECORDQUERY ( Query ) return RecordQuery . setItem ()","title":"itemrecord()"},{"location":"server/controllers/#controllers.hebrew.querysharing","text":"Saves the shared status of a query to the database. See also M:QUERYSAVE.sharing . Client code: {sidecontent.sendval} . Source code in controllers/hebrew.py def querysharing (): \"\"\"Saves the shared status of a query to the database. See also [M:QUERYSAVE.sharing][querysave.QUERYSAVE.sharing]. Client code: [{sidecontent.sendval}][sidecontentsendval]. \"\"\" session . forget ( response ) Query = QUERY () QueryChapter = QUERYCHAPTER () QuerySave = QUERYSAVE ( Query , QueryChapter ) return QuerySave . sharing ()","title":"querysharing()"},{"location":"server/controllers/#controllers.hebrew.queryupdate","text":"Saves metadata of a query to the database. See also M:QUERYSAVE.putRecord . Client code: {sidecontent.sendvals} . Source code in controllers/hebrew.py def queryupdate (): \"\"\"Saves metadata of a query to the database. See also [M:QUERYSAVE.putRecord][querysave.QUERYSAVE.putRecord]. Client code: [{sidecontent.sendvals}][sidecontentsendvals]. \"\"\" session . forget ( response ) Query = QUERY () QueryChapter = QUERYCHAPTER () QuerySave = QUERYSAVE ( Query , QueryChapter ) return QuerySave . putRecord ()","title":"queryupdate()"},{"location":"server/models/","text":"Models \u00b6 The code in the models define the database connections and define other data related global variables.","title":"Models"},{"location":"server/models/#models","text":"The code in the models define the database connections and define other data related global variables.","title":"Models"},{"location":"server/views/","text":"Views \u00b6 The HTML generation takes place in the views, based on data supplied by the controllers in template variables. Nevertheless, there is also a fair bit of HTML generation at the client side, done by Javascript.","title":"Views"},{"location":"server/views/#views","text":"The HTML generation takes place in the views, based on data supplied by the controllers in template variables. Nevertheless, there is also a fair bit of HTML generation at the client side, done by Javascript.","title":"Views"},{"location":"server/bymodule/","text":"About modules \u00b6 Python modules perform dedicated data retrieval and composition tasks. These tasks have been delegated to them by the controllers. Use the navigation menu to jump to the individual modules.","title":"About modules"},{"location":"server/bymodule/#about-modules","text":"Python modules perform dedicated data retrieval and composition tasks. These tasks have been delegated to them by the controllers. Use the navigation menu to jump to the individual modules.","title":"About modules"},{"location":"server/bymodule/blang/","text":"blang \u00b6 BIBLANG \u00b6 BK_NAMES \u00b6 BOOK_LANGS \u00b6 Languages for bible book names BOOK_NAMES \u00b6 Book names in all the languages BOOK_TRANS \u00b6","title":"Blang"},{"location":"server/bymodule/blang/#blang","text":"","title":"blang"},{"location":"server/bymodule/blang/#blang.BIBLANG","text":"","title":"BIBLANG"},{"location":"server/bymodule/blang/#blang.BK_NAMES","text":"","title":"BK_NAMES"},{"location":"server/bymodule/blang/#blang.BOOK_LANGS","text":"Languages for bible book names","title":"BOOK_LANGS"},{"location":"server/bymodule/blang/#blang.BOOK_NAMES","text":"Book names in all the languages","title":"BOOK_NAMES"},{"location":"server/bymodule/blang/#blang.BOOK_TRANS","text":"","title":"BOOK_TRANS"},{"location":"server/bymodule/boiler/","text":"boiler \u00b6 FIELDNAMES \u00b6 Lists of field names of the data that is displayed in text presentations. Keyed by the code of the text presentation type, the values are combinations of data type (word, phrase, clause etc.) and feature name (gloss, phono, gender, etc.) LEGEND \u00b6 The legend as an HTML table. See \u2208 feature-legend . TEXT_TPL \u00b6 The representation of a word in data view as an HTML table.","title":"Boiler"},{"location":"server/bymodule/boiler/#boiler","text":"","title":"boiler"},{"location":"server/bymodule/boiler/#boiler.FIELDNAMES","text":"Lists of field names of the data that is displayed in text presentations. Keyed by the code of the text presentation type, the values are combinations of data type (word, phrase, clause etc.) and feature name (gloss, phono, gender, etc.)","title":"FIELDNAMES"},{"location":"server/bymodule/boiler/#boiler.LEGEND","text":"The legend as an HTML table. See \u2208 feature-legend .","title":"LEGEND"},{"location":"server/bymodule/boiler/#boiler.TEXT_TPL","text":"The representation of a word in data view as an HTML table.","title":"TEXT_TPL"},{"location":"server/bymodule/books/","text":"books \u00b6 BOOKS \u00b6 All information about the names of bible books. The order of the books and the names of the books in all supported languages. This information is meant to be permanently cached. __init__ ( self ) special \u00b6 Source code in modules/books.py def __init__ ( self ): pass getNames ( self ) \u00b6 Send information about bible booknames. The info consists of the latin booknames, the languages in which we have translations for them, and a translation table for all book names. The info is wrapped in global Javascript variables, so that the whole client app can use the info. Source code in modules/books.py def getNames ( self ): \"\"\"Send information about bible booknames. The info consists of the latin booknames, the languages in which we have translations for them, and a translation table for all book names. The info is wrapped in global Javascript variables, so that the whole client app can use the info. \"\"\" jsinit = dedent ( f \"\"\" var bookLatin = { json . dumps ( BOOK_NAMES [ \"Hebrew\" ][ \"la\" ]) } ; var bookTrans = { json . dumps ( BOOK_TRANS ) } ; var bookLangs = { json . dumps ( BOOK_LANGS [ \"Hebrew\" ]) } ; \"\"\" ) return dict ( jsinit = jsinit ) get ( self , vr ) \u00b6 Source code in modules/books.py def get ( self , vr ): Caching = current . Caching return Caching . get ( f \"books_ { vr } _\" , lambda : self . get_c ( vr ), ALWAYS ) get_c ( self , vr ) \u00b6 get book information: number of chapters per book Source code in modules/books.py def get_c ( self , vr ): \"\"\"get book information: number of chapters per book \"\"\" PASSAGE_DBS = current . PASSAGE_DBS if vr in PASSAGE_DBS : booksData = PASSAGE_DBS [ vr ] . executesql ( dedent ( \"\"\" select book.id, book.name, max(chapter_num) from chapter inner join book on chapter.book_id = book.id group by name order by book.id ; \"\"\" ) ) booksOrder = [ x [ 1 ] for x in booksData ] books = dict (( x [ 1 ], x [ 2 ]) for x in booksData ) bookIds = dict (( x [ 1 ], x [ 0 ]) for x in booksData ) bookName = dict (( x [ 0 ], x [ 1 ]) for x in booksData ) result = ( books , booksOrder , bookIds , bookName ) else : result = ({}, [], {}, {}) return result","title":"Books"},{"location":"server/bymodule/books/#books","text":"","title":"books"},{"location":"server/bymodule/books/#books.BOOKS","text":"All information about the names of bible books. The order of the books and the names of the books in all supported languages. This information is meant to be permanently cached.","title":"BOOKS"},{"location":"server/bymodule/books/#books.BOOKS.__init__","text":"Source code in modules/books.py def __init__ ( self ): pass","title":"__init__()"},{"location":"server/bymodule/books/#books.BOOKS.getNames","text":"Send information about bible booknames. The info consists of the latin booknames, the languages in which we have translations for them, and a translation table for all book names. The info is wrapped in global Javascript variables, so that the whole client app can use the info. Source code in modules/books.py def getNames ( self ): \"\"\"Send information about bible booknames. The info consists of the latin booknames, the languages in which we have translations for them, and a translation table for all book names. The info is wrapped in global Javascript variables, so that the whole client app can use the info. \"\"\" jsinit = dedent ( f \"\"\" var bookLatin = { json . dumps ( BOOK_NAMES [ \"Hebrew\" ][ \"la\" ]) } ; var bookTrans = { json . dumps ( BOOK_TRANS ) } ; var bookLangs = { json . dumps ( BOOK_LANGS [ \"Hebrew\" ]) } ; \"\"\" ) return dict ( jsinit = jsinit )","title":"getNames()"},{"location":"server/bymodule/books/#books.BOOKS.get","text":"Source code in modules/books.py def get ( self , vr ): Caching = current . Caching return Caching . get ( f \"books_ { vr } _\" , lambda : self . get_c ( vr ), ALWAYS )","title":"get()"},{"location":"server/bymodule/books/#books.BOOKS.get_c","text":"get book information: number of chapters per book Source code in modules/books.py def get_c ( self , vr ): \"\"\"get book information: number of chapters per book \"\"\" PASSAGE_DBS = current . PASSAGE_DBS if vr in PASSAGE_DBS : booksData = PASSAGE_DBS [ vr ] . executesql ( dedent ( \"\"\" select book.id, book.name, max(chapter_num) from chapter inner join book on chapter.book_id = book.id group by name order by book.id ; \"\"\" ) ) booksOrder = [ x [ 1 ] for x in booksData ] books = dict (( x [ 1 ], x [ 2 ]) for x in booksData ) bookIds = dict (( x [ 1 ], x [ 0 ]) for x in booksData ) bookName = dict (( x [ 0 ], x [ 1 ]) for x in booksData ) result = ( books , booksOrder , bookIds , bookName ) else : result = ({}, [], {}, {}) return result","title":"get_c()"},{"location":"server/bymodule/caching/","text":"models.caching \u00b6 CACHING_ENABLED \u00b6 Whether we should also cache on disk Do not cache on disk Two problems: some of the cached objects cannot be pickled: M viewdefs.Make caches validation functions . We could work around this. But: It causes deadlock. In order to write to the cache file, the file must be locked, but the process somehow never allows the lock to be obtained. CACHING_RAM_ONLY \u00b6 CACHING \u00b6 Handles all caching requests. The cache is used for global data structures In web2py the cache is global to the threads, but local to the process. Since we use the cache to maintain a live index between queries and chapters, the index in one process might get out of touch with the situation in another process. For example if a query is run and different or new results are obtained. It will trigger an update of certain cache values, but other processes do not see that. So configure a SHEBANQ server to use 1 process and multiple threads. other location This module is not in the modules directory but in the models directory. In the module an instance of this class is created and added to current (a web2py concept), which means that the object is available for each request. __init__ ( self ) special \u00b6 Source code in models/caching.py def __init__ ( self ): pass get ( self , cacheKey , func , expire ) \u00b6 Get the value of function func from the cache. When called, it is first determined of the cache contains a value for the key cacheKey . If so, this value is returned. If not, func is called with zero arguments, and the result is stored in the cache under key cacheKey . Then the result is returned. If the expiration time is not None, the result stays in the cache for that many seconds. Parameters: Name Type Description Default func function a function with zero arguments. required cacheKey string a string which is used to lookup the value of func() by. required expire integer time in seconds after which the stored result expires. If None , the result stays in the cache permanently. required Returns: Type Description data Whatever func() returnss Source code in models/caching.py def get ( self , cacheKey , func , expire ): \"\"\"Get the value of function `func` from the cache. When called, it is first determined of the cache contains a value for the key `cacheKey`. If so, this value is returned. If not, `func` is called with zero arguments, and the result is stored in the cache under key `cacheKey`. Then the result is returned. If the expiration time is not None, the result stays in the cache for that many seconds. Parameters ---------- func: function a function with zero arguments. cacheKey: string a string which is used to lookup the value of `func()` by. expire: integer time in seconds after which the stored result expires. If `None`, the result stays in the cache permanently. Returns ------- data Whatever `func()` returnss \"\"\" cache = current . cache if CACHING_ENABLED and cache is not None : if CACHING_RAM_ONLY : result = cache . ram ( cacheKey , func , time_expire = expire ) else : result = cache . ram ( cacheKey , lambda : cache . disk ( cacheKey , func , time_expire = expire ), time_expire = expire , ) else : result = func () return result clear ( self , cacheKeys ) \u00b6 Source code in models/caching.py def clear ( self , cacheKeys ): cache = current . cache if CACHING_ENABLED and cache is not None : cache . ram . clear ( regex = cacheKeys ) if not CACHING_RAM_ONLY : cache . disk . clear ( regex = cacheKeys )","title":"Caching"},{"location":"server/bymodule/caching/#models.caching","text":"","title":"caching"},{"location":"server/bymodule/caching/#models.caching.CACHING_ENABLED","text":"Whether we should also cache on disk Do not cache on disk Two problems: some of the cached objects cannot be pickled: M viewdefs.Make caches validation functions . We could work around this. But: It causes deadlock. In order to write to the cache file, the file must be locked, but the process somehow never allows the lock to be obtained.","title":"CACHING_ENABLED"},{"location":"server/bymodule/caching/#models.caching.CACHING_RAM_ONLY","text":"","title":"CACHING_RAM_ONLY"},{"location":"server/bymodule/caching/#models.caching.CACHING","text":"Handles all caching requests. The cache is used for global data structures In web2py the cache is global to the threads, but local to the process. Since we use the cache to maintain a live index between queries and chapters, the index in one process might get out of touch with the situation in another process. For example if a query is run and different or new results are obtained. It will trigger an update of certain cache values, but other processes do not see that. So configure a SHEBANQ server to use 1 process and multiple threads. other location This module is not in the modules directory but in the models directory. In the module an instance of this class is created and added to current (a web2py concept), which means that the object is available for each request.","title":"CACHING"},{"location":"server/bymodule/caching/#models.caching.CACHING.__init__","text":"Source code in models/caching.py def __init__ ( self ): pass","title":"__init__()"},{"location":"server/bymodule/caching/#models.caching.CACHING.get","text":"Get the value of function func from the cache. When called, it is first determined of the cache contains a value for the key cacheKey . If so, this value is returned. If not, func is called with zero arguments, and the result is stored in the cache under key cacheKey . Then the result is returned. If the expiration time is not None, the result stays in the cache for that many seconds. Parameters: Name Type Description Default func function a function with zero arguments. required cacheKey string a string which is used to lookup the value of func() by. required expire integer time in seconds after which the stored result expires. If None , the result stays in the cache permanently. required Returns: Type Description data Whatever func() returnss Source code in models/caching.py def get ( self , cacheKey , func , expire ): \"\"\"Get the value of function `func` from the cache. When called, it is first determined of the cache contains a value for the key `cacheKey`. If so, this value is returned. If not, `func` is called with zero arguments, and the result is stored in the cache under key `cacheKey`. Then the result is returned. If the expiration time is not None, the result stays in the cache for that many seconds. Parameters ---------- func: function a function with zero arguments. cacheKey: string a string which is used to lookup the value of `func()` by. expire: integer time in seconds after which the stored result expires. If `None`, the result stays in the cache permanently. Returns ------- data Whatever `func()` returnss \"\"\" cache = current . cache if CACHING_ENABLED and cache is not None : if CACHING_RAM_ONLY : result = cache . ram ( cacheKey , func , time_expire = expire ) else : result = cache . ram ( cacheKey , lambda : cache . disk ( cacheKey , func , time_expire = expire ), time_expire = expire , ) else : result = func () return result","title":"get()"},{"location":"server/bymodule/caching/#models.caching.CACHING.clear","text":"Source code in models/caching.py def clear ( self , cacheKeys ): cache = current . cache if CACHING_ENABLED and cache is not None : cache . ram . clear ( regex = cacheKeys ) if not CACHING_RAM_ONLY : cache . disk . clear ( regex = cacheKeys )","title":"clear()"},{"location":"server/bymodule/chart/","text":"chart \u00b6 BLOCK_SIZE \u00b6 CHART \u00b6 Make heat maps of lists of items. The items are word occurrences or query results or note set members. We divide the bible in 500-word blocks and count the number of items per block. We present the blocks in a chart, where each block shows the number of items by means of color. The blocks are clickable and move to the chapter in which the first word of the block occurs. See also the client code: {chart} . __init__ ( self , Books , Record , Word , Query , Note ) special \u00b6 Source code in modules/chart.py def __init__ ( self , Books , Record , Word , Query , Note ): self . Books = Books self . Record = Record self . Word = Word self . Query = Query self . Note = Note page ( self ) \u00b6 Read request parameters and get chart data ready for the controller. Source code in modules/chart.py def page ( self ): \"\"\"Read request parameters and get chart data ready for the controller. \"\"\" Check = current . Check Record = self . Record vr = Check . field ( \"material\" , \"\" , \"version\" ) mr = Check . field ( \"material\" , \"\" , \"mr\" ) qw = Check . field ( \"material\" , \"\" , \"qw\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) ( authorized , msg ) = Record . authRead ( mr , qw , iidRep ) if not authorized : # produce empty chart result = self . compose ( vr , []) else : result = self . get ( vr , qw , iidRep ) result . update ( qw = qw ) result . update ( msg = msg ) return result get ( self , vr , qw , iidRep ) \u00b6 Get chart data, using the cache. Source code in modules/chart.py def get ( self , vr , qw , iidRep ): \"\"\"Get chart data, using the cache. \"\"\" Caching = current . Caching return Caching . get ( f \"chart_ { vr } _ { qw } _ { iidRep } _\" , lambda : self . get_c ( vr , qw , iidRep ), ONE_DAY , ) get_c ( self , vr , qw , iidRep ) \u00b6 Source code in modules/chart.py def get_c ( self , vr , qw , iidRep ): Query = self . Query Word = self . Word Note = self . Note ( iid , keywords ) = iDecode ( qw , iidRep ) ( nSlots , slotSets ) = ( Query . read ( vr , iid ) if qw == \"q\" else Word . read ( vr , iid ) if qw == \"w\" else Note . read ( vr , iid , keywords ) ) result = self . compose ( vr , slotSets ) result . update ( qw = qw ) return result getBlocks ( self , vr ) \u00b6 Get info on the 500-word blocks. for each slot: to which block it belongs, for each block: book and chapter number of first word. Possibly there are gaps between books. Source code in modules/chart.py def getBlocks ( self , vr ): \"\"\"Get info on the 500-word blocks. * for each slot: to which block it belongs, * for each block: book and chapter number of first word. Possibly there are gaps between books. \"\"\" Caching = current . Caching return Caching . get ( f \"blocks_ { vr } _\" , lambda : self . getBlocks_c ( vr ), ALWAYS ) getBlocks_c ( self , vr ) \u00b6 Source code in modules/chart.py def getBlocks_c ( self , vr ): PASSAGE_DBS = current . PASSAGE_DBS if vr not in PASSAGE_DBS : return ([], {}) bookSlots = PASSAGE_DBS [ vr ] . executesql ( dedent ( \"\"\" select name, first_m, last_m from book ; \"\"\" ) ) chapterSlots = PASSAGE_DBS [ vr ] . executesql ( dedent ( \"\"\" select chapter_num, first_m, last_m from chapter ; \"\"\" ) ) m = - 1 curBlkF = None curBlkSize = 0 curBkIndex = 0 curChpIndex = 0 ( curBk , curBkFirst_m , curBkLast_m ) = bookSlots [ curBkIndex ] ( curChp , curChpFirst_m , curChpLast_m ) = chapterSlots [ curChpIndex ] blocks = [] blockMapping = {} def getCurposInfo ( n ): ( curChp , curChpFirst_m , curChpLast_m ) = chapterSlots [ curChpIndex ] chapterLen = curChpLast_m - curChpFirst_m + 1 fraction = float ( n - curChpFirst_m ) / chapterLen rep = ( f \" { curChp } .Z\" if n == curChpLast_m else f \" { curChp } .z\" if round ( 10 * fraction ) == 10 else f \" { curChp + fraction : 0.1f } \" ) return ( curChp , rep ) while True : m += 1 if m > curBkLast_m : size = round (( float ( curBlkSize ) / BLOCK_SIZE ) * 100 ) blocks . append (( curBk , curBlkF , getCurposInfo ( m - 1 ), size )) curBlkSize = 0 curBkIndex += 1 if curBkIndex >= len ( bookSlots ): break else : ( curBk , curBkFirst_m , curBkLast_m ) = bookSlots [ curBkIndex ] curChpIndex += 1 ( curChp , curChpFirst_m , curChpLast_m ) = chapterSlots [ curChpIndex ] curBlkF = getCurposInfo ( m ) if curBlkSize == BLOCK_SIZE : blocks . append (( curBk , curBlkF , getCurposInfo ( m - 1 ), 100 )) curBlkSize = 0 if m > curChpLast_m : curChpIndex += 1 if curChpIndex >= len ( chapterSlots ): break else : ( curChp , curChpFirst_m , curChpLast_m ) = chapterSlots [ curChpIndex ] if m < curBkFirst_m : continue if m < curChpFirst_m : continue if curBlkSize == 0 : curBlkF = getCurposInfo ( m ) blockMapping [ m ] = len ( blocks ) curBlkSize += 1 return ( blocks , blockMapping ) compose ( self , vr , slotSets ) \u00b6 Organize the raw chart data in books and then in blocks. Returns: Type Description dict keyed by book, with values lists of blocks where each block is a tuple (chapter number, start position, end position, number of results, size) Source code in modules/chart.py def compose ( self , vr , slotSets ): \"\"\"Organize the raw chart data in books and then in blocks. Returns ------- dict keyed by book, with values lists of blocks where each block is a tuple (chapter number, start position, end position, number of results, size) \"\"\" Books = self . Books slots = flatten ( slotSets ) chart = {} chartOrder = [] if len ( slots ): ( books , booksOrder , bookIds , bookName ) = Books . get ( vr ) ( blocks , blockMapping ) = self . getBlocks ( vr ) results = {} for bl in range ( len ( blocks )): results [ bl ] = 0 for bk in booksOrder : chart [ bk ] = [] chartOrder . append ( bk ) for m in slots : results [ blockMapping [ m ]] += 1 for bl in range ( len ( blocks )): ( bk , chpStart , chpEnd , size ) = blocks [ bl ] r = results [ bl ] chart [ bk ] . append (( chpStart [ 0 ], chpStart [ 1 ], chpEnd [ 1 ], r , size )) return dict ( chart = json . dumps ( chart ), chartOrder = json . dumps ( chartOrder ))","title":"Chart"},{"location":"server/bymodule/chart/#chart","text":"","title":"chart"},{"location":"server/bymodule/chart/#chart.BLOCK_SIZE","text":"","title":"BLOCK_SIZE"},{"location":"server/bymodule/chart/#chart.CHART","text":"Make heat maps of lists of items. The items are word occurrences or query results or note set members. We divide the bible in 500-word blocks and count the number of items per block. We present the blocks in a chart, where each block shows the number of items by means of color. The blocks are clickable and move to the chapter in which the first word of the block occurs. See also the client code: {chart} .","title":"CHART"},{"location":"server/bymodule/chart/#chart.CHART.__init__","text":"Source code in modules/chart.py def __init__ ( self , Books , Record , Word , Query , Note ): self . Books = Books self . Record = Record self . Word = Word self . Query = Query self . Note = Note","title":"__init__()"},{"location":"server/bymodule/chart/#chart.CHART.page","text":"Read request parameters and get chart data ready for the controller. Source code in modules/chart.py def page ( self ): \"\"\"Read request parameters and get chart data ready for the controller. \"\"\" Check = current . Check Record = self . Record vr = Check . field ( \"material\" , \"\" , \"version\" ) mr = Check . field ( \"material\" , \"\" , \"mr\" ) qw = Check . field ( \"material\" , \"\" , \"qw\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) ( authorized , msg ) = Record . authRead ( mr , qw , iidRep ) if not authorized : # produce empty chart result = self . compose ( vr , []) else : result = self . get ( vr , qw , iidRep ) result . update ( qw = qw ) result . update ( msg = msg ) return result","title":"page()"},{"location":"server/bymodule/chart/#chart.CHART.get","text":"Get chart data, using the cache. Source code in modules/chart.py def get ( self , vr , qw , iidRep ): \"\"\"Get chart data, using the cache. \"\"\" Caching = current . Caching return Caching . get ( f \"chart_ { vr } _ { qw } _ { iidRep } _\" , lambda : self . get_c ( vr , qw , iidRep ), ONE_DAY , )","title":"get()"},{"location":"server/bymodule/chart/#chart.CHART.get_c","text":"Source code in modules/chart.py def get_c ( self , vr , qw , iidRep ): Query = self . Query Word = self . Word Note = self . Note ( iid , keywords ) = iDecode ( qw , iidRep ) ( nSlots , slotSets ) = ( Query . read ( vr , iid ) if qw == \"q\" else Word . read ( vr , iid ) if qw == \"w\" else Note . read ( vr , iid , keywords ) ) result = self . compose ( vr , slotSets ) result . update ( qw = qw ) return result","title":"get_c()"},{"location":"server/bymodule/chart/#chart.CHART.getBlocks","text":"Get info on the 500-word blocks. for each slot: to which block it belongs, for each block: book and chapter number of first word. Possibly there are gaps between books. Source code in modules/chart.py def getBlocks ( self , vr ): \"\"\"Get info on the 500-word blocks. * for each slot: to which block it belongs, * for each block: book and chapter number of first word. Possibly there are gaps between books. \"\"\" Caching = current . Caching return Caching . get ( f \"blocks_ { vr } _\" , lambda : self . getBlocks_c ( vr ), ALWAYS )","title":"getBlocks()"},{"location":"server/bymodule/chart/#chart.CHART.getBlocks_c","text":"Source code in modules/chart.py def getBlocks_c ( self , vr ): PASSAGE_DBS = current . PASSAGE_DBS if vr not in PASSAGE_DBS : return ([], {}) bookSlots = PASSAGE_DBS [ vr ] . executesql ( dedent ( \"\"\" select name, first_m, last_m from book ; \"\"\" ) ) chapterSlots = PASSAGE_DBS [ vr ] . executesql ( dedent ( \"\"\" select chapter_num, first_m, last_m from chapter ; \"\"\" ) ) m = - 1 curBlkF = None curBlkSize = 0 curBkIndex = 0 curChpIndex = 0 ( curBk , curBkFirst_m , curBkLast_m ) = bookSlots [ curBkIndex ] ( curChp , curChpFirst_m , curChpLast_m ) = chapterSlots [ curChpIndex ] blocks = [] blockMapping = {} def getCurposInfo ( n ): ( curChp , curChpFirst_m , curChpLast_m ) = chapterSlots [ curChpIndex ] chapterLen = curChpLast_m - curChpFirst_m + 1 fraction = float ( n - curChpFirst_m ) / chapterLen rep = ( f \" { curChp } .Z\" if n == curChpLast_m else f \" { curChp } .z\" if round ( 10 * fraction ) == 10 else f \" { curChp + fraction : 0.1f } \" ) return ( curChp , rep ) while True : m += 1 if m > curBkLast_m : size = round (( float ( curBlkSize ) / BLOCK_SIZE ) * 100 ) blocks . append (( curBk , curBlkF , getCurposInfo ( m - 1 ), size )) curBlkSize = 0 curBkIndex += 1 if curBkIndex >= len ( bookSlots ): break else : ( curBk , curBkFirst_m , curBkLast_m ) = bookSlots [ curBkIndex ] curChpIndex += 1 ( curChp , curChpFirst_m , curChpLast_m ) = chapterSlots [ curChpIndex ] curBlkF = getCurposInfo ( m ) if curBlkSize == BLOCK_SIZE : blocks . append (( curBk , curBlkF , getCurposInfo ( m - 1 ), 100 )) curBlkSize = 0 if m > curChpLast_m : curChpIndex += 1 if curChpIndex >= len ( chapterSlots ): break else : ( curChp , curChpFirst_m , curChpLast_m ) = chapterSlots [ curChpIndex ] if m < curBkFirst_m : continue if m < curChpFirst_m : continue if curBlkSize == 0 : curBlkF = getCurposInfo ( m ) blockMapping [ m ] = len ( blocks ) curBlkSize += 1 return ( blocks , blockMapping )","title":"getBlocks_c()"},{"location":"server/bymodule/chart/#chart.CHART.compose","text":"Organize the raw chart data in books and then in blocks. Returns: Type Description dict keyed by book, with values lists of blocks where each block is a tuple (chapter number, start position, end position, number of results, size) Source code in modules/chart.py def compose ( self , vr , slotSets ): \"\"\"Organize the raw chart data in books and then in blocks. Returns ------- dict keyed by book, with values lists of blocks where each block is a tuple (chapter number, start position, end position, number of results, size) \"\"\" Books = self . Books slots = flatten ( slotSets ) chart = {} chartOrder = [] if len ( slots ): ( books , booksOrder , bookIds , bookName ) = Books . get ( vr ) ( blocks , blockMapping ) = self . getBlocks ( vr ) results = {} for bl in range ( len ( blocks )): results [ bl ] = 0 for bk in booksOrder : chart [ bk ] = [] chartOrder . append ( bk ) for m in slots : results [ blockMapping [ m ]] += 1 for bl in range ( len ( blocks )): ( bk , chpStart , chpEnd , size ) = blocks [ bl ] r = results [ bl ] chart [ bk ] . append (( chpStart [ 0 ], chpStart [ 1 ], chpEnd [ 1 ], r , size )) return dict ( chart = json . dumps ( chart ), chartOrder = json . dumps ( chartOrder ))","title":"compose()"},{"location":"server/bymodule/check/","text":"models.check \u00b6 CHECK \u00b6 Checks values for parameters Before passing on request parameters to the rest of the application, they will be checked for sanity. Default values will be supplied, if needed. other location This module is not in the modules directory but in the models directory. In the module an instance of this class is created and added to current (a web2py concept), which means that the object is available for each request. __init__ ( self ) special \u00b6 Source code in models/check.py def __init__ ( self ): pass field ( self , group , qw , var , default = True ) \u00b6 Source code in models/check.py def field ( self , group , qw , var , default = True ): ViewDefs = current . ViewDefs request = current . request requestVar = ( \"c_\" if group == \"colormap\" else \"\" ) + qw + var if requestVar == \"iid\" : x = request . vars . get ( \"id\" , request . vars . get ( \"iid\" , None )) else : x = request . vars . get ( requestVar , None ) if requestVar == \"extra\" : x = str ( x ) if type ( x ) is list : x = x [ 0 ] # this occurs when the same variable occurs multiple times # in the request/querystring theVar = \"0\" if group == \"colormap\" else var defaultValue = ViewDefs . settings [ group ][ qw ][ theVar ] if default else None return ViewDefs . validation [ group ][ qw ][ theVar ]( defaultValue , x ) fields ( self , tp , qw = None ) \u00b6 Source code in models/check.py def fields ( self , tp , qw = None ): ViewDefs = current . ViewDefs if qw is None or qw != \"n\" : if tp == \"txtd\" : hebrewFields = [] for ( line , fields ) in ViewDefs . featureLines : if self . field ( \"hebrewdata\" , \"\" , line ) == \"v\" : for ( f , name , prettyName ) in fields : if self . field ( \"hebrewdata\" , \"\" , f ) == \"v\" : hebrewFields . append (( name , prettyName )) else : hebrewFields = ViewDefs . featureFields [ tp ] return hebrewFields else : hebrewFields = ( ( ( \"clause_atom\" , \"ca_nr\" ), ( \"shebanq_note.note.keywords\" , \"keyw\" ), ( \"shebanq_note.note.status\" , \"status\" ), ( \"shebanq_note.note.ntext\" , \"note\" ), ) if tp == \"txtp\" else ( ( \"clause_atom\" , \"ca_nr\" ), ( \"clause_atom.text\" , \"ca_txt\" ), ( \"shebanq_note.note.keywords\" , \"keyw\" ), ( \"shebanq_note.note.status\" , \"status\" ), ( \"shebanq_note.note.ntext\" , \"note\" ), ( \"shebanq_note.note.created_on\" , \"created_on\" ), ( \"shebanq_note.note.modified_on\" , \"modified_on\" ), ( ( 'if(shebanq_note.note.is_shared = \"T\", \"T\", \"F\") ' \"as shared\" ), \"is_shared\" , ), ( ( 'if(shebanq_note.note.is_published = \"T\", \"T\", \"F\") ' \"as is_published\" ), \"is_published\" , ), ( 'ifnull(shebanq_note.note.published_on, \"\") as pub' , \"published_on\" , ), ) ) return hebrewFields isUnique ( self , tp , obj_id , val , myId , msgs ) \u00b6 Source code in models/check.py def isUnique ( self , tp , obj_id , val , myId , msgs ): db = current . db result = False ( label , table ) = TPS [ tp ] for x in [ 1 ]: if tp == \"q\" : checkSql = dedent ( f \"\"\" select id from query where name = ' { val } ' and query.created_by = { myId } ; \"\"\" ) else : checkSql = dedent ( f \"\"\" select id from { table } where name = ' { val } ' ; \"\"\" ) try : ids = db . executesql ( checkSql ) except Exception : msgs . append (( \"error\" , f \"cannot check the unicity of { val } as { label } !\" )) break if len ( ids ) and ( obj_id == 0 or ids [ 0 ][ 0 ] != int ( obj_id )): msgs . append (( \"error\" , f \"the { label } name is already taken!\" )) break result = True return result isName ( self , tp , obj_id , myId , val , msgs ) \u00b6 Source code in models/check.py def isName ( self , tp , obj_id , myId , val , msgs ): label = TPS [ tp ][ 0 ] result = None for x in [ 1 ]: if len ( val ) > 64 : msgs . append ( ( \"error\" , f \" { label } name is longer than 64 characters!\" , ) ) break val = val . strip () if val == \"\" : msgs . append ( ( \"error\" , f \" { label } name consists completely of white space!\" ) ) break val = val . replace ( \"'\" , \"''\" ) if not self . isUnique ( tp , obj_id , val , myId , msgs ): break result = val return result isDescription ( self , tp , val , msgs ) \u00b6 Source code in models/check.py def isDescription ( self , tp , val , msgs ): label = TPS [ tp ][ 0 ] result = None for x in [ 1 ]: if len ( val ) > 8192 : msgs . append ( ( \"error\" , f \" { label } description is longer than 8192 characters!\" ) ) break result = val . replace ( \"'\" , \"''\" ) return result isMql ( self , tp , val , msgs ) \u00b6 Source code in models/check.py def isMql ( self , tp , val , msgs ): label = TPS [ tp ][ 0 ] result = None for x in [ 1 ]: if len ( val ) > 8192 : msgs . append ( ( \"error\" , f \" { label } mql is longer than 8192 characters!\" , ) ) break result = val . replace ( \"'\" , \"''\" ) return result isPublished ( self , tp , val , msgs ) \u00b6 Source code in models/check.py def isPublished ( self , tp , val , msgs ): label = TPS [ tp ][ 0 ] result = None for x in [ 1 ]: if len ( val ) > 10 or ( len ( val ) > 0 and not val . isalnum ()): msgs . append ( ( \"error\" , f \" { label } published status has an invalid value { val } \" , ) ) break result = \"T\" if val == \"T\" else \"\" return result isWebsite ( self , tp , val , msgs ) \u00b6 Source code in models/check.py def isWebsite ( self , tp , val , msgs ): label = TPS [ tp ][ 0 ] result = None for x in [ 1 ]: if len ( val ) > 512 : msgs . append ( ( \"error\" , f \" { label } website is longer than 512 characters!\" ) ) break val = val . strip () if val == \"\" : msgs . append ( ( \"error\" , f \" { label } website consists completely of white space!\" ) ) break try : urlComps = urlparse ( val ) except ValueError : msgs . append (( \"error\" , f \"invalid syntax in { label } website !\" )) break scheme = urlComps . scheme if scheme not in { \"http\" , \"https\" }: msgs . append ( ( \"error\" , f \" { label } website does not start with http(s)://\" ) ) break netloc = urlComps . netloc if \".\" not in netloc : msgs . append (( \"error\" , f \"no location in { label } website\" )) break result = urlunparse ( urlComps ) . replace ( \"'\" , \"''\" ) return result isInt ( self , var , label , msgs ) \u00b6 Source code in models/check.py def isInt ( self , var , label , msgs ): request = current . request val = request . vars [ var ] if val is None : msgs . append (( \"error\" , f \"No { label } number given\" )) return None if len ( val ) > 10 or not val . isdigit (): msgs . append (( \"error\" , f \"Not a valid { label } \" )) return None return int ( val ) isBool ( self , var ) \u00b6 Source code in models/check.py def isBool ( self , var ): request = current . request val = request . vars [ var ] if ( val is None or len ( val ) > 10 or not val . isalpha () or val not in { \"true\" , \"false\" } or val == \"false\" ): return False return True isId ( self , var , tp , label , msgs , valrep = None ) \u00b6 Source code in models/check.py def isId ( self , var , tp , label , msgs , valrep = None ): request = current . request if valrep is None : valrep = request . vars [ var ] if valrep is None : msgs . append (( \"error\" , f \"No { label } id given\" )) return None if tp in { \"w\" , \"q\" , \"n\" }: ( val , keywords ) = iDecode ( tp , valrep ) else : val = valrep if len ( valrep ) > 10 or not valrep . isdigit (): msgs . append (( \"error\" , f \"Not a valid { label } id\" )) return None val = int ( valrep ) if tp == \"n\" : return valrep return val isRel ( self , tp , val , msgs ) \u00b6 Source code in models/check.py def isRel ( self , tp , val , msgs ): db = current . db ( label , table ) = TPS [ tp ] result = None for x in [ 1 ]: checkSql = dedent ( f \"\"\" select count(*) as occurs from { table } where id = { val } ; \"\"\" ) try : occurs = db . executesql ( checkSql )[ 0 ][ 0 ] except Exception : msgs . append ( ( \"error\" , f \"cannot check the occurrence of { label } id { val } !\" , ) ) break if not occurs : if val == 0 : msgs . append (( \"error\" , f \"No { label } chosen!\" )) else : msgs . append (( \"error\" , f \"There is no { label } { val } !\" )) break result = val return result","title":"Check"},{"location":"server/bymodule/check/#models.check","text":"","title":"check"},{"location":"server/bymodule/check/#models.check.CHECK","text":"Checks values for parameters Before passing on request parameters to the rest of the application, they will be checked for sanity. Default values will be supplied, if needed. other location This module is not in the modules directory but in the models directory. In the module an instance of this class is created and added to current (a web2py concept), which means that the object is available for each request.","title":"CHECK"},{"location":"server/bymodule/check/#models.check.CHECK.__init__","text":"Source code in models/check.py def __init__ ( self ): pass","title":"__init__()"},{"location":"server/bymodule/check/#models.check.CHECK.field","text":"Source code in models/check.py def field ( self , group , qw , var , default = True ): ViewDefs = current . ViewDefs request = current . request requestVar = ( \"c_\" if group == \"colormap\" else \"\" ) + qw + var if requestVar == \"iid\" : x = request . vars . get ( \"id\" , request . vars . get ( \"iid\" , None )) else : x = request . vars . get ( requestVar , None ) if requestVar == \"extra\" : x = str ( x ) if type ( x ) is list : x = x [ 0 ] # this occurs when the same variable occurs multiple times # in the request/querystring theVar = \"0\" if group == \"colormap\" else var defaultValue = ViewDefs . settings [ group ][ qw ][ theVar ] if default else None return ViewDefs . validation [ group ][ qw ][ theVar ]( defaultValue , x )","title":"field()"},{"location":"server/bymodule/check/#models.check.CHECK.fields","text":"Source code in models/check.py def fields ( self , tp , qw = None ): ViewDefs = current . ViewDefs if qw is None or qw != \"n\" : if tp == \"txtd\" : hebrewFields = [] for ( line , fields ) in ViewDefs . featureLines : if self . field ( \"hebrewdata\" , \"\" , line ) == \"v\" : for ( f , name , prettyName ) in fields : if self . field ( \"hebrewdata\" , \"\" , f ) == \"v\" : hebrewFields . append (( name , prettyName )) else : hebrewFields = ViewDefs . featureFields [ tp ] return hebrewFields else : hebrewFields = ( ( ( \"clause_atom\" , \"ca_nr\" ), ( \"shebanq_note.note.keywords\" , \"keyw\" ), ( \"shebanq_note.note.status\" , \"status\" ), ( \"shebanq_note.note.ntext\" , \"note\" ), ) if tp == \"txtp\" else ( ( \"clause_atom\" , \"ca_nr\" ), ( \"clause_atom.text\" , \"ca_txt\" ), ( \"shebanq_note.note.keywords\" , \"keyw\" ), ( \"shebanq_note.note.status\" , \"status\" ), ( \"shebanq_note.note.ntext\" , \"note\" ), ( \"shebanq_note.note.created_on\" , \"created_on\" ), ( \"shebanq_note.note.modified_on\" , \"modified_on\" ), ( ( 'if(shebanq_note.note.is_shared = \"T\", \"T\", \"F\") ' \"as shared\" ), \"is_shared\" , ), ( ( 'if(shebanq_note.note.is_published = \"T\", \"T\", \"F\") ' \"as is_published\" ), \"is_published\" , ), ( 'ifnull(shebanq_note.note.published_on, \"\") as pub' , \"published_on\" , ), ) ) return hebrewFields","title":"fields()"},{"location":"server/bymodule/check/#models.check.CHECK.isUnique","text":"Source code in models/check.py def isUnique ( self , tp , obj_id , val , myId , msgs ): db = current . db result = False ( label , table ) = TPS [ tp ] for x in [ 1 ]: if tp == \"q\" : checkSql = dedent ( f \"\"\" select id from query where name = ' { val } ' and query.created_by = { myId } ; \"\"\" ) else : checkSql = dedent ( f \"\"\" select id from { table } where name = ' { val } ' ; \"\"\" ) try : ids = db . executesql ( checkSql ) except Exception : msgs . append (( \"error\" , f \"cannot check the unicity of { val } as { label } !\" )) break if len ( ids ) and ( obj_id == 0 or ids [ 0 ][ 0 ] != int ( obj_id )): msgs . append (( \"error\" , f \"the { label } name is already taken!\" )) break result = True return result","title":"isUnique()"},{"location":"server/bymodule/check/#models.check.CHECK.isName","text":"Source code in models/check.py def isName ( self , tp , obj_id , myId , val , msgs ): label = TPS [ tp ][ 0 ] result = None for x in [ 1 ]: if len ( val ) > 64 : msgs . append ( ( \"error\" , f \" { label } name is longer than 64 characters!\" , ) ) break val = val . strip () if val == \"\" : msgs . append ( ( \"error\" , f \" { label } name consists completely of white space!\" ) ) break val = val . replace ( \"'\" , \"''\" ) if not self . isUnique ( tp , obj_id , val , myId , msgs ): break result = val return result","title":"isName()"},{"location":"server/bymodule/check/#models.check.CHECK.isDescription","text":"Source code in models/check.py def isDescription ( self , tp , val , msgs ): label = TPS [ tp ][ 0 ] result = None for x in [ 1 ]: if len ( val ) > 8192 : msgs . append ( ( \"error\" , f \" { label } description is longer than 8192 characters!\" ) ) break result = val . replace ( \"'\" , \"''\" ) return result","title":"isDescription()"},{"location":"server/bymodule/check/#models.check.CHECK.isMql","text":"Source code in models/check.py def isMql ( self , tp , val , msgs ): label = TPS [ tp ][ 0 ] result = None for x in [ 1 ]: if len ( val ) > 8192 : msgs . append ( ( \"error\" , f \" { label } mql is longer than 8192 characters!\" , ) ) break result = val . replace ( \"'\" , \"''\" ) return result","title":"isMql()"},{"location":"server/bymodule/check/#models.check.CHECK.isPublished","text":"Source code in models/check.py def isPublished ( self , tp , val , msgs ): label = TPS [ tp ][ 0 ] result = None for x in [ 1 ]: if len ( val ) > 10 or ( len ( val ) > 0 and not val . isalnum ()): msgs . append ( ( \"error\" , f \" { label } published status has an invalid value { val } \" , ) ) break result = \"T\" if val == \"T\" else \"\" return result","title":"isPublished()"},{"location":"server/bymodule/check/#models.check.CHECK.isWebsite","text":"Source code in models/check.py def isWebsite ( self , tp , val , msgs ): label = TPS [ tp ][ 0 ] result = None for x in [ 1 ]: if len ( val ) > 512 : msgs . append ( ( \"error\" , f \" { label } website is longer than 512 characters!\" ) ) break val = val . strip () if val == \"\" : msgs . append ( ( \"error\" , f \" { label } website consists completely of white space!\" ) ) break try : urlComps = urlparse ( val ) except ValueError : msgs . append (( \"error\" , f \"invalid syntax in { label } website !\" )) break scheme = urlComps . scheme if scheme not in { \"http\" , \"https\" }: msgs . append ( ( \"error\" , f \" { label } website does not start with http(s)://\" ) ) break netloc = urlComps . netloc if \".\" not in netloc : msgs . append (( \"error\" , f \"no location in { label } website\" )) break result = urlunparse ( urlComps ) . replace ( \"'\" , \"''\" ) return result","title":"isWebsite()"},{"location":"server/bymodule/check/#models.check.CHECK.isInt","text":"Source code in models/check.py def isInt ( self , var , label , msgs ): request = current . request val = request . vars [ var ] if val is None : msgs . append (( \"error\" , f \"No { label } number given\" )) return None if len ( val ) > 10 or not val . isdigit (): msgs . append (( \"error\" , f \"Not a valid { label } \" )) return None return int ( val )","title":"isInt()"},{"location":"server/bymodule/check/#models.check.CHECK.isBool","text":"Source code in models/check.py def isBool ( self , var ): request = current . request val = request . vars [ var ] if ( val is None or len ( val ) > 10 or not val . isalpha () or val not in { \"true\" , \"false\" } or val == \"false\" ): return False return True","title":"isBool()"},{"location":"server/bymodule/check/#models.check.CHECK.isId","text":"Source code in models/check.py def isId ( self , var , tp , label , msgs , valrep = None ): request = current . request if valrep is None : valrep = request . vars [ var ] if valrep is None : msgs . append (( \"error\" , f \"No { label } id given\" )) return None if tp in { \"w\" , \"q\" , \"n\" }: ( val , keywords ) = iDecode ( tp , valrep ) else : val = valrep if len ( valrep ) > 10 or not valrep . isdigit (): msgs . append (( \"error\" , f \"Not a valid { label } id\" )) return None val = int ( valrep ) if tp == \"n\" : return valrep return val","title":"isId()"},{"location":"server/bymodule/check/#models.check.CHECK.isRel","text":"Source code in models/check.py def isRel ( self , tp , val , msgs ): db = current . db ( label , table ) = TPS [ tp ] result = None for x in [ 1 ]: checkSql = dedent ( f \"\"\" select count(*) as occurs from { table } where id = { val } ; \"\"\" ) try : occurs = db . executesql ( checkSql )[ 0 ][ 0 ] except Exception : msgs . append ( ( \"error\" , f \"cannot check the occurrence of { label } id { val } !\" , ) ) break if not occurs : if val == 0 : msgs . append (( \"error\" , f \"No { label } chosen!\" )) else : msgs . append (( \"error\" , f \"There is no { label } { val } !\" )) break result = val return result","title":"isRel()"},{"location":"server/bymodule/constants/","text":"constants \u00b6 ALWAYS \u00b6 NOTFILLFIELDS \u00b6 Fields that, when represented in HTML, should not be filled with a non breaking space when empty. NULLDT \u00b6 Empty date time representation. ONE_DAY \u00b6 ONE_HOUR \u00b6 PUBLISH_FREEZE \u00b6 Time interval after which publishing is irrevocable. PUBLISH_FREEZE_MSG \u00b6 TPS \u00b6 Types of records in query tree view.","title":"Constants"},{"location":"server/bymodule/constants/#constants","text":"","title":"constants"},{"location":"server/bymodule/constants/#constants.ALWAYS","text":"","title":"ALWAYS"},{"location":"server/bymodule/constants/#constants.NOTFILLFIELDS","text":"Fields that, when represented in HTML, should not be filled with a non breaking space when empty.","title":"NOTFILLFIELDS"},{"location":"server/bymodule/constants/#constants.NULLDT","text":"Empty date time representation.","title":"NULLDT"},{"location":"server/bymodule/constants/#constants.ONE_DAY","text":"","title":"ONE_DAY"},{"location":"server/bymodule/constants/#constants.ONE_HOUR","text":"","title":"ONE_HOUR"},{"location":"server/bymodule/constants/#constants.PUBLISH_FREEZE","text":"Time interval after which publishing is irrevocable.","title":"PUBLISH_FREEZE"},{"location":"server/bymodule/constants/#constants.PUBLISH_FREEZE_MSG","text":"","title":"PUBLISH_FREEZE_MSG"},{"location":"server/bymodule/constants/#constants.TPS","text":"Types of records in query tree view.","title":"TPS"},{"location":"server/bymodule/csvdata/","text":"csvdata \u00b6 CSVDATA \u00b6 Produces various kinds of csv exports of lists of items. Items are word occirrences, query results or noteset members. __init__ ( self , Record , Word , Query ) special \u00b6 Source code in modules/csvdata.py def __init__ ( self , Record , Word , Query ): self . Record = Record self . Word = Word self . Query = Query page ( self ) \u00b6 Read request parameters and get the data and ready for the controller. Source code in modules/csvdata.py def page ( self ): \"\"\"Read request parameters and get the data and ready for the controller. \"\"\" ViewDefs = current . ViewDefs Check = current . Check Record = self . Record vr = Check . field ( \"material\" , \"\" , \"version\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) mr = Check . field ( \"material\" , \"\" , \"mr\" ) qw = Check . field ( \"material\" , \"\" , \"qw\" ) tp = Check . field ( \"material\" , \"\" , \"tp\" ) extra = Check . field ( \"rest\" , \"\" , \"extra\" ) ( iid , keywords ) = iDecode ( qw , iidRep ) iidRep2 = iDecode ( qw , iidRep , rsep = \" \" ) itemStyle = ViewDefs . itemStyle tabLabels = ViewDefs . tabLabels fileName = f \" { vr } _ { itemStyle [ qw ][ 't' ] }{ iidRep2 } _ { tabLabels [ tp ] }{ extra } .csv\" ( authorized , msg ) = Record . authRead ( mr , qw , iidRep ) if not authorized : return dict ( fileName = fileName , data = msg ) hebrewFields = Check . fields ( tp , qw = qw ) data = self . get ( vr , mr , qw , iid , keywords , tp , extra , hebrewFields , fileName ) return dict ( fileName = fileName , data = data ) get ( self , vr , mr , qw , iid , keywords , tp , extra , hebrewFields , fileName ) \u00b6 Get csv data as specified by parameters. Source code in modules/csvdata.py def get ( self , vr , mr , qw , iid , keywords , tp , extra , hebrewFields , fileName ): \"\"\"Get csv data as specified by parameters. \"\"\" Word = self . Word Query = self . Query auth = current . auth PASSAGE_DBS = current . PASSAGE_DBS if extra : extra = \"_\" + extra if len ( extra ) > 64 : extra = extra [ 0 : 64 ] headRow = [ \"book\" , \"chapter\" , \"verse\" ] + [ hf [ 1 ] for hf in hebrewFields ] if qw == \"n\" : keywordsSql = keywords . replace ( \"'\" , \"''\" ) myId = auth . user . id if auth . user is not None else None extra = \"\" if myId is None else f \" or created_by = { myId } \" hflist = \", \" . join ( hf [ 0 ] for hf in hebrewFields ) sql = dedent ( f \"\"\" select shebanq_note.note.book, shebanq_note.note.chapter, shebanq_note.note.verse, { hflist } from shebanq_note.note inner join book on shebanq_note.note.book = book.name inner join clause_atom on clause_atom.ca_num = shebanq_note.note.clause_atom and clause_atom.book_id = book.id where shebanq_note.note.keywords like '% { keywordsSql } %' and shebanq_note.note.version = ' { vr } ' and (shebanq_note.note.is_shared = 'T' { extra } ) ; \"\"\" ) dataRows = PASSAGE_DBS [ vr ] . executesql ( sql ) if vr in PASSAGE_DBS else [] else : ( nSlots , slotSets ) = ( Query . read ( vr , iid ) if qw == \"q\" else Word . read ( vr , iid ) ) slots = flatten ( slotSets ) dataRows = [] if len ( slots ): hflist = \", \" . join ( f \"word. { hf [ 0 ] } \" for hf in hebrewFields ) slotsVal = \",\" . join ( str ( x ) for x in slots ) sql = dedent ( f \"\"\" select book.name, chapter.chapter_num, verse.verse_num, { hflist } from word inner join word_verse on word_verse.anchor = word.word_number inner join verse on verse.id = word_verse.verse_id inner join chapter on verse.chapter_id = chapter.id inner join book on chapter.book_id = book.id where word.word_number in ( { slotsVal } ) order by word.word_number ; \"\"\" ) dataRows = PASSAGE_DBS [ vr ] . executesql ( sql ) if vr in PASSAGE_DBS else [] allRows = csv ([ headRow ] + list ( dataRows )) return allRows csv ( data ) \u00b6 converts an data structure of rows and fields into a csv string. With proper quotations and escapes Source code in modules/csvdata.py def csv ( data ): \"\"\"converts an data structure of rows and fields into a csv string. With proper quotations and escapes \"\"\" result = [] if data is not None : for row in data : prow = [ str ( x ) for x in row ] trow = [ f '''\" { x . replace ( '\"' , '\"\"' ) } \"''' if '\"' in x or \",\" in x else x for x in prow ] result . append (( \",\" . join ( trow )) . replace ( \" \\n \" , \" \" ) . replace ( \" \\r \" , \" \" )) return \" \\n \" . join ( result )","title":"Csvdata"},{"location":"server/bymodule/csvdata/#csvdata","text":"","title":"csvdata"},{"location":"server/bymodule/csvdata/#csvdata.CSVDATA","text":"Produces various kinds of csv exports of lists of items. Items are word occirrences, query results or noteset members.","title":"CSVDATA"},{"location":"server/bymodule/csvdata/#csvdata.CSVDATA.__init__","text":"Source code in modules/csvdata.py def __init__ ( self , Record , Word , Query ): self . Record = Record self . Word = Word self . Query = Query","title":"__init__()"},{"location":"server/bymodule/csvdata/#csvdata.CSVDATA.page","text":"Read request parameters and get the data and ready for the controller. Source code in modules/csvdata.py def page ( self ): \"\"\"Read request parameters and get the data and ready for the controller. \"\"\" ViewDefs = current . ViewDefs Check = current . Check Record = self . Record vr = Check . field ( \"material\" , \"\" , \"version\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) mr = Check . field ( \"material\" , \"\" , \"mr\" ) qw = Check . field ( \"material\" , \"\" , \"qw\" ) tp = Check . field ( \"material\" , \"\" , \"tp\" ) extra = Check . field ( \"rest\" , \"\" , \"extra\" ) ( iid , keywords ) = iDecode ( qw , iidRep ) iidRep2 = iDecode ( qw , iidRep , rsep = \" \" ) itemStyle = ViewDefs . itemStyle tabLabels = ViewDefs . tabLabels fileName = f \" { vr } _ { itemStyle [ qw ][ 't' ] }{ iidRep2 } _ { tabLabels [ tp ] }{ extra } .csv\" ( authorized , msg ) = Record . authRead ( mr , qw , iidRep ) if not authorized : return dict ( fileName = fileName , data = msg ) hebrewFields = Check . fields ( tp , qw = qw ) data = self . get ( vr , mr , qw , iid , keywords , tp , extra , hebrewFields , fileName ) return dict ( fileName = fileName , data = data )","title":"page()"},{"location":"server/bymodule/csvdata/#csvdata.CSVDATA.get","text":"Get csv data as specified by parameters. Source code in modules/csvdata.py def get ( self , vr , mr , qw , iid , keywords , tp , extra , hebrewFields , fileName ): \"\"\"Get csv data as specified by parameters. \"\"\" Word = self . Word Query = self . Query auth = current . auth PASSAGE_DBS = current . PASSAGE_DBS if extra : extra = \"_\" + extra if len ( extra ) > 64 : extra = extra [ 0 : 64 ] headRow = [ \"book\" , \"chapter\" , \"verse\" ] + [ hf [ 1 ] for hf in hebrewFields ] if qw == \"n\" : keywordsSql = keywords . replace ( \"'\" , \"''\" ) myId = auth . user . id if auth . user is not None else None extra = \"\" if myId is None else f \" or created_by = { myId } \" hflist = \", \" . join ( hf [ 0 ] for hf in hebrewFields ) sql = dedent ( f \"\"\" select shebanq_note.note.book, shebanq_note.note.chapter, shebanq_note.note.verse, { hflist } from shebanq_note.note inner join book on shebanq_note.note.book = book.name inner join clause_atom on clause_atom.ca_num = shebanq_note.note.clause_atom and clause_atom.book_id = book.id where shebanq_note.note.keywords like '% { keywordsSql } %' and shebanq_note.note.version = ' { vr } ' and (shebanq_note.note.is_shared = 'T' { extra } ) ; \"\"\" ) dataRows = PASSAGE_DBS [ vr ] . executesql ( sql ) if vr in PASSAGE_DBS else [] else : ( nSlots , slotSets ) = ( Query . read ( vr , iid ) if qw == \"q\" else Word . read ( vr , iid ) ) slots = flatten ( slotSets ) dataRows = [] if len ( slots ): hflist = \", \" . join ( f \"word. { hf [ 0 ] } \" for hf in hebrewFields ) slotsVal = \",\" . join ( str ( x ) for x in slots ) sql = dedent ( f \"\"\" select book.name, chapter.chapter_num, verse.verse_num, { hflist } from word inner join word_verse on word_verse.anchor = word.word_number inner join verse on verse.id = word_verse.verse_id inner join chapter on verse.chapter_id = chapter.id inner join book on chapter.book_id = book.id where word.word_number in ( { slotsVal } ) order by word.word_number ; \"\"\" ) dataRows = PASSAGE_DBS [ vr ] . executesql ( sql ) if vr in PASSAGE_DBS else [] allRows = csv ([ headRow ] + list ( dataRows )) return allRows","title":"get()"},{"location":"server/bymodule/csvdata/#csvdata.csv","text":"converts an data structure of rows and fields into a csv string. With proper quotations and escapes Source code in modules/csvdata.py def csv ( data ): \"\"\"converts an data structure of rows and fields into a csv string. With proper quotations and escapes \"\"\" result = [] if data is not None : for row in data : prow = [ str ( x ) for x in row ] trow = [ f '''\" { x . replace ( '\"' , '\"\"' ) } \"''' if '\"' in x or \",\" in x else x for x in prow ] result . append (( \",\" . join ( trow )) . replace ( \" \\n \" , \" \" ) . replace ( \" \\r \" , \" \" )) return \" \\n \" . join ( result )","title":"csv()"},{"location":"server/bymodule/dbconfig/","text":"dbconfig \u00b6 CONFIG \u00b6 Connection details for the databases. EMDROS_VERSIONS \u00b6 Emdros versions that have been in use by SHEBANQ. Copied manually from /opt/emdros/include/emdros/version-emdros.h configPath \u00b6","title":"Dbconfig"},{"location":"server/bymodule/dbconfig/#dbconfig","text":"","title":"dbconfig"},{"location":"server/bymodule/dbconfig/#dbconfig.CONFIG","text":"Connection details for the databases.","title":"CONFIG"},{"location":"server/bymodule/dbconfig/#dbconfig.EMDROS_VERSIONS","text":"Emdros versions that have been in use by SHEBANQ. Copied manually from /opt/emdros/include/emdros/version-emdros.h","title":"EMDROS_VERSIONS"},{"location":"server/bymodule/dbconfig/#dbconfig.configPath","text":"","title":"configPath"},{"location":"server/bymodule/helpers/","text":"helpers \u00b6 TO_LOGGER \u00b6 TO_RESPONSE \u00b6 TO_STDERR \u00b6 debug ( msg ) \u00b6 Issue a debug message. The message is written to the console and into a log file: shebanqDir /log/debug.log . It works on your local shebanq and the shebanq on a server. See logging . Source code in modules/helpers.py def debug ( msg ): \"\"\"Issue a debug message. The message is written to the console and into a log file: *shebanqDir*`/log/debug.log`. It works on your local shebanq and the shebanq on a server. See [logging]({{pythonLogging}}). \"\"\" if current . DEBUG : if TO_STDERR : sys . stderr . write ( f \" { msg } \\n \" ) if TO_LOGGER : current . logger . info ( f \" { msg } \" ) if TO_RESPONSE : msgRep = msg . replace ( \" \\n \" , \"<br>\" ) current . response . write ( f \" { msgRep } <br>\" ) isodt ( dt = None ) \u00b6 Source code in modules/helpers.py def isodt ( dt = None ): return ( datetime . utcnow () . strftime ( \"%Y-%m- %d T%H:%M:%SZ\" ) if dt is None else dt . strftime ( \"%Y-%m- %d T%H:%M:%SZ\" ) ) delta ( timeInterval ) \u00b6 Source code in modules/helpers.py def delta ( timeInterval ): return f \" { int ( round ( timeInterval * 100 )) / 100 } s\" hebKey ( x ) \u00b6 Source code in modules/helpers.py def hebKey ( x ): return x . replace ( \"\ufb2a\" , \"\u05e9\ufb2a\" ) . replace ( \"\ufb2b\" , \"\u05e9\ufb2b\" ) iEncode ( qw , idpart , keywords = None , sep = '|' ) \u00b6 Source code in modules/helpers.py def iEncode ( qw , idpart , keywords = None , sep = \"|\" ): if qw == \"n\" : return ( b64encode (( f \" { idpart } | { keywords } \" ) . encode ( \"utf8\" )) . decode ( \"utf8\" ) . replace ( \" \\n \" , \"\" ) . replace ( \"=\" , \"_\" ) ) if qw == \"w\" : return idpart if qw == \"q\" : return str ( idpart ) return str ( idpart ) iDecode ( qw , iidRep , sep = '|' , rsep = None ) \u00b6 Source code in modules/helpers.py def iDecode ( qw , iidRep , sep = \"|\" , rsep = None ): idpart = iidRep keywords = \"\" if qw == \"n\" : try : ( idpart , keywords ) = ( b64decode ( iidRep . replace ( \"_\" , \"=\" ) . encode ( \"utf8\" )) . decode ( \"utf8\" ) . split ( sep , 1 ) ) except Exception : ( idpart , keywords ) = ( None , None ) if qw == \"w\" : ( idpart , keywords ) = ( iidRep , \"\" ) if qw == \"q\" : ( idpart , keywords ) = ( int ( iidRep ) if iidRep . isdigit () else 0 , \"\" ) if rsep is None : result = ( idpart , keywords ) else : if qw == \"n\" : result = rsep . join (( str ( idpart ), keywords )) else : result = str ( idpart ) return result hEsc ( material , fill = True ) \u00b6 Source code in modules/helpers.py def hEsc ( material , fill = True ): material = ( material . replace ( \"&\" , \"&amp;\" ) . replace ( \"<\" , \"&lt;\" ) . replace ( \">\" , \"&gt;\" ) . replace ( '\"' , \"&quot;\" ) . replace ( \"'\" , \"&apos;\" ) . replace ( \" \\\\ n\" , \" \\n \" ) ) if fill : if material == \"\" : material = \"&nbsp;\" return material toAscii ( x ) \u00b6 Source code in modules/helpers.py def toAscii ( x ): return x . encode ( \"ascii\" , \"replace\" ) formatVersion ( qw , obj_id , vr , st ) \u00b6 Source code in modules/helpers.py def formatVersion ( qw , obj_id , vr , st ): if qw == \"q\" : keyName = \"query_id\" if st == 1 : icon = \"quote-right\" cls = \"special\" elif st == 2 : icon = \"quote-right\" cls = \"\" elif st == 3 : icon = \"gears\" cls = \"good\" elif st == 4 : icon = \"circle-o\" cls = \"warning\" elif st == 5 : icon = \"clock-o\" cls = \"error\" return f \"\"\"<a href=\"#\" class=\"ctl br { qw } { cls } fa fa- { icon } \" { keyName } =\" { obj_id } \" v=\" { vr } \"></a>\"\"\" else : keyName = \"key_id\" stRep = st if st else \"-\" return ( f '<a href=\"#\" class=\"ctl br { qw } \" { keyName } =\" { obj_id } \" v=\" { vr } \"> { stRep } </a>' ) pagelist ( page , pages , spread ) \u00b6 Source code in modules/helpers.py def pagelist ( page , pages , spread ): factor = 1 filteredPages = { 1 , page , pages } while factor <= pages : pageBase = factor * int ( page / factor ) filteredPages |= { pageBase + int (( i - spread / 2 ) * factor ) for i in range ( 2 * int ( spread / 2 ) + 1 ) } factor *= spread return sorted ( i for i in filteredPages if i > 0 and i <= pages ) countSlots ( rows ) \u00b6 Source code in modules/helpers.py def countSlots ( rows ): covered = set () for ( b , e ) in rows : covered |= set ( range ( b , e + 1 )) return len ( covered ) flatten ( msets ) \u00b6 Source code in modules/helpers.py def flatten ( msets ): result = set () for ( b , e ) in msets : for m in range ( b , e + 1 ): result . add ( m ) return list ( sorted ( result )) collapseToRanges ( slots ) \u00b6 Source code in modules/helpers.py def collapseToRanges ( slots ): covered = set () for start in slots : covered . add ( start ) return normRanges ( None , fromset = covered ) normRanges ( ranges , fromset = None ) \u00b6 Source code in modules/helpers.py def normRanges ( ranges , fromset = None ): covered = set () if fromset is not None : covered = fromset else : for ( start , end ) in ranges : for i in range ( start , end + 1 ): covered . add ( i ) curStart = None curEnd = None result = [] for i in sorted ( covered ): if i not in covered : if curEnd is not None : result . append (( curStart , curEnd - 1 )) curStart = None curEnd = None elif curEnd is None or i > curEnd : if curEnd is not None : result . append (( curStart , curEnd - 1 )) curStart = i curEnd = i + 1 else : curEnd = i + 1 if curEnd is not None : result . append (( curStart , curEnd - 1 )) return ( len ( covered ), result ) sanitize ( text ) \u00b6 We need to hEsc the markdown text. But markdown does an extra layer of escaping & inside href attributes. We have to unescape doubly escaped & . Source code in modules/helpers.py def sanitize ( text ): \"\"\"We need to hEsc the markdown text. But markdown does an extra layer of escaping `&` inside `href` attributes. We have to unescape doubly escaped `&`. \"\"\" return text . replace ( \"&amp;amp;\" , \"&amp;\" )","title":"Helpers"},{"location":"server/bymodule/helpers/#helpers","text":"","title":"helpers"},{"location":"server/bymodule/helpers/#helpers.TO_LOGGER","text":"","title":"TO_LOGGER"},{"location":"server/bymodule/helpers/#helpers.TO_RESPONSE","text":"","title":"TO_RESPONSE"},{"location":"server/bymodule/helpers/#helpers.TO_STDERR","text":"","title":"TO_STDERR"},{"location":"server/bymodule/helpers/#helpers.debug","text":"Issue a debug message. The message is written to the console and into a log file: shebanqDir /log/debug.log . It works on your local shebanq and the shebanq on a server. See logging . Source code in modules/helpers.py def debug ( msg ): \"\"\"Issue a debug message. The message is written to the console and into a log file: *shebanqDir*`/log/debug.log`. It works on your local shebanq and the shebanq on a server. See [logging]({{pythonLogging}}). \"\"\" if current . DEBUG : if TO_STDERR : sys . stderr . write ( f \" { msg } \\n \" ) if TO_LOGGER : current . logger . info ( f \" { msg } \" ) if TO_RESPONSE : msgRep = msg . replace ( \" \\n \" , \"<br>\" ) current . response . write ( f \" { msgRep } <br>\" )","title":"debug()"},{"location":"server/bymodule/helpers/#helpers.isodt","text":"Source code in modules/helpers.py def isodt ( dt = None ): return ( datetime . utcnow () . strftime ( \"%Y-%m- %d T%H:%M:%SZ\" ) if dt is None else dt . strftime ( \"%Y-%m- %d T%H:%M:%SZ\" ) )","title":"isodt()"},{"location":"server/bymodule/helpers/#helpers.delta","text":"Source code in modules/helpers.py def delta ( timeInterval ): return f \" { int ( round ( timeInterval * 100 )) / 100 } s\"","title":"delta()"},{"location":"server/bymodule/helpers/#helpers.hebKey","text":"Source code in modules/helpers.py def hebKey ( x ): return x . replace ( \"\ufb2a\" , \"\u05e9\ufb2a\" ) . replace ( \"\ufb2b\" , \"\u05e9\ufb2b\" )","title":"hebKey()"},{"location":"server/bymodule/helpers/#helpers.iEncode","text":"Source code in modules/helpers.py def iEncode ( qw , idpart , keywords = None , sep = \"|\" ): if qw == \"n\" : return ( b64encode (( f \" { idpart } | { keywords } \" ) . encode ( \"utf8\" )) . decode ( \"utf8\" ) . replace ( \" \\n \" , \"\" ) . replace ( \"=\" , \"_\" ) ) if qw == \"w\" : return idpart if qw == \"q\" : return str ( idpart ) return str ( idpart )","title":"iEncode()"},{"location":"server/bymodule/helpers/#helpers.iDecode","text":"Source code in modules/helpers.py def iDecode ( qw , iidRep , sep = \"|\" , rsep = None ): idpart = iidRep keywords = \"\" if qw == \"n\" : try : ( idpart , keywords ) = ( b64decode ( iidRep . replace ( \"_\" , \"=\" ) . encode ( \"utf8\" )) . decode ( \"utf8\" ) . split ( sep , 1 ) ) except Exception : ( idpart , keywords ) = ( None , None ) if qw == \"w\" : ( idpart , keywords ) = ( iidRep , \"\" ) if qw == \"q\" : ( idpart , keywords ) = ( int ( iidRep ) if iidRep . isdigit () else 0 , \"\" ) if rsep is None : result = ( idpart , keywords ) else : if qw == \"n\" : result = rsep . join (( str ( idpart ), keywords )) else : result = str ( idpart ) return result","title":"iDecode()"},{"location":"server/bymodule/helpers/#helpers.hEsc","text":"Source code in modules/helpers.py def hEsc ( material , fill = True ): material = ( material . replace ( \"&\" , \"&amp;\" ) . replace ( \"<\" , \"&lt;\" ) . replace ( \">\" , \"&gt;\" ) . replace ( '\"' , \"&quot;\" ) . replace ( \"'\" , \"&apos;\" ) . replace ( \" \\\\ n\" , \" \\n \" ) ) if fill : if material == \"\" : material = \"&nbsp;\" return material","title":"hEsc()"},{"location":"server/bymodule/helpers/#helpers.toAscii","text":"Source code in modules/helpers.py def toAscii ( x ): return x . encode ( \"ascii\" , \"replace\" )","title":"toAscii()"},{"location":"server/bymodule/helpers/#helpers.formatVersion","text":"Source code in modules/helpers.py def formatVersion ( qw , obj_id , vr , st ): if qw == \"q\" : keyName = \"query_id\" if st == 1 : icon = \"quote-right\" cls = \"special\" elif st == 2 : icon = \"quote-right\" cls = \"\" elif st == 3 : icon = \"gears\" cls = \"good\" elif st == 4 : icon = \"circle-o\" cls = \"warning\" elif st == 5 : icon = \"clock-o\" cls = \"error\" return f \"\"\"<a href=\"#\" class=\"ctl br { qw } { cls } fa fa- { icon } \" { keyName } =\" { obj_id } \" v=\" { vr } \"></a>\"\"\" else : keyName = \"key_id\" stRep = st if st else \"-\" return ( f '<a href=\"#\" class=\"ctl br { qw } \" { keyName } =\" { obj_id } \" v=\" { vr } \"> { stRep } </a>' )","title":"formatVersion()"},{"location":"server/bymodule/helpers/#helpers.pagelist","text":"Source code in modules/helpers.py def pagelist ( page , pages , spread ): factor = 1 filteredPages = { 1 , page , pages } while factor <= pages : pageBase = factor * int ( page / factor ) filteredPages |= { pageBase + int (( i - spread / 2 ) * factor ) for i in range ( 2 * int ( spread / 2 ) + 1 ) } factor *= spread return sorted ( i for i in filteredPages if i > 0 and i <= pages )","title":"pagelist()"},{"location":"server/bymodule/helpers/#helpers.countSlots","text":"Source code in modules/helpers.py def countSlots ( rows ): covered = set () for ( b , e ) in rows : covered |= set ( range ( b , e + 1 )) return len ( covered )","title":"countSlots()"},{"location":"server/bymodule/helpers/#helpers.flatten","text":"Source code in modules/helpers.py def flatten ( msets ): result = set () for ( b , e ) in msets : for m in range ( b , e + 1 ): result . add ( m ) return list ( sorted ( result ))","title":"flatten()"},{"location":"server/bymodule/helpers/#helpers.collapseToRanges","text":"Source code in modules/helpers.py def collapseToRanges ( slots ): covered = set () for start in slots : covered . add ( start ) return normRanges ( None , fromset = covered )","title":"collapseToRanges()"},{"location":"server/bymodule/helpers/#helpers.normRanges","text":"Source code in modules/helpers.py def normRanges ( ranges , fromset = None ): covered = set () if fromset is not None : covered = fromset else : for ( start , end ) in ranges : for i in range ( start , end + 1 ): covered . add ( i ) curStart = None curEnd = None result = [] for i in sorted ( covered ): if i not in covered : if curEnd is not None : result . append (( curStart , curEnd - 1 )) curStart = None curEnd = None elif curEnd is None or i > curEnd : if curEnd is not None : result . append (( curStart , curEnd - 1 )) curStart = i curEnd = i + 1 else : curEnd = i + 1 if curEnd is not None : result . append (( curStart , curEnd - 1 )) return ( len ( covered ), result )","title":"normRanges()"},{"location":"server/bymodule/helpers/#helpers.sanitize","text":"We need to hEsc the markdown text. But markdown does an extra layer of escaping & inside href attributes. We have to unescape doubly escaped & . Source code in modules/helpers.py def sanitize ( text ): \"\"\"We need to hEsc the markdown text. But markdown does an extra layer of escaping `&` inside `href` attributes. We have to unescape doubly escaped `&`. \"\"\" return text . replace ( \"&amp;amp;\" , \"&amp;\" )","title":"sanitize()"},{"location":"server/bymodule/materials/","text":"materials \u00b6 RESULT_PAGE_SIZE \u00b6 MATERIAL \u00b6 Responsible for the data for the main area of the page. See {Material} \u2208 book , \u2208 chapter , \u2208 page , __init__ ( self , Record , Word , Query , Note ) special \u00b6 Source code in modules/materials.py def __init__ ( self , Record , Word , Query , Note ): self . Record = Record self . Word = Word self . Query = Query self . Note = Note page ( self ) \u00b6 Source code in modules/materials.py def page ( self ): Check = current . Check Record = self . Record mr = Check . field ( \"material\" , \"\" , \"mr\" ) qw = Check . field ( \"material\" , \"\" , \"qw\" ) vr = Check . field ( \"material\" , \"\" , \"version\" ) bk = Check . field ( \"material\" , \"\" , \"book\" ) ch = Check . field ( \"material\" , \"\" , \"chapter\" ) tp = Check . field ( \"material\" , \"\" , \"tp\" ) tr = Check . field ( \"material\" , \"\" , \"tr\" ) lang = Check . field ( \"material\" , \"\" , \"lang\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) page = Check . field ( \"material\" , \"\" , \"page\" ) ( authorized , msg ) = Record . authRead ( mr , qw , iidRep ) if not authorized : return dict ( version = vr , mr = mr , qw = qw , msg = msg , hits = 0 , results = 0 , pages = 0 , page = 0 , pagelist = json . dumps ([]), material = None , slots = json . dumps ([]), ) return self . get ( vr , mr , qw , bk , iidRep , ch , page , tp , tr , lang ) getPassage ( self , vr , bk , ch ) \u00b6 Source code in modules/materials.py def getPassage ( self , vr , bk , ch ): Caching = current . Caching return Caching . get ( f \"passage_ { vr } _ { bk } _ { ch } \" , lambda : self . getPassage_c ( vr , bk , ch ), ALWAYS , ) getPassage_c ( self , vr , bookname , chapternum ) \u00b6 Source code in modules/materials.py def getPassage_c ( self , vr , bookname , chapternum ): PASSAGE_DBS = current . PASSAGE_DBS if bookname is None or chapternum is None or vr not in PASSAGE_DBS : return ({}, {}) bookrecords = PASSAGE_DBS [ vr ] . executesql ( dedent ( f \"\"\" select * from book where name = ' { bookname } ' ; \"\"\" ), as_dict = True , ) book = bookrecords [ 0 ] if bookrecords else {} if book and \"id\" in book : chapterrecords = PASSAGE_DBS [ vr ] . executesql ( dedent ( f \"\"\" select * from chapter where chapter_num = { chapternum } and book_id = { book [ \"id\" ] } ; \"\"\" ), as_dict = True , ) chapter = chapterrecords [ 0 ] if chapterrecords else {} else : chapter = {} return ( book , chapter ) get ( self , vr , mr , qw , bk , iidRep , ch , page , tp , tr , lang ) \u00b6 Source code in modules/materials.py def get ( self , vr , mr , qw , bk , iidRep , ch , page , tp , tr , lang ): Caching = current . Caching mrrep = \"m\" if mr == \"m\" else qw book = bk if mr == \"m\" else iidRep chapter = ch if mr == \"m\" else page return Caching . get ( f \"verses_ { vr } _ { mrrep } _ { book } _ { chapter } _ { tp } _ { tr } _ { lang } _\" , lambda : self . get_c ( vr , mr , qw , bk , iidRep , ch , page , tp , tr , lang ), ONE_HOUR , ) get_c ( self , vr , mr , qw , bk , iidRep , ch , page , tp , tr , lang ) \u00b6 Source code in modules/materials.py def get_c ( self , vr , mr , qw , bk , iidRep , ch , page , tp , tr , lang ): Word = self . Word Query = self . Query Note = self . Note if mr == \"m\" : ( book , chapter ) = self . getPassage ( vr , bk , ch ) material = ( VERSESCONTENT ( vr , mr , chapter = chapter [ \"id\" ], tp = tp , tr = tr , lang = lang ) if chapter else None ) result = dict ( mr = mr , qw = qw , hits = 0 , msg = f \" { bk } { ch } does not exist\" if not chapter else None , results = len ( material . verses ) if material else 0 , pages = 1 , material = material , slots = json . dumps ([]), ) elif mr == \"r\" : ( iid , keywords ) = ( None , None ) if iidRep is not None : ( iid , keywords ) = iDecode ( qw , iidRep ) if iid is None : kind = \"query\" if qw == \"q\" else \"word\" if qw == \"w\" else \"note set\" msg = f \"No { kind } selected\" result = dict ( mr = mr , qw = qw , msg = msg , hits = 0 , results = 0 , pages = 0 , page = 0 , pagelist = json . dumps ([]), material = None , slots = json . dumps ([]), ) else : ( nSlots , slotSets ) = ( Query . read ( vr , iid ) if qw == \"q\" else Word . read ( vr , iid ) if qw == \"w\" else Note . read ( vr , iid , keywords ) ) ( nresults , npages , verses , slots ) = self . getPagination ( vr , page , slotSets ) material = VERSESCONTENT ( vr , mr , verses , tp = tp , tr = tr , lang = lang ) result = dict ( mr = mr , qw = qw , msg = None , hits = nSlots , results = nresults , pages = npages , page = page , pagelist = json . dumps ( pagelist ( page , npages , 10 )), material = material , slots = json . dumps ( slots ), ) else : result = dict () return result getPagination ( self , vr , p , slotSets ) \u00b6 Source code in modules/materials.py def getPagination ( self , vr , p , slotSets ): Caching = current . Caching PASSAGE_DBS = current . PASSAGE_DBS verseBoundaries = ( Caching . get ( f \"verse_boundaries_ { vr } _\" , lambda : PASSAGE_DBS [ vr ] . executesql ( dedent ( \"\"\" select first_m, last_m from verse order by id ; \"\"\" ) ), ALWAYS , ) if vr in PASSAGE_DBS else [] ) m = 0 # slot range index, walking through slotSets v = 0 # verse id, walking through verseBoundaries nvp = 0 # number of verses added to current page nvt = 0 # number of verses added in total nM = len ( slotSets ) nV = len ( verseBoundaries ) curPage = 1 # current page verseIds = [] verseSlots = set () lastVerse = - 1 while m < nM and v < nV : if nvp == RESULT_PAGE_SIZE : nvp = 0 curPage += 1 ( vB , vE ) = verseBoundaries [ v ] ( mB , mE ) = slotSets [ m ] if vE < mB : v += 1 continue if mE < vB : m += 1 continue # now vE >= mB and mE >= vB so one of the following holds # vvvvvv # mmmmm # mmmmmmmmmmmmmmm # mmm # mmmmmmmmmmmmm # so (vB, vE) and (mB, mE) overlap # so add v to the result pages and go to the next verse # and add p to the highlight list if on the selected page if v != lastVerse : if curPage == p : verseIds . append ( v ) lastVerse = v nvp += 1 nvt += 1 if lastVerse == v : clippedSLots = set ( range ( max ( vB , mB ), min ( vE , mE ) + 1 )) verseSlots |= clippedSLots if curPage != p : v += 1 else : if mE < vE : m += 1 else : v += 1 verses = verseIds if p <= curPage and len ( verseIds ) else None return ( nvt , curPage if nvt else 0 , verses , list ( verseSlots ))","title":"Materials"},{"location":"server/bymodule/materials/#materials","text":"","title":"materials"},{"location":"server/bymodule/materials/#materials.RESULT_PAGE_SIZE","text":"","title":"RESULT_PAGE_SIZE"},{"location":"server/bymodule/materials/#materials.MATERIAL","text":"Responsible for the data for the main area of the page. See {Material} \u2208 book , \u2208 chapter , \u2208 page ,","title":"MATERIAL"},{"location":"server/bymodule/materials/#materials.MATERIAL.__init__","text":"Source code in modules/materials.py def __init__ ( self , Record , Word , Query , Note ): self . Record = Record self . Word = Word self . Query = Query self . Note = Note","title":"__init__()"},{"location":"server/bymodule/materials/#materials.MATERIAL.page","text":"Source code in modules/materials.py def page ( self ): Check = current . Check Record = self . Record mr = Check . field ( \"material\" , \"\" , \"mr\" ) qw = Check . field ( \"material\" , \"\" , \"qw\" ) vr = Check . field ( \"material\" , \"\" , \"version\" ) bk = Check . field ( \"material\" , \"\" , \"book\" ) ch = Check . field ( \"material\" , \"\" , \"chapter\" ) tp = Check . field ( \"material\" , \"\" , \"tp\" ) tr = Check . field ( \"material\" , \"\" , \"tr\" ) lang = Check . field ( \"material\" , \"\" , \"lang\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) page = Check . field ( \"material\" , \"\" , \"page\" ) ( authorized , msg ) = Record . authRead ( mr , qw , iidRep ) if not authorized : return dict ( version = vr , mr = mr , qw = qw , msg = msg , hits = 0 , results = 0 , pages = 0 , page = 0 , pagelist = json . dumps ([]), material = None , slots = json . dumps ([]), ) return self . get ( vr , mr , qw , bk , iidRep , ch , page , tp , tr , lang )","title":"page()"},{"location":"server/bymodule/materials/#materials.MATERIAL.getPassage","text":"Source code in modules/materials.py def getPassage ( self , vr , bk , ch ): Caching = current . Caching return Caching . get ( f \"passage_ { vr } _ { bk } _ { ch } \" , lambda : self . getPassage_c ( vr , bk , ch ), ALWAYS , )","title":"getPassage()"},{"location":"server/bymodule/materials/#materials.MATERIAL.getPassage_c","text":"Source code in modules/materials.py def getPassage_c ( self , vr , bookname , chapternum ): PASSAGE_DBS = current . PASSAGE_DBS if bookname is None or chapternum is None or vr not in PASSAGE_DBS : return ({}, {}) bookrecords = PASSAGE_DBS [ vr ] . executesql ( dedent ( f \"\"\" select * from book where name = ' { bookname } ' ; \"\"\" ), as_dict = True , ) book = bookrecords [ 0 ] if bookrecords else {} if book and \"id\" in book : chapterrecords = PASSAGE_DBS [ vr ] . executesql ( dedent ( f \"\"\" select * from chapter where chapter_num = { chapternum } and book_id = { book [ \"id\" ] } ; \"\"\" ), as_dict = True , ) chapter = chapterrecords [ 0 ] if chapterrecords else {} else : chapter = {} return ( book , chapter )","title":"getPassage_c()"},{"location":"server/bymodule/materials/#materials.MATERIAL.get","text":"Source code in modules/materials.py def get ( self , vr , mr , qw , bk , iidRep , ch , page , tp , tr , lang ): Caching = current . Caching mrrep = \"m\" if mr == \"m\" else qw book = bk if mr == \"m\" else iidRep chapter = ch if mr == \"m\" else page return Caching . get ( f \"verses_ { vr } _ { mrrep } _ { book } _ { chapter } _ { tp } _ { tr } _ { lang } _\" , lambda : self . get_c ( vr , mr , qw , bk , iidRep , ch , page , tp , tr , lang ), ONE_HOUR , )","title":"get()"},{"location":"server/bymodule/materials/#materials.MATERIAL.get_c","text":"Source code in modules/materials.py def get_c ( self , vr , mr , qw , bk , iidRep , ch , page , tp , tr , lang ): Word = self . Word Query = self . Query Note = self . Note if mr == \"m\" : ( book , chapter ) = self . getPassage ( vr , bk , ch ) material = ( VERSESCONTENT ( vr , mr , chapter = chapter [ \"id\" ], tp = tp , tr = tr , lang = lang ) if chapter else None ) result = dict ( mr = mr , qw = qw , hits = 0 , msg = f \" { bk } { ch } does not exist\" if not chapter else None , results = len ( material . verses ) if material else 0 , pages = 1 , material = material , slots = json . dumps ([]), ) elif mr == \"r\" : ( iid , keywords ) = ( None , None ) if iidRep is not None : ( iid , keywords ) = iDecode ( qw , iidRep ) if iid is None : kind = \"query\" if qw == \"q\" else \"word\" if qw == \"w\" else \"note set\" msg = f \"No { kind } selected\" result = dict ( mr = mr , qw = qw , msg = msg , hits = 0 , results = 0 , pages = 0 , page = 0 , pagelist = json . dumps ([]), material = None , slots = json . dumps ([]), ) else : ( nSlots , slotSets ) = ( Query . read ( vr , iid ) if qw == \"q\" else Word . read ( vr , iid ) if qw == \"w\" else Note . read ( vr , iid , keywords ) ) ( nresults , npages , verses , slots ) = self . getPagination ( vr , page , slotSets ) material = VERSESCONTENT ( vr , mr , verses , tp = tp , tr = tr , lang = lang ) result = dict ( mr = mr , qw = qw , msg = None , hits = nSlots , results = nresults , pages = npages , page = page , pagelist = json . dumps ( pagelist ( page , npages , 10 )), material = material , slots = json . dumps ( slots ), ) else : result = dict () return result","title":"get_c()"},{"location":"server/bymodule/materials/#materials.MATERIAL.getPagination","text":"Source code in modules/materials.py def getPagination ( self , vr , p , slotSets ): Caching = current . Caching PASSAGE_DBS = current . PASSAGE_DBS verseBoundaries = ( Caching . get ( f \"verse_boundaries_ { vr } _\" , lambda : PASSAGE_DBS [ vr ] . executesql ( dedent ( \"\"\" select first_m, last_m from verse order by id ; \"\"\" ) ), ALWAYS , ) if vr in PASSAGE_DBS else [] ) m = 0 # slot range index, walking through slotSets v = 0 # verse id, walking through verseBoundaries nvp = 0 # number of verses added to current page nvt = 0 # number of verses added in total nM = len ( slotSets ) nV = len ( verseBoundaries ) curPage = 1 # current page verseIds = [] verseSlots = set () lastVerse = - 1 while m < nM and v < nV : if nvp == RESULT_PAGE_SIZE : nvp = 0 curPage += 1 ( vB , vE ) = verseBoundaries [ v ] ( mB , mE ) = slotSets [ m ] if vE < mB : v += 1 continue if mE < vB : m += 1 continue # now vE >= mB and mE >= vB so one of the following holds # vvvvvv # mmmmm # mmmmmmmmmmmmmmm # mmm # mmmmmmmmmmmmm # so (vB, vE) and (mB, mE) overlap # so add v to the result pages and go to the next verse # and add p to the highlight list if on the selected page if v != lastVerse : if curPage == p : verseIds . append ( v ) lastVerse = v nvp += 1 nvt += 1 if lastVerse == v : clippedSLots = set ( range ( max ( vB , mB ), min ( vE , mE ) + 1 )) verseSlots |= clippedSLots if curPage != p : v += 1 else : if mE < vE : m += 1 else : v += 1 verses = verseIds if p <= curPage and len ( verseIds ) else None return ( nvt , curPage if nvt else 0 , verses , list ( verseSlots ))","title":"getPagination()"},{"location":"server/bymodule/mql/","text":"mql \u00b6 EMDROS_VERSION \u00b6 ITER_LIMIT \u00b6 OLD_EMDROS_VERSIONS \u00b6 db \u00b6 LimitError ( Exception ) \u00b6 __init__ ( self , message , cause = None ) special \u00b6 Source code in modules/mql.py def __init__ ( self , message , cause = None ): Exception . __init__ ( self , message ) sanitize ( query , msgs ) \u00b6 Source code in modules/mql.py def sanitize ( query , msgs ): comps = query . split ( \"/*\" ) lastcomp = comps [ - 1 ] if len ( comps ) > 1 and lastcomp . find ( \"*/\" ) == - 1 : result = query + \"*/\" else : result = query if \"focus\" not in query . lower (): msgs . append (( \"note\" , \"no FOCUS in your query!\" )) return result + \" \\n GO \\n \" toSlotSets ( setstr ) \u00b6 Source code in modules/mql.py def toSlotSets ( setstr ): elems = setstr [ 2 : - 2 ] . strip () if elems == \"\" : return [] comps = elems . split ( \",\" ) return [ [ int ( y ) for y in x . lstrip () . split ( \"-\" )] if \"-\" in x else [ int ( x ), int ( x )] for x in comps ] sheafResults ( sheaf ) \u00b6 Source code in modules/mql.py def sheafResults ( sheaf ): itr = sheaf . iterator () n = 0 while itr . hasNext (): straw = itr . current () n += strawResults ( straw ) if n > ITER_LIMIT : raise LimitError ( \"\" ) itr . next () return n strawResults ( straw ) \u00b6 Source code in modules/mql.py def strawResults ( straw ): n = 1 itr = straw . const_iterator () while itr . hasNext (): mo = itr . current () if not mo . sheafIsEmpty (): sheaf = mo . getSheaf () n *= sheafResults ( sheaf ) if n > ITER_LIMIT : raise LimitError ( \"\" ) itr . next () return n mql ( vr , query ) \u00b6 Source code in modules/mql.py def mql ( vr , query ): env = EmdrosPy . EmdrosEnv ( EmdrosPy . kOKConsole , EmdrosPy . kCSUTF8 , CONFIG [ \"shebanqHost\" ], CONFIG [ \"shebanqUser\" ], CONFIG [ \"shebanqPassword\" ], db + vr , EmdrosPy . kMySQL , ) compilerResult = False msgs = [] good = env . executeString ( sanitize ( query , msgs ), compilerResult , False , False )[ 1 ] limitExceeded = False if not good : msgs . append (( \"error\" , env . getCompilerError ())) return ( False , False , None , None , msgs , EMDROS_VERSION ) else : if not env . isSheaf : msgs . append (( \"error\" , \"Result of query is not a sheaf\" )) return ( False , False , None , None , msgs , EMDROS_VERSION ) else : sheaf = env . getSheaf () if sheaf is None : msgs . append (( \"error\" , \"Result of query is the null sheaf\" )) return ( False , False , 0 , [], msgs , EMDROS_VERSION ) else : try : n = sheafResults ( sheaf ) except LimitError : n = ITER_LIMIT limitExceeded = True if not limitExceeded : ms = toSlotSets ( sheaf . getSOM ( True ) . toString ()) else : ms = [] msgs . append ( ( \"error\" , \"\"\"Too many results (much more than there are words in the Bible). Try to limit results by putting a containing block around a sequence of blocks with .. between them. Not: [word] .. [word] .. [word] But: [chapter [word] .. [word] .. [word] ] \"\"\" , ) ) return ( True , limitExceeded , n , ms , msgs , EMDROS_VERSION )","title":"Mql"},{"location":"server/bymodule/mql/#mql","text":"","title":"mql"},{"location":"server/bymodule/mql/#mql.EMDROS_VERSION","text":"","title":"EMDROS_VERSION"},{"location":"server/bymodule/mql/#mql.ITER_LIMIT","text":"","title":"ITER_LIMIT"},{"location":"server/bymodule/mql/#mql.OLD_EMDROS_VERSIONS","text":"","title":"OLD_EMDROS_VERSIONS"},{"location":"server/bymodule/mql/#mql.db","text":"","title":"db"},{"location":"server/bymodule/mql/#mql.LimitError","text":"","title":"LimitError"},{"location":"server/bymodule/mql/#mql.LimitError.__init__","text":"Source code in modules/mql.py def __init__ ( self , message , cause = None ): Exception . __init__ ( self , message )","title":"__init__()"},{"location":"server/bymodule/mql/#mql.sanitize","text":"Source code in modules/mql.py def sanitize ( query , msgs ): comps = query . split ( \"/*\" ) lastcomp = comps [ - 1 ] if len ( comps ) > 1 and lastcomp . find ( \"*/\" ) == - 1 : result = query + \"*/\" else : result = query if \"focus\" not in query . lower (): msgs . append (( \"note\" , \"no FOCUS in your query!\" )) return result + \" \\n GO \\n \"","title":"sanitize()"},{"location":"server/bymodule/mql/#mql.toSlotSets","text":"Source code in modules/mql.py def toSlotSets ( setstr ): elems = setstr [ 2 : - 2 ] . strip () if elems == \"\" : return [] comps = elems . split ( \",\" ) return [ [ int ( y ) for y in x . lstrip () . split ( \"-\" )] if \"-\" in x else [ int ( x ), int ( x )] for x in comps ]","title":"toSlotSets()"},{"location":"server/bymodule/mql/#mql.sheafResults","text":"Source code in modules/mql.py def sheafResults ( sheaf ): itr = sheaf . iterator () n = 0 while itr . hasNext (): straw = itr . current () n += strawResults ( straw ) if n > ITER_LIMIT : raise LimitError ( \"\" ) itr . next () return n","title":"sheafResults()"},{"location":"server/bymodule/mql/#mql.strawResults","text":"Source code in modules/mql.py def strawResults ( straw ): n = 1 itr = straw . const_iterator () while itr . hasNext (): mo = itr . current () if not mo . sheafIsEmpty (): sheaf = mo . getSheaf () n *= sheafResults ( sheaf ) if n > ITER_LIMIT : raise LimitError ( \"\" ) itr . next () return n","title":"strawResults()"},{"location":"server/bymodule/mql/#mql.mql","text":"Source code in modules/mql.py def mql ( vr , query ): env = EmdrosPy . EmdrosEnv ( EmdrosPy . kOKConsole , EmdrosPy . kCSUTF8 , CONFIG [ \"shebanqHost\" ], CONFIG [ \"shebanqUser\" ], CONFIG [ \"shebanqPassword\" ], db + vr , EmdrosPy . kMySQL , ) compilerResult = False msgs = [] good = env . executeString ( sanitize ( query , msgs ), compilerResult , False , False )[ 1 ] limitExceeded = False if not good : msgs . append (( \"error\" , env . getCompilerError ())) return ( False , False , None , None , msgs , EMDROS_VERSION ) else : if not env . isSheaf : msgs . append (( \"error\" , \"Result of query is not a sheaf\" )) return ( False , False , None , None , msgs , EMDROS_VERSION ) else : sheaf = env . getSheaf () if sheaf is None : msgs . append (( \"error\" , \"Result of query is the null sheaf\" )) return ( False , False , 0 , [], msgs , EMDROS_VERSION ) else : try : n = sheafResults ( sheaf ) except LimitError : n = ITER_LIMIT limitExceeded = True if not limitExceeded : ms = toSlotSets ( sheaf . getSOM ( True ) . toString ()) else : ms = [] msgs . append ( ( \"error\" , \"\"\"Too many results (much more than there are words in the Bible). Try to limit results by putting a containing block around a sequence of blocks with .. between them. Not: [word] .. [word] .. [word] But: [chapter [word] .. [word] .. [word] ] \"\"\" , ) ) return ( True , limitExceeded , n , ms , msgs , EMDROS_VERSION )","title":"mql()"},{"location":"server/bymodule/note/","text":"note \u00b6 NOTE \u00b6 Handles notes. __init__ ( self , Books ) special \u00b6 Source code in modules/note.py def __init__ ( self , Books ): self . Books = Books authUpload ( self ) \u00b6 Source code in modules/note.py def authUpload ( self ): auth = current . auth db = current . db myId = None authorized = False if auth . user : myId = auth . user . id if myId : sql = dedent ( f \"\"\" select uid from uploaders where uid = { myId } \"\"\" ) records = db . executesql ( sql ) authorized = ( records is not None and len ( records ) == 1 and records [ 0 ][ 0 ] == myId ) msg = \"\" if authorized else \"you are not allowed to upload notes as csv files\" return ( authorized , myId , msg ) page ( self , ViewSettings ) \u00b6 Source code in modules/note.py def page ( self , ViewSettings ): Check = current . Check pageConfig = ViewSettings . writeConfig () key_id = Check . isId ( \"goto\" , \"n\" , \"note\" , []) ( authorized , myId , msg ) = self . authUpload () return dict ( pageConfig = pageConfig , key_id = key_id , mayUpload = authorized , user_id = myId , ) getVerseNotes ( self ) \u00b6 Get the notes belonging to a single verse. Reads request parameters to determine which verse. Source code in modules/note.py def getVerseNotes ( self ): \"\"\"Get the notes belonging to a single verse. Reads request parameters to determine which verse. \"\"\" Check = current . Check auth = current . auth vr = Check . field ( \"material\" , \"\" , \"version\" ) bk = Check . field ( \"material\" , \"\" , \"book\" ) ch = Check . field ( \"material\" , \"\" , \"chapter\" ) vs = Check . field ( \"material\" , \"\" , \"verse\" ) edit = Check . isBool ( \"edit\" ) myId = None if auth . user : myId = auth . user . id authenticated = myId is not None clauseAtoms = self . getClauseAtoms ( vr , bk , ch , vs ) changed = False msgs = [] return self . inVerse ( vr , bk , ch , vs , myId , clauseAtoms , changed , msgs , authenticated , edit ) body ( self ) \u00b6 Retrieves a note set record based on parameters. Source code in modules/note.py def body ( self ): \"\"\"Retrieves a note set record based on parameters. \"\"\" Check = current . Check vr = Check . field ( \"material\" , \"\" , \"version\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) ( iid , keywords ) = iDecode ( \"n\" , iidRep ) msgs = [] if not iid : msg = f \"Not a valid note id: { iid } \" msgs . append (( \"error\" , msg )) return dict ( noteRecord = dict (), note = json . dumps ( dict ()), msgs = json . dumps ( msgs ), ) noteRecord = self . getInfo ( iidRep , vr , msgs ) return dict ( vr = vr , noteRecord = noteRecord , note = json . dumps ( noteRecord ), msgs = json . dumps ( msgs ), ) getItems ( self , vr , book , chapter , is_published ) \u00b6 Source code in modules/note.py def getItems ( self , vr , book , chapter , is_published ): NOTE_DB = current . NOTE_DB bk = book [ \"name\" ] ch = chapter [ \"chapter_num\" ] if is_published == \"x\" : isPubVersion = \"\" else : isPubVersion = \" and is_published = 'T'\" sql = dedent ( f \"\"\" select note.created_by, shebanq_web.auth_user.first_name, shebanq_web.auth_user.last_name, note.keywords, note.verse, note.is_published from note inner join shebanq_web.auth_user on shebanq_web.auth_user.id = created_by where version = ' { vr } ' and book = ' { bk } ' and chapter = { ch } { isPubVersion } order by note.verse ; \"\"\" ) records = NOTE_DB . executesql ( sql ) user = {} nPublished = collections . Counter () nNotes = collections . Counter () nVerses = {} for ( user_id , first_name , last_name , keywords , v , is_published ) in records : if user_id not in user : user [ user_id ] = ( first_name , last_name ) for keyword in set ( keywords . strip () . split ()): if is_published == \"T\" : nPublished [( user_id , keyword )] += 1 nNotes [( user_id , keyword )] += 1 nVerses . setdefault (( user_id , keyword ), set ()) . add ( v ) r = [] for ( user_id , keyword ) in nNotes : ( first_name , last_name ) = user [ user_id ] thisNPub = nPublished [( user_id , keyword )] thisNNotes = nNotes [( user_id , keyword )] thisNVerses = len ( nVerses [( user_id , keyword )]) r . append ( { \"item\" : dict ( id = iEncode ( \"n\" , user_id , keyword ), first_name = first_name , last_name = last_name , keywords = keyword , is_published = thisNPub > 0 , nNotes = thisNNotes , nVerses = thisNVerses , ), \"slots\" : json . dumps ([]), } ) return r read ( self , vr , iid , keywords ) \u00b6 Source code in modules/note.py def read ( self , vr , iid , keywords ): auth = current . auth NOTE_DB = current . NOTE_DB clauseAtomFirst = self . getClauseAtomFirstSlot ( vr ) keywordsSql = keywords . replace ( \"'\" , \"''\" ) myId = auth . user . id if auth . user is not None else None extra = \"\" if myId is None else f \" or created_by = { myId } \" sql = dedent ( f \"\"\" select book, clause_atom from note where keywords like '% { keywordsSql } %' and version = ' { vr } ' and (is_shared = 'T' { extra } ) ; \"\"\" ) clauseAtoms = NOTE_DB . executesql ( sql ) slots = { clauseAtomFirst [ x [ 0 ]][ x [ 1 ]] for x in clauseAtoms } return normRanges ( None , fromset = slots ) getClauseAtoms ( self , vr , bk , ch , vs ) \u00b6 Source code in modules/note.py def getClauseAtoms ( self , vr , bk , ch , vs ): Caching = current . Caching return Caching . get ( f \"clause_atoms_ { vr } _ { bk } _ { ch } _ { vs } _\" , lambda : self . getClauseAtoms_c ( vr , bk , ch , vs ), ALWAYS , ) getClauseAtoms_c ( self , vr , bk , ch , vs ) \u00b6 Source code in modules/note.py def getClauseAtoms_c ( self , vr , bk , ch , vs ): PASSAGE_DBS = current . PASSAGE_DBS clauseAtoms = [] caData = ( PASSAGE_DBS [ vr ] . executesql ( dedent ( f \"\"\" select distinct word.clause_atom_number from verse inner join word_verse on verse.id = word_verse.verse_id inner join word on word.word_number = word_verse.anchor inner join chapter on chapter.id = verse.chapter_id inner join book on book.id = chapter.book_id where book.name = ' { bk } ' and chapter.chapter_num = { ch } and verse.verse_num = { vs } order by word.clause_atom_number ; \"\"\" ) ) if vr in PASSAGE_DBS else [] ) for row in caData : clauseAtoms . append ( row [ 0 ]) return clauseAtoms getClauseAtomFirstSlot ( self , vr ) \u00b6 Source code in modules/note.py def getClauseAtomFirstSlot ( self , vr ): Caching = current . Caching return Caching . get ( f \"clause_atom_f_ { vr } _\" , lambda : self . getClauseAtomFirstSlot_c ( vr ), ALWAYS , ) getClauseAtomFirstSlot_c ( self , vr ) \u00b6 Source code in modules/note.py def getClauseAtomFirstSlot_c ( self , vr ): Books = self . Books PASSAGE_DBS = current . PASSAGE_DBS ( books , booksOrder , bookIds , bookName ) = Books . get ( vr ) sql = dedent ( \"\"\" select book_id, ca_num, first_m from clause_atom ; \"\"\" ) caData = PASSAGE_DBS [ vr ] . executesql ( sql ) if vr in PASSAGE_DBS else [] caFirst = {} for ( book_id , ca_num , first_m ) in caData : book_name = bookName [ book_id ] caFirst . setdefault ( book_name , {})[ ca_num ] = first_m return caFirst getInfo ( self , iidRep , vr , msgs ) \u00b6 Source code in modules/note.py def getInfo ( self , iidRep , vr , msgs ): db = current . db ( iid , keywords ) = iDecode ( \"n\" , iidRep ) if iid is None : return {} nRecord = dict ( id = iidRep , user_id = iid , first_name = \"N?\" , last_name = \"N?\" , keywords = keywords , versions = {}, ) nRecord [ \"versions\" ] = self . countNotes ( iid , keywords ) sql = dedent ( f \"\"\" select first_name, last_name from auth_user where id = ' { iid } ' ; \"\"\" ) uinfo = db . executesql ( sql ) if uinfo is not None and len ( uinfo ) > 0 : nRecord [ \"first_name\" ] = uinfo [ 0 ][ 0 ] nRecord [ \"last_name\" ] = uinfo [ 0 ][ 1 ] return nRecord countNotes ( self , user_id , keywords ) \u00b6 Source code in modules/note.py def countNotes ( self , user_id , keywords ): auth = current . auth NOTE_DB = current . NOTE_DB keywordsSql = keywords . replace ( \"'\" , \"''\" ) myId = auth . user . id if auth . user is not None else None extra = f \" or created_by = { user_id } \" if myId == user_id else \"\" sql = dedent ( f \"\"\" select version, count(id) as amount from note where keywords like '% { keywordsSql } %' and (is_shared = 'T' { extra } ) group by version ; \"\"\" ) records = NOTE_DB . executesql ( sql ) vrs = set () versionInfo = {} for ( vr , amount ) in records : vrs . add ( vr ) versionInfo [ vr ] = dict ( n = amount ) return versionInfo inVerse ( self , vr , bk , ch , vs , myId , clauseAtoms , changed , msgs , authenticated , edit ) \u00b6 Source code in modules/note.py def inVerse ( self , vr , bk , ch , vs , myId , clauseAtoms , changed , msgs , authenticated , edit ): NOTE_DB = current . NOTE_DB condition = \"note.is_shared = 'T' or note.is_published = 'T' \" if myId is not None : condition += f \" or note.created_by = { myId } \" noteSql = dedent ( f \"\"\" select note.id, note.created_by as user_id, shebanq_web.auth_user.first_name, shebanq_web.auth_user.last_name, note.clause_atom, note.is_shared, note.is_published, note.published_on, note.status, note.keywords, note.ntext from note inner join shebanq_web.auth_user on note.created_by = shebanq_web.auth_user.id where ( { condition } ) and note.version = ' { vr } ' and note.book =' { bk } ' and note.chapter = { ch } and note.verse = { vs } order by modified_on desc ; \"\"\" ) records = NOTE_DB . executesql ( noteSql ) users = {} keyIndex = {} notesProto = collections . defaultdict ( lambda : {}) clauseAtomUsers = collections . defaultdict ( lambda : collections . OrderedDict ()) if myId is not None and edit : users [ myId ] = \"me\" for clauseAtom in clauseAtoms : notesProto [ clauseAtom ][ myId ] = [ dict ( user_id = myId , note_id = 0 , is_shared = True , is_published = False , status = \"o\" , keywords = \"\" , ntext = \"\" , ) ] clauseAtomUsers [ clauseAtom ][ myId ] = None good = True if records is None : msgs . append ( ( \"error\" , f \"Cannot lookup notes for { bk } { ch } : { vs } in version { vr } \" , ) ) good = False elif len ( records ) == 0 : msgs . append (( \"warning\" , \"No notes\" )) else : now = current . request . utcnow for ( note_id , user_id , first_name , last_name , clause_atom , is_shared , is_published , published_on , status , keywords , ntext , ) in records : if ( myId is None or ( user_id != myId ) or not edit ) and user_id not in users : users [ user_id ] = f \" { first_name } { last_name } \" if user_id not in clauseAtomUsers [ clause_atom ]: clauseAtomUsers [ clause_atom ][ user_id ] = None is_published = is_published == \"T\" is_shared = is_published or is_shared == \"T\" ro = ( myId is None or user_id != myId or not edit or ( is_published and published_on is not None and ( published_on <= now - PUBLISH_FREEZE ) ) ) keywordList = keywords . strip () . split () for keyword in keywordList : keyIndex [ f \" { user_id } { keyword } \" ] = iEncode ( \"n\" , user_id , keywords = keyword ) notesProto . setdefault ( clause_atom , {}) . setdefault ( user_id , []) . append ( dict ( user_id = user_id , note_id = note_id , ro = ro , is_shared = is_shared , is_published = is_published , status = status , keywords = keywords , ntext = ntext , ) ) notes = {} for clauseAtom in notesProto : for user_id in clauseAtomUsers [ clauseAtom ]: notes . setdefault ( clauseAtom , []) . extend ( notesProto [ clauseAtom ][ user_id ]) return json . dumps ( dict ( good = good , changed = changed , msgs = msgs , users = users , notes = notes , keyIndex = keyIndex , authenticated = authenticated , ) )","title":"Note"},{"location":"server/bymodule/note/#note","text":"","title":"note"},{"location":"server/bymodule/note/#note.NOTE","text":"Handles notes.","title":"NOTE"},{"location":"server/bymodule/note/#note.NOTE.__init__","text":"Source code in modules/note.py def __init__ ( self , Books ): self . Books = Books","title":"__init__()"},{"location":"server/bymodule/note/#note.NOTE.authUpload","text":"Source code in modules/note.py def authUpload ( self ): auth = current . auth db = current . db myId = None authorized = False if auth . user : myId = auth . user . id if myId : sql = dedent ( f \"\"\" select uid from uploaders where uid = { myId } \"\"\" ) records = db . executesql ( sql ) authorized = ( records is not None and len ( records ) == 1 and records [ 0 ][ 0 ] == myId ) msg = \"\" if authorized else \"you are not allowed to upload notes as csv files\" return ( authorized , myId , msg )","title":"authUpload()"},{"location":"server/bymodule/note/#note.NOTE.page","text":"Source code in modules/note.py def page ( self , ViewSettings ): Check = current . Check pageConfig = ViewSettings . writeConfig () key_id = Check . isId ( \"goto\" , \"n\" , \"note\" , []) ( authorized , myId , msg ) = self . authUpload () return dict ( pageConfig = pageConfig , key_id = key_id , mayUpload = authorized , user_id = myId , )","title":"page()"},{"location":"server/bymodule/note/#note.NOTE.getVerseNotes","text":"Get the notes belonging to a single verse. Reads request parameters to determine which verse. Source code in modules/note.py def getVerseNotes ( self ): \"\"\"Get the notes belonging to a single verse. Reads request parameters to determine which verse. \"\"\" Check = current . Check auth = current . auth vr = Check . field ( \"material\" , \"\" , \"version\" ) bk = Check . field ( \"material\" , \"\" , \"book\" ) ch = Check . field ( \"material\" , \"\" , \"chapter\" ) vs = Check . field ( \"material\" , \"\" , \"verse\" ) edit = Check . isBool ( \"edit\" ) myId = None if auth . user : myId = auth . user . id authenticated = myId is not None clauseAtoms = self . getClauseAtoms ( vr , bk , ch , vs ) changed = False msgs = [] return self . inVerse ( vr , bk , ch , vs , myId , clauseAtoms , changed , msgs , authenticated , edit )","title":"getVerseNotes()"},{"location":"server/bymodule/note/#note.NOTE.body","text":"Retrieves a note set record based on parameters. Source code in modules/note.py def body ( self ): \"\"\"Retrieves a note set record based on parameters. \"\"\" Check = current . Check vr = Check . field ( \"material\" , \"\" , \"version\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) ( iid , keywords ) = iDecode ( \"n\" , iidRep ) msgs = [] if not iid : msg = f \"Not a valid note id: { iid } \" msgs . append (( \"error\" , msg )) return dict ( noteRecord = dict (), note = json . dumps ( dict ()), msgs = json . dumps ( msgs ), ) noteRecord = self . getInfo ( iidRep , vr , msgs ) return dict ( vr = vr , noteRecord = noteRecord , note = json . dumps ( noteRecord ), msgs = json . dumps ( msgs ), )","title":"body()"},{"location":"server/bymodule/note/#note.NOTE.getItems","text":"Source code in modules/note.py def getItems ( self , vr , book , chapter , is_published ): NOTE_DB = current . NOTE_DB bk = book [ \"name\" ] ch = chapter [ \"chapter_num\" ] if is_published == \"x\" : isPubVersion = \"\" else : isPubVersion = \" and is_published = 'T'\" sql = dedent ( f \"\"\" select note.created_by, shebanq_web.auth_user.first_name, shebanq_web.auth_user.last_name, note.keywords, note.verse, note.is_published from note inner join shebanq_web.auth_user on shebanq_web.auth_user.id = created_by where version = ' { vr } ' and book = ' { bk } ' and chapter = { ch } { isPubVersion } order by note.verse ; \"\"\" ) records = NOTE_DB . executesql ( sql ) user = {} nPublished = collections . Counter () nNotes = collections . Counter () nVerses = {} for ( user_id , first_name , last_name , keywords , v , is_published ) in records : if user_id not in user : user [ user_id ] = ( first_name , last_name ) for keyword in set ( keywords . strip () . split ()): if is_published == \"T\" : nPublished [( user_id , keyword )] += 1 nNotes [( user_id , keyword )] += 1 nVerses . setdefault (( user_id , keyword ), set ()) . add ( v ) r = [] for ( user_id , keyword ) in nNotes : ( first_name , last_name ) = user [ user_id ] thisNPub = nPublished [( user_id , keyword )] thisNNotes = nNotes [( user_id , keyword )] thisNVerses = len ( nVerses [( user_id , keyword )]) r . append ( { \"item\" : dict ( id = iEncode ( \"n\" , user_id , keyword ), first_name = first_name , last_name = last_name , keywords = keyword , is_published = thisNPub > 0 , nNotes = thisNNotes , nVerses = thisNVerses , ), \"slots\" : json . dumps ([]), } ) return r","title":"getItems()"},{"location":"server/bymodule/note/#note.NOTE.read","text":"Source code in modules/note.py def read ( self , vr , iid , keywords ): auth = current . auth NOTE_DB = current . NOTE_DB clauseAtomFirst = self . getClauseAtomFirstSlot ( vr ) keywordsSql = keywords . replace ( \"'\" , \"''\" ) myId = auth . user . id if auth . user is not None else None extra = \"\" if myId is None else f \" or created_by = { myId } \" sql = dedent ( f \"\"\" select book, clause_atom from note where keywords like '% { keywordsSql } %' and version = ' { vr } ' and (is_shared = 'T' { extra } ) ; \"\"\" ) clauseAtoms = NOTE_DB . executesql ( sql ) slots = { clauseAtomFirst [ x [ 0 ]][ x [ 1 ]] for x in clauseAtoms } return normRanges ( None , fromset = slots )","title":"read()"},{"location":"server/bymodule/note/#note.NOTE.getClauseAtoms","text":"Source code in modules/note.py def getClauseAtoms ( self , vr , bk , ch , vs ): Caching = current . Caching return Caching . get ( f \"clause_atoms_ { vr } _ { bk } _ { ch } _ { vs } _\" , lambda : self . getClauseAtoms_c ( vr , bk , ch , vs ), ALWAYS , )","title":"getClauseAtoms()"},{"location":"server/bymodule/note/#note.NOTE.getClauseAtoms_c","text":"Source code in modules/note.py def getClauseAtoms_c ( self , vr , bk , ch , vs ): PASSAGE_DBS = current . PASSAGE_DBS clauseAtoms = [] caData = ( PASSAGE_DBS [ vr ] . executesql ( dedent ( f \"\"\" select distinct word.clause_atom_number from verse inner join word_verse on verse.id = word_verse.verse_id inner join word on word.word_number = word_verse.anchor inner join chapter on chapter.id = verse.chapter_id inner join book on book.id = chapter.book_id where book.name = ' { bk } ' and chapter.chapter_num = { ch } and verse.verse_num = { vs } order by word.clause_atom_number ; \"\"\" ) ) if vr in PASSAGE_DBS else [] ) for row in caData : clauseAtoms . append ( row [ 0 ]) return clauseAtoms","title":"getClauseAtoms_c()"},{"location":"server/bymodule/note/#note.NOTE.getClauseAtomFirstSlot","text":"Source code in modules/note.py def getClauseAtomFirstSlot ( self , vr ): Caching = current . Caching return Caching . get ( f \"clause_atom_f_ { vr } _\" , lambda : self . getClauseAtomFirstSlot_c ( vr ), ALWAYS , )","title":"getClauseAtomFirstSlot()"},{"location":"server/bymodule/note/#note.NOTE.getClauseAtomFirstSlot_c","text":"Source code in modules/note.py def getClauseAtomFirstSlot_c ( self , vr ): Books = self . Books PASSAGE_DBS = current . PASSAGE_DBS ( books , booksOrder , bookIds , bookName ) = Books . get ( vr ) sql = dedent ( \"\"\" select book_id, ca_num, first_m from clause_atom ; \"\"\" ) caData = PASSAGE_DBS [ vr ] . executesql ( sql ) if vr in PASSAGE_DBS else [] caFirst = {} for ( book_id , ca_num , first_m ) in caData : book_name = bookName [ book_id ] caFirst . setdefault ( book_name , {})[ ca_num ] = first_m return caFirst","title":"getClauseAtomFirstSlot_c()"},{"location":"server/bymodule/note/#note.NOTE.getInfo","text":"Source code in modules/note.py def getInfo ( self , iidRep , vr , msgs ): db = current . db ( iid , keywords ) = iDecode ( \"n\" , iidRep ) if iid is None : return {} nRecord = dict ( id = iidRep , user_id = iid , first_name = \"N?\" , last_name = \"N?\" , keywords = keywords , versions = {}, ) nRecord [ \"versions\" ] = self . countNotes ( iid , keywords ) sql = dedent ( f \"\"\" select first_name, last_name from auth_user where id = ' { iid } ' ; \"\"\" ) uinfo = db . executesql ( sql ) if uinfo is not None and len ( uinfo ) > 0 : nRecord [ \"first_name\" ] = uinfo [ 0 ][ 0 ] nRecord [ \"last_name\" ] = uinfo [ 0 ][ 1 ] return nRecord","title":"getInfo()"},{"location":"server/bymodule/note/#note.NOTE.countNotes","text":"Source code in modules/note.py def countNotes ( self , user_id , keywords ): auth = current . auth NOTE_DB = current . NOTE_DB keywordsSql = keywords . replace ( \"'\" , \"''\" ) myId = auth . user . id if auth . user is not None else None extra = f \" or created_by = { user_id } \" if myId == user_id else \"\" sql = dedent ( f \"\"\" select version, count(id) as amount from note where keywords like '% { keywordsSql } %' and (is_shared = 'T' { extra } ) group by version ; \"\"\" ) records = NOTE_DB . executesql ( sql ) vrs = set () versionInfo = {} for ( vr , amount ) in records : vrs . add ( vr ) versionInfo [ vr ] = dict ( n = amount ) return versionInfo","title":"countNotes()"},{"location":"server/bymodule/note/#note.NOTE.inVerse","text":"Source code in modules/note.py def inVerse ( self , vr , bk , ch , vs , myId , clauseAtoms , changed , msgs , authenticated , edit ): NOTE_DB = current . NOTE_DB condition = \"note.is_shared = 'T' or note.is_published = 'T' \" if myId is not None : condition += f \" or note.created_by = { myId } \" noteSql = dedent ( f \"\"\" select note.id, note.created_by as user_id, shebanq_web.auth_user.first_name, shebanq_web.auth_user.last_name, note.clause_atom, note.is_shared, note.is_published, note.published_on, note.status, note.keywords, note.ntext from note inner join shebanq_web.auth_user on note.created_by = shebanq_web.auth_user.id where ( { condition } ) and note.version = ' { vr } ' and note.book =' { bk } ' and note.chapter = { ch } and note.verse = { vs } order by modified_on desc ; \"\"\" ) records = NOTE_DB . executesql ( noteSql ) users = {} keyIndex = {} notesProto = collections . defaultdict ( lambda : {}) clauseAtomUsers = collections . defaultdict ( lambda : collections . OrderedDict ()) if myId is not None and edit : users [ myId ] = \"me\" for clauseAtom in clauseAtoms : notesProto [ clauseAtom ][ myId ] = [ dict ( user_id = myId , note_id = 0 , is_shared = True , is_published = False , status = \"o\" , keywords = \"\" , ntext = \"\" , ) ] clauseAtomUsers [ clauseAtom ][ myId ] = None good = True if records is None : msgs . append ( ( \"error\" , f \"Cannot lookup notes for { bk } { ch } : { vs } in version { vr } \" , ) ) good = False elif len ( records ) == 0 : msgs . append (( \"warning\" , \"No notes\" )) else : now = current . request . utcnow for ( note_id , user_id , first_name , last_name , clause_atom , is_shared , is_published , published_on , status , keywords , ntext , ) in records : if ( myId is None or ( user_id != myId ) or not edit ) and user_id not in users : users [ user_id ] = f \" { first_name } { last_name } \" if user_id not in clauseAtomUsers [ clause_atom ]: clauseAtomUsers [ clause_atom ][ user_id ] = None is_published = is_published == \"T\" is_shared = is_published or is_shared == \"T\" ro = ( myId is None or user_id != myId or not edit or ( is_published and published_on is not None and ( published_on <= now - PUBLISH_FREEZE ) ) ) keywordList = keywords . strip () . split () for keyword in keywordList : keyIndex [ f \" { user_id } { keyword } \" ] = iEncode ( \"n\" , user_id , keywords = keyword ) notesProto . setdefault ( clause_atom , {}) . setdefault ( user_id , []) . append ( dict ( user_id = user_id , note_id = note_id , ro = ro , is_shared = is_shared , is_published = is_published , status = status , keywords = keywords , ntext = ntext , ) ) notes = {} for clauseAtom in notesProto : for user_id in clauseAtomUsers [ clauseAtom ]: notes . setdefault ( clauseAtom , []) . extend ( notesProto [ clauseAtom ][ user_id ]) return json . dumps ( dict ( good = good , changed = changed , msgs = msgs , users = users , notes = notes , keyIndex = keyIndex , authenticated = authenticated , ) )","title":"inVerse()"},{"location":"server/bymodule/notesave/","text":"notesave \u00b6 NOTESAVE \u00b6 __init__ ( self , Note ) special \u00b6 Source code in modules/notesave.py def __init__ ( self , Note ): self . Note = Note put ( self , myId , vr , bk , ch , vs , notes , clauseAtoms , msgs ) \u00b6 Source code in modules/notesave.py def put ( self , myId , vr , bk , ch , vs , notes , clauseAtoms , msgs ): Caching = current . Caching NOTE_DB = current . NOTE_DB ( good , notesOld , notesUpd , notesNew , notesDel ) = self . filter ( myId , notes , clauseAtoms , msgs ) updated = 0 doCommit = False now = current . request . utcnow for note_id in notesUpd : ( is_shared , is_published , status , keywords , ntext ) = notesUpd [ note_id ] ( isSharedOld , isPubOld , statusOld , keywordsOld , ntextOld ) = notesOld [ note_id ] extrafields = [] if is_shared and not isSharedOld : extrafields . append ( f \", \\n\\t shared_on = ' { now } '\" ) if not is_shared and isSharedOld : extrafields . append ( \", \\n\\t shared_on = null\" ) if is_published and not isPubOld : extrafields . append ( f \", \\n\\t published_on = ' { now } '\" ) if not is_published and isPubOld : extrafields . append ( \", \\n\\t published_on = null\" ) is_shared = \"'T'\" if is_shared else \"null\" is_published = \"'T'\" if is_published else \"null\" status = \"o\" if status not in { \"o\" , \"*\" , \"+\" , \"?\" , \"-\" , \"!\" } else status updateSql = dedent ( f \"\"\" update note set modified_on = ' { now } ', is_shared = { is_shared } , is_published = { is_published } , status = ' { status } ', keywords = ' { keywords . replace ( \"'\" , \"''\" ) } ', ntext = ' { ntext . replace ( \"'\" , \"''\" ) } ' { \"\" . join ( extrafields ) } where id = { note_id } ; \"\"\" ) NOTE_DB . executesql ( updateSql ) updated += 1 doCommit = True if len ( notesDel ) > 0 : deleteSql = dedent ( f \"\"\" delete from note where id in ( { \",\" . join ( str ( x ) for x in notesDel ) } ) ; \"\"\" ) NOTE_DB . executesql ( deleteSql ) doCommit = True for clause_atom in notesNew : ( is_shared , is_published , status , keywords , ntext ) = notesNew [ clause_atom ] sh = \"'T'\" if is_shared else \"null\" sht = f \"' { now } '\" if is_shared else \"null\" pb = \"'T'\" if is_published else \"null\" pbt = f \"' { now } '\" if is_published else \"null\" fl = \"o\" if status not in { \"o\" , \"*\" , \"+\" , \"?\" , \"-\" , \"!\" } else status keywordsSql = keywords . replace ( \"'\" , \"''\" ) ntr = ntext . replace ( \"'\" , \"''\" ) insertSql = dedent ( f \"\"\" insert into note (version, book, chapter, verse, clause_atom, created_by, created_on, modified_on, is_shared, shared_on, is_published, published_on, status, keywords, ntext) values (' { vr } ', ' { bk } ', { ch } , { vs } , { clause_atom } , { myId } , ' { now } ', ' { now } ', { sh } , { sht } , { pb } , { pbt } , ' { fl } ', ' { keywordsSql } ', ' { ntr } ') ; \"\"\" ) NOTE_DB . executesql ( insertSql ) doCommit = True if doCommit : NOTE_DB . commit () changed = False if len ( notesDel ) > 0 : msgs . append (( \"special\" , f \"Deleted notes: { len ( notesDel ) } \" )) if updated > 0 : msgs . append (( \"special\" , f \"Updated notes: { updated } \" )) if len ( notesNew ) > 0 : msgs . append (( \"special\" , f \"Added notes: { len ( notesNew ) } \" )) if len ( notesDel ) + len ( notesNew ) + updated == 0 : msgs . append (( \"warning\" , \"No changes\" )) else : changed = True Caching . clear ( f \"^items_n_ { vr } _ { bk } _ { ch } _\" ) if len ( notesNew ): for keywords in { notesNew [ clause_atom ][ 3 ] for clause_atom in notesNew }: Caching . clear ( f \"^verses_ { vr } _n_ { iEncode ( 'n' , myId , keywords = keywords ) } _\" , ) if len ( notesDel ): for note_id in notesDel : if note_id in notesOld : keywords = notesOld [ note_id ][ 3 ] Caching . clear ( f \"^verses_ { vr } _n_ { iEncode ( 'n' , myId , keywords = keywords ) } _\" , ) return changed putVerseNotes ( self ) \u00b6 Save notes. Reads request parameters to determine which notes for which verse. Source code in modules/notesave.py def putVerseNotes ( self ): \"\"\"Save notes. Reads request parameters to determine which notes for which verse. \"\"\" Check = current . Check Note = self . Note auth = current . auth vr = Check . field ( \"material\" , \"\" , \"version\" ) bk = Check . field ( \"material\" , \"\" , \"book\" ) ch = Check . field ( \"material\" , \"\" , \"chapter\" ) vs = Check . field ( \"material\" , \"\" , \"verse\" ) edit = Check . isBool ( \"edit\" ) myId = None if auth . user : myId = auth . user . id authenticated = myId is not None clauseAtoms = Note . getClauseAtoms ( vr , bk , ch , vs ) changed = False msgs = [] if myId is None : msgs . append (( \"error\" , \"You have to be logged in when you save notes\" )) else : requestVars = current . request . vars notes = ( json . loads ( requestVars . notes ) if requestVars and requestVars . notes else [] ) changed = self . put ( myId , vr , bk , ch , vs , notes , clauseAtoms , msgs ) return Note . inVerse ( vr , bk , ch , vs , myId , clauseAtoms , changed , msgs , authenticated , edit ) filter ( self , myId , notes , clauseAtoms , msgs ) \u00b6 Source code in modules/notesave.py def filter ( self , myId , notes , clauseAtoms , msgs ): NOTE_DB = current . NOTE_DB good = True notesOther = set () notesMissing = set () notesExtra = set () notesSame = set () clauseErrors = set () emptyNew = 0 notesOld = {} notesUpd = {} notesNew = {} notesDel = set () for fields in notes : note_id = int ( fields [ \"note_id\" ]) user_id = int ( fields [ \"user_id\" ]) clause_atom = int ( fields [ \"clause_atom\" ]) if user_id != myId : notesOther . add ( note_id ) good = False continue if clause_atom not in clauseAtoms : clauseErrors . add ( note_id ) good = False continue keywords = \"\" . join ( \" \" + keyword + \" \" for keyword in fields [ \"keywords\" ] . strip () . split () ) ntext = fields [ \"ntext\" ] . strip () if keywords == \"\" and ntext == \"\" : if note_id == 0 : emptyNew += 1 else : notesDel . add ( note_id ) continue if note_id != 0 : notesUpd [ note_id ] = ( fields [ \"is_shared\" ], fields [ \"is_published\" ], fields [ \"status\" ], keywords , ntext , ) else : notesNew [ fields [ \"clause_atom\" ]] = ( fields [ \"is_shared\" ], fields [ \"is_published\" ], fields [ \"status\" ], keywords , ntext , ) if len ( notesUpd ) > 0 or len ( notesDel ) > 0 : ids = \",\" . join ( str ( x ) for x in ( set ( notesUpd . keys ()) | notesDel )) sqlOld = dedent ( f \"\"\" select id, created_by, is_shared, is_published, status, keywords, ntext from note where id in ( { ids } ) ; \"\"\" ) changeCandidates = NOTE_DB . executesql ( sqlOld ) if changeCandidates is not None : for ( note_id , user_id , isSharedOld , isPubOld , statusOld , keywordsOld , ntextOld , ) in changeCandidates : remove = False if user_id != myId : notesOther . add ( note_id ) remove = True elif note_id not in notesUpd and note_id not in notesDel : notesExtra . add ( note_id ) remove = True elif note_id in notesUpd : ( is_shared , is_published , status , keywords , ntext ) = notesUpd [ note_id ] if not is_shared : is_shared = None if not is_published : is_published = None if ( statusOld == status and keywordsOld == keywords and ntextOld == ntext and isSharedOld == is_shared and isPubOld == is_published ): notesSame . add ( note_id ) if note_id not in notesDel : remove = True if remove : if note_id in notesUpd : del notesUpd [ note_id ] if note_id in notesDel : notesDel . remove ( note_id ) else : notesOld [ note_id ] = ( isSharedOld , isPubOld , statusOld , keywordsOld , ntextOld , ) removable = set () for note_id in notesUpd : if note_id not in notesOld : if note_id not in notesOther : notesMissing . add ( note_id ) removable . add ( note_id ) for note_id in removable : del notesUpd [ note_id ] removable = set () for note_id in notesDel : if note_id not in notesOld : if note_id not in notesOther : notesMissing . add ( note_id ) removable . add ( note_id ) for note_id in removable : notesDel . remove ( note_id ) if len ( notesOther ) > 0 : msgs . append (( \"error\" , f \"Notes of other users skipped: { len ( notesOther ) } \" )) if len ( notesMissing ) > 0 : msgs . append (( \"error\" , f \"Non-existing notes: { len ( notesMissing ) } \" )) if len ( notesExtra ) > 0 : msgs . append (( \"error\" , f \"Notes not shown: { len ( notesExtra ) } \" )) if len ( clauseErrors ) > 0 : msgs . append ( ( \"error\" , f \"Notes referring to wrong clause: { len ( clauseErrors ) } \" ) ) if len ( notesSame ) > 0 : pass if emptyNew > 0 : pass return ( good , notesOld , notesUpd , notesNew , notesDel )","title":"Notesave"},{"location":"server/bymodule/notesave/#notesave","text":"","title":"notesave"},{"location":"server/bymodule/notesave/#notesave.NOTESAVE","text":"","title":"NOTESAVE"},{"location":"server/bymodule/notesave/#notesave.NOTESAVE.__init__","text":"Source code in modules/notesave.py def __init__ ( self , Note ): self . Note = Note","title":"__init__()"},{"location":"server/bymodule/notesave/#notesave.NOTESAVE.put","text":"Source code in modules/notesave.py def put ( self , myId , vr , bk , ch , vs , notes , clauseAtoms , msgs ): Caching = current . Caching NOTE_DB = current . NOTE_DB ( good , notesOld , notesUpd , notesNew , notesDel ) = self . filter ( myId , notes , clauseAtoms , msgs ) updated = 0 doCommit = False now = current . request . utcnow for note_id in notesUpd : ( is_shared , is_published , status , keywords , ntext ) = notesUpd [ note_id ] ( isSharedOld , isPubOld , statusOld , keywordsOld , ntextOld ) = notesOld [ note_id ] extrafields = [] if is_shared and not isSharedOld : extrafields . append ( f \", \\n\\t shared_on = ' { now } '\" ) if not is_shared and isSharedOld : extrafields . append ( \", \\n\\t shared_on = null\" ) if is_published and not isPubOld : extrafields . append ( f \", \\n\\t published_on = ' { now } '\" ) if not is_published and isPubOld : extrafields . append ( \", \\n\\t published_on = null\" ) is_shared = \"'T'\" if is_shared else \"null\" is_published = \"'T'\" if is_published else \"null\" status = \"o\" if status not in { \"o\" , \"*\" , \"+\" , \"?\" , \"-\" , \"!\" } else status updateSql = dedent ( f \"\"\" update note set modified_on = ' { now } ', is_shared = { is_shared } , is_published = { is_published } , status = ' { status } ', keywords = ' { keywords . replace ( \"'\" , \"''\" ) } ', ntext = ' { ntext . replace ( \"'\" , \"''\" ) } ' { \"\" . join ( extrafields ) } where id = { note_id } ; \"\"\" ) NOTE_DB . executesql ( updateSql ) updated += 1 doCommit = True if len ( notesDel ) > 0 : deleteSql = dedent ( f \"\"\" delete from note where id in ( { \",\" . join ( str ( x ) for x in notesDel ) } ) ; \"\"\" ) NOTE_DB . executesql ( deleteSql ) doCommit = True for clause_atom in notesNew : ( is_shared , is_published , status , keywords , ntext ) = notesNew [ clause_atom ] sh = \"'T'\" if is_shared else \"null\" sht = f \"' { now } '\" if is_shared else \"null\" pb = \"'T'\" if is_published else \"null\" pbt = f \"' { now } '\" if is_published else \"null\" fl = \"o\" if status not in { \"o\" , \"*\" , \"+\" , \"?\" , \"-\" , \"!\" } else status keywordsSql = keywords . replace ( \"'\" , \"''\" ) ntr = ntext . replace ( \"'\" , \"''\" ) insertSql = dedent ( f \"\"\" insert into note (version, book, chapter, verse, clause_atom, created_by, created_on, modified_on, is_shared, shared_on, is_published, published_on, status, keywords, ntext) values (' { vr } ', ' { bk } ', { ch } , { vs } , { clause_atom } , { myId } , ' { now } ', ' { now } ', { sh } , { sht } , { pb } , { pbt } , ' { fl } ', ' { keywordsSql } ', ' { ntr } ') ; \"\"\" ) NOTE_DB . executesql ( insertSql ) doCommit = True if doCommit : NOTE_DB . commit () changed = False if len ( notesDel ) > 0 : msgs . append (( \"special\" , f \"Deleted notes: { len ( notesDel ) } \" )) if updated > 0 : msgs . append (( \"special\" , f \"Updated notes: { updated } \" )) if len ( notesNew ) > 0 : msgs . append (( \"special\" , f \"Added notes: { len ( notesNew ) } \" )) if len ( notesDel ) + len ( notesNew ) + updated == 0 : msgs . append (( \"warning\" , \"No changes\" )) else : changed = True Caching . clear ( f \"^items_n_ { vr } _ { bk } _ { ch } _\" ) if len ( notesNew ): for keywords in { notesNew [ clause_atom ][ 3 ] for clause_atom in notesNew }: Caching . clear ( f \"^verses_ { vr } _n_ { iEncode ( 'n' , myId , keywords = keywords ) } _\" , ) if len ( notesDel ): for note_id in notesDel : if note_id in notesOld : keywords = notesOld [ note_id ][ 3 ] Caching . clear ( f \"^verses_ { vr } _n_ { iEncode ( 'n' , myId , keywords = keywords ) } _\" , ) return changed","title":"put()"},{"location":"server/bymodule/notesave/#notesave.NOTESAVE.putVerseNotes","text":"Save notes. Reads request parameters to determine which notes for which verse. Source code in modules/notesave.py def putVerseNotes ( self ): \"\"\"Save notes. Reads request parameters to determine which notes for which verse. \"\"\" Check = current . Check Note = self . Note auth = current . auth vr = Check . field ( \"material\" , \"\" , \"version\" ) bk = Check . field ( \"material\" , \"\" , \"book\" ) ch = Check . field ( \"material\" , \"\" , \"chapter\" ) vs = Check . field ( \"material\" , \"\" , \"verse\" ) edit = Check . isBool ( \"edit\" ) myId = None if auth . user : myId = auth . user . id authenticated = myId is not None clauseAtoms = Note . getClauseAtoms ( vr , bk , ch , vs ) changed = False msgs = [] if myId is None : msgs . append (( \"error\" , \"You have to be logged in when you save notes\" )) else : requestVars = current . request . vars notes = ( json . loads ( requestVars . notes ) if requestVars and requestVars . notes else [] ) changed = self . put ( myId , vr , bk , ch , vs , notes , clauseAtoms , msgs ) return Note . inVerse ( vr , bk , ch , vs , myId , clauseAtoms , changed , msgs , authenticated , edit )","title":"putVerseNotes()"},{"location":"server/bymodule/notesave/#notesave.NOTESAVE.filter","text":"Source code in modules/notesave.py def filter ( self , myId , notes , clauseAtoms , msgs ): NOTE_DB = current . NOTE_DB good = True notesOther = set () notesMissing = set () notesExtra = set () notesSame = set () clauseErrors = set () emptyNew = 0 notesOld = {} notesUpd = {} notesNew = {} notesDel = set () for fields in notes : note_id = int ( fields [ \"note_id\" ]) user_id = int ( fields [ \"user_id\" ]) clause_atom = int ( fields [ \"clause_atom\" ]) if user_id != myId : notesOther . add ( note_id ) good = False continue if clause_atom not in clauseAtoms : clauseErrors . add ( note_id ) good = False continue keywords = \"\" . join ( \" \" + keyword + \" \" for keyword in fields [ \"keywords\" ] . strip () . split () ) ntext = fields [ \"ntext\" ] . strip () if keywords == \"\" and ntext == \"\" : if note_id == 0 : emptyNew += 1 else : notesDel . add ( note_id ) continue if note_id != 0 : notesUpd [ note_id ] = ( fields [ \"is_shared\" ], fields [ \"is_published\" ], fields [ \"status\" ], keywords , ntext , ) else : notesNew [ fields [ \"clause_atom\" ]] = ( fields [ \"is_shared\" ], fields [ \"is_published\" ], fields [ \"status\" ], keywords , ntext , ) if len ( notesUpd ) > 0 or len ( notesDel ) > 0 : ids = \",\" . join ( str ( x ) for x in ( set ( notesUpd . keys ()) | notesDel )) sqlOld = dedent ( f \"\"\" select id, created_by, is_shared, is_published, status, keywords, ntext from note where id in ( { ids } ) ; \"\"\" ) changeCandidates = NOTE_DB . executesql ( sqlOld ) if changeCandidates is not None : for ( note_id , user_id , isSharedOld , isPubOld , statusOld , keywordsOld , ntextOld , ) in changeCandidates : remove = False if user_id != myId : notesOther . add ( note_id ) remove = True elif note_id not in notesUpd and note_id not in notesDel : notesExtra . add ( note_id ) remove = True elif note_id in notesUpd : ( is_shared , is_published , status , keywords , ntext ) = notesUpd [ note_id ] if not is_shared : is_shared = None if not is_published : is_published = None if ( statusOld == status and keywordsOld == keywords and ntextOld == ntext and isSharedOld == is_shared and isPubOld == is_published ): notesSame . add ( note_id ) if note_id not in notesDel : remove = True if remove : if note_id in notesUpd : del notesUpd [ note_id ] if note_id in notesDel : notesDel . remove ( note_id ) else : notesOld [ note_id ] = ( isSharedOld , isPubOld , statusOld , keywordsOld , ntextOld , ) removable = set () for note_id in notesUpd : if note_id not in notesOld : if note_id not in notesOther : notesMissing . add ( note_id ) removable . add ( note_id ) for note_id in removable : del notesUpd [ note_id ] removable = set () for note_id in notesDel : if note_id not in notesOld : if note_id not in notesOther : notesMissing . add ( note_id ) removable . add ( note_id ) for note_id in removable : notesDel . remove ( note_id ) if len ( notesOther ) > 0 : msgs . append (( \"error\" , f \"Notes of other users skipped: { len ( notesOther ) } \" )) if len ( notesMissing ) > 0 : msgs . append (( \"error\" , f \"Non-existing notes: { len ( notesMissing ) } \" )) if len ( notesExtra ) > 0 : msgs . append (( \"error\" , f \"Notes not shown: { len ( notesExtra ) } \" )) if len ( clauseErrors ) > 0 : msgs . append ( ( \"error\" , f \"Notes referring to wrong clause: { len ( clauseErrors ) } \" ) ) if len ( notesSame ) > 0 : pass if emptyNew > 0 : pass return ( good , notesOld , notesUpd , notesNew , notesDel )","title":"filter()"},{"location":"server/bymodule/notesupload/","text":"notesupload \u00b6 NOTESUPLOAD \u00b6 Handles bulk uploads of notes. __init__ ( self , Books , Note ) special \u00b6 Source code in modules/notesupload.py def __init__ ( self , Books , Note ): self . Books = Books self . Note = Note upload ( self ) \u00b6 Checks a set of uploaded notes and stores them. Source code in modules/notesupload.py def upload ( self ): \"\"\"Checks a set of uploaded notes and stores them. \"\"\" Books = self . Books ViewDefs = current . ViewDefs Note = self . Note fileText = current . request . vars . file good = True ( authorized , myId , msg ) = Note . authUpload () if not authorized : return dict ( data = json . dumps ( dict ( msgs = [( \"error\" , msg )], good = False ))) Caching = current . Caching NOTE_DB = current . NOTE_DB VERSIONS = current . VERSIONS msgs = [] myVersions = set () bookInfo = {} for vr in VERSIONS : myVersions . add ( vr ) bookInfo [ vr ] = Books . get ( vr )[ 0 ] normFields = \" \\t \" . join ( \"\"\" version book chapter verse clause_atom is_shared is_published status keywords ntext \"\"\" . strip () . split () ) good = True fieldnames = normFields . split ( \" \\t \" ) nfields = len ( fieldnames ) errors = {} allKeywords = set () allVersions = set () now = current . request . utcnow created_on = now modified_on = now nerrors = 0 chunks = [] chunksize = 100 sqlhead = dedent ( f \"\"\" insert into note ( { \", \" . join ( fieldnames ) } , created_by, created_on, modified_on, shared_on, published_on, bulk) values \"\"\" ) thisChunk = [] thisI = 0 for ( i , linenl ) in enumerate ( fileText . value . decode ( \"utf8\" ) . split ( \" \\n \" )): line = linenl . rstrip () if line == \"\" : continue if i == 0 : if line != normFields : msgs . append ( [ \"error\" , ( f \"Wrong fields: { line } . \" f \"Required fields are { normFields } \" ), ] ) good = False break continue fields = line . replace ( \"'\" , \"''\" ) . split ( \" \\t \" ) if len ( fields ) != nfields : nerrors += 1 errors . setdefault ( \"wrong number of fields\" , []) . append ( i + 1 ) continue ( version , book , chapter , verse , clause_atom , is_shared , is_published , status , keywords , ntext , ) = fields published_on = \"NULL\" shared_on = \"NULL\" if version not in myVersions : nerrors += 1 errors . setdefault ( \"unrecognized version\" , []) . append ( f \" { i + 1 } : { version } \" ) continue books = bookInfo [ version ] if book not in books : nerrors += 1 errors . setdefault ( \"unrecognized book\" , []) . append ( f \" { i + 1 } : { book } \" ) continue maxChapter = books [ book ] if not chapter . isdigit () or int ( chapter ) > maxChapter : nerrors += 1 errors . setdefault ( \"unrecognized chapter\" , []) . append ( f \" { i + 1 } : { chapter } \" ) continue if not verse . isdigit () or int ( verse ) > 200 : nerrors += 1 errors . setdefault ( \"unrecognized verse\" , []) . append ( f \" { i + 1 } : { verse } \" ) continue if not clause_atom . isdigit () or int ( clause_atom ) > 100000 : nerrors += 1 errors . setdefault ( \"unrecognized clause_atom\" , []) . append ( f \" { i + 1 } : { clause_atom } \" ) continue if is_shared not in { \"T\" , \"\" }: nerrors += 1 errors . setdefault ( \"unrecognized shared field\" , []) . append ( f \" { i + 1 } : { is_shared } \" ) continue if is_published not in { \"T\" , \"\" }: nerrors += 1 errors . setdefault ( \"unrecognized published field\" , []) . append ( f \" { i + 1 } : { is_published } \" ) continue if status not in ViewDefs . noteStatusCls : nerrors += 1 errors . setdefault ( \"unrecognized status\" , []) . append ( f \" { i + 1 } : { status } \" ) continue if len ( keywords ) >= 128 : nerrors += 1 errors . setdefault ( \"keywords length over 128\" , []) . append ( f \" { i + 1 } : { len ( keywords ) } \" ) continue if len ( ntext ) >= 1024 : nerrors += 1 errors . setdefault ( \"note text length over 1024\" , []) . append ( f \" { i + 1 } : { len ( ntext ) } \" ) continue if nerrors > 20 : msgs . append ([ \"error\" , \"too many errors, aborting\" ]) break if is_shared == \"T\" : shared_on = f \"' { now } '\" if is_published == \"T\" : published_on = f \"' { now } '\" keywordList = keywords . split () if len ( keywordList ) == 0 : errors . setdefault ( \"empty keyword\" , []) . append ( f ' { i + 1 } :\" { keywords } \"' ) continue allKeywords |= set ( keywordList ) keywords = \"\" . join ( f \" { x } \" for x in keywordList ) allVersions . add ( version ) thisChunk . append ( ( f \"(' { version } ',' { book } ', { chapter } , { verse } , { clause_atom } ,\" f \"' { is_shared } ',' { is_published } ',\" f \"' { status } ',' { keywords } ',' { ntext } ', { myId } ,\" f \"' { created_on } ',' { modified_on } ', { shared_on } , { published_on } ,'b')\" ) ) thisI += 1 if thisI >= chunksize : chunks . append ( thisChunk ) thisChunk = [] thisI = 0 if len ( thisChunk ): chunks . append ( thisChunk ) if errors or nerrors : good = False else : avrep = \"', '\" . join ( allVersions ) whereVersion = f \"version in (' { avrep } ')\" whereKeywords = \" or \" . join ( f \" keywords like '% { keyword } %' \" for keyword in keywordList ) # first delete previously bulk uploaded notes by this author # and with these keywords and these versions delSql = dedent ( f \"\"\" delete from note where bulk = 'b' and created_by = { myId } and { whereVersion } and { whereKeywords } ; \"\"\" ) NOTE_DB . executesql ( delSql ) NOTE_DB . commit () for chunk in chunks : chunkRep = \", \\n \" . join ( chunk ) sql = f \" { sqlhead } { chunkRep } ;\" NOTE_DB . executesql ( sql ) NOTE_DB . commit () Caching . clear ( r \"^items_n_\" ) for vr in myVersions : Caching . clear ( f \"^verses_ { vr } _n_\" ) for msg in sorted ( errors ): istr = \",\" . join ( str ( i ) for i in errors [ msg ]) msgs . append ([ \"error\" , f \" { msg } : { istr } \" ]) msgs . append ([ \"good\" if good else \"error\" , \"Done\" ]) return dict ( data = json . dumps ( dict ( msgs = msgs , good = good )))","title":"Notesupload"},{"location":"server/bymodule/notesupload/#notesupload","text":"","title":"notesupload"},{"location":"server/bymodule/notesupload/#notesupload.NOTESUPLOAD","text":"Handles bulk uploads of notes.","title":"NOTESUPLOAD"},{"location":"server/bymodule/notesupload/#notesupload.NOTESUPLOAD.__init__","text":"Source code in modules/notesupload.py def __init__ ( self , Books , Note ): self . Books = Books self . Note = Note","title":"__init__()"},{"location":"server/bymodule/notesupload/#notesupload.NOTESUPLOAD.upload","text":"Checks a set of uploaded notes and stores them. Source code in modules/notesupload.py def upload ( self ): \"\"\"Checks a set of uploaded notes and stores them. \"\"\" Books = self . Books ViewDefs = current . ViewDefs Note = self . Note fileText = current . request . vars . file good = True ( authorized , myId , msg ) = Note . authUpload () if not authorized : return dict ( data = json . dumps ( dict ( msgs = [( \"error\" , msg )], good = False ))) Caching = current . Caching NOTE_DB = current . NOTE_DB VERSIONS = current . VERSIONS msgs = [] myVersions = set () bookInfo = {} for vr in VERSIONS : myVersions . add ( vr ) bookInfo [ vr ] = Books . get ( vr )[ 0 ] normFields = \" \\t \" . join ( \"\"\" version book chapter verse clause_atom is_shared is_published status keywords ntext \"\"\" . strip () . split () ) good = True fieldnames = normFields . split ( \" \\t \" ) nfields = len ( fieldnames ) errors = {} allKeywords = set () allVersions = set () now = current . request . utcnow created_on = now modified_on = now nerrors = 0 chunks = [] chunksize = 100 sqlhead = dedent ( f \"\"\" insert into note ( { \", \" . join ( fieldnames ) } , created_by, created_on, modified_on, shared_on, published_on, bulk) values \"\"\" ) thisChunk = [] thisI = 0 for ( i , linenl ) in enumerate ( fileText . value . decode ( \"utf8\" ) . split ( \" \\n \" )): line = linenl . rstrip () if line == \"\" : continue if i == 0 : if line != normFields : msgs . append ( [ \"error\" , ( f \"Wrong fields: { line } . \" f \"Required fields are { normFields } \" ), ] ) good = False break continue fields = line . replace ( \"'\" , \"''\" ) . split ( \" \\t \" ) if len ( fields ) != nfields : nerrors += 1 errors . setdefault ( \"wrong number of fields\" , []) . append ( i + 1 ) continue ( version , book , chapter , verse , clause_atom , is_shared , is_published , status , keywords , ntext , ) = fields published_on = \"NULL\" shared_on = \"NULL\" if version not in myVersions : nerrors += 1 errors . setdefault ( \"unrecognized version\" , []) . append ( f \" { i + 1 } : { version } \" ) continue books = bookInfo [ version ] if book not in books : nerrors += 1 errors . setdefault ( \"unrecognized book\" , []) . append ( f \" { i + 1 } : { book } \" ) continue maxChapter = books [ book ] if not chapter . isdigit () or int ( chapter ) > maxChapter : nerrors += 1 errors . setdefault ( \"unrecognized chapter\" , []) . append ( f \" { i + 1 } : { chapter } \" ) continue if not verse . isdigit () or int ( verse ) > 200 : nerrors += 1 errors . setdefault ( \"unrecognized verse\" , []) . append ( f \" { i + 1 } : { verse } \" ) continue if not clause_atom . isdigit () or int ( clause_atom ) > 100000 : nerrors += 1 errors . setdefault ( \"unrecognized clause_atom\" , []) . append ( f \" { i + 1 } : { clause_atom } \" ) continue if is_shared not in { \"T\" , \"\" }: nerrors += 1 errors . setdefault ( \"unrecognized shared field\" , []) . append ( f \" { i + 1 } : { is_shared } \" ) continue if is_published not in { \"T\" , \"\" }: nerrors += 1 errors . setdefault ( \"unrecognized published field\" , []) . append ( f \" { i + 1 } : { is_published } \" ) continue if status not in ViewDefs . noteStatusCls : nerrors += 1 errors . setdefault ( \"unrecognized status\" , []) . append ( f \" { i + 1 } : { status } \" ) continue if len ( keywords ) >= 128 : nerrors += 1 errors . setdefault ( \"keywords length over 128\" , []) . append ( f \" { i + 1 } : { len ( keywords ) } \" ) continue if len ( ntext ) >= 1024 : nerrors += 1 errors . setdefault ( \"note text length over 1024\" , []) . append ( f \" { i + 1 } : { len ( ntext ) } \" ) continue if nerrors > 20 : msgs . append ([ \"error\" , \"too many errors, aborting\" ]) break if is_shared == \"T\" : shared_on = f \"' { now } '\" if is_published == \"T\" : published_on = f \"' { now } '\" keywordList = keywords . split () if len ( keywordList ) == 0 : errors . setdefault ( \"empty keyword\" , []) . append ( f ' { i + 1 } :\" { keywords } \"' ) continue allKeywords |= set ( keywordList ) keywords = \"\" . join ( f \" { x } \" for x in keywordList ) allVersions . add ( version ) thisChunk . append ( ( f \"(' { version } ',' { book } ', { chapter } , { verse } , { clause_atom } ,\" f \"' { is_shared } ',' { is_published } ',\" f \"' { status } ',' { keywords } ',' { ntext } ', { myId } ,\" f \"' { created_on } ',' { modified_on } ', { shared_on } , { published_on } ,'b')\" ) ) thisI += 1 if thisI >= chunksize : chunks . append ( thisChunk ) thisChunk = [] thisI = 0 if len ( thisChunk ): chunks . append ( thisChunk ) if errors or nerrors : good = False else : avrep = \"', '\" . join ( allVersions ) whereVersion = f \"version in (' { avrep } ')\" whereKeywords = \" or \" . join ( f \" keywords like '% { keyword } %' \" for keyword in keywordList ) # first delete previously bulk uploaded notes by this author # and with these keywords and these versions delSql = dedent ( f \"\"\" delete from note where bulk = 'b' and created_by = { myId } and { whereVersion } and { whereKeywords } ; \"\"\" ) NOTE_DB . executesql ( delSql ) NOTE_DB . commit () for chunk in chunks : chunkRep = \", \\n \" . join ( chunk ) sql = f \" { sqlhead } { chunkRep } ;\" NOTE_DB . executesql ( sql ) NOTE_DB . commit () Caching . clear ( r \"^items_n_\" ) for vr in myVersions : Caching . clear ( f \"^verses_ { vr } _n_\" ) for msg in sorted ( errors ): istr = \",\" . join ( str ( i ) for i in errors [ msg ]) msgs . append ([ \"error\" , f \" { msg } : { istr } \" ]) msgs . append ([ \"good\" if good else \"error\" , \"Done\" ]) return dict ( data = json . dumps ( dict ( msgs = msgs , good = good )))","title":"upload()"},{"location":"server/bymodule/notetree/","text":"notetree \u00b6 NOTETREE \u00b6 __init__ ( self ) special \u00b6 Source code in modules/notetree.py def __init__ ( self ): pass get ( self ) \u00b6 Get the metadata of all queries and deliver it as json. Source code in modules/notetree.py def get ( self ): \"\"\"Get the metadata of all queries and deliver it as json. \"\"\" auth = current . auth NOTE_DB = current . NOTE_DB VERSION_ORDER = current . VERSION_ORDER VERSION_INDEX = current . VERSION_INDEX myId = None if auth . user : myId = auth . user . id objInfo = collections . defaultdict ( lambda : {}) def titleBadge ( obj_id , objType , tot ): name = objInfo [ objType ][ obj_id ] if objType is not None else \"Shared Notes\" badge = \"\" if tot != 0 : badge = f '<span class=\"total special\"> { tot } </span>' return f '<span n=\"1\"> { hEsc ( name ) } </span><span class=\"brn\">( { badge } )</span>' condition = ( dedent ( \"\"\" where note.is_shared = 'T' \"\"\" ) if myId is None else dedent ( f \"\"\" where note.is_shared = 'T' or note.created_by = { myId } \"\"\" ) ) projectNoteSql = dedent ( f \"\"\" select count(note.id) as amount, note.version, note.keywords, concat(auth_user.first_name, ' ', auth_user.last_name) as uname, auth_user.id as user_id from note inner join shebanq_web.auth_user on note.created_by = shebanq_web.auth_user.id { condition } group by auth_user.id, note.keywords, note.version order by shebanq_web.auth_user.last_name, shebanq_web.auth_user.first_name, note.keywords ; \"\"\" ) projectNote = NOTE_DB . executesql ( projectNoteSql ) projectNotes = collections . OrderedDict () for ( amount , nvr , keywordList , uname , user_id ) in projectNote : for keywords in set ( keywordList . strip () . split ()): key_id = iEncode ( \"n\" , user_id , keywords = keywords ) if key_id not in projectNotes : projectNotes [ key_id ] = { \"\" : ( uname , user_id , keywords ), \"v\" : [ 0 for v in VERSION_ORDER ], } projectNotes [ key_id ][ \"v\" ][ VERSION_INDEX [ nvr ]] = amount tree = collections . OrderedDict () countSet = collections . defaultdict ( lambda : set ()) countUser = collections . defaultdict ( lambda : 0 ) count = 0 for key_id in projectNotes : projectNoteInfo = projectNotes [ key_id ] ( uname , user_id , noteName ) = projectNoteInfo [ \"\" ] countSet [ \"u\" ] . add ( user_id ) countSet [ \"n\" ] . add ( key_id ) objInfo [ \"u\" ][ user_id ] = uname tree . setdefault ( user_id , []) . append ( key_id ) count += 1 countUser [ user_id ] += 1 objInfo [ \"u\" ][ 0 ] = \"\" objInfo [ \"n\" ] = projectNotes categoryCount = dict (( x [ 0 ], len ( x [ 1 ])) for x in countSet . items ()) categoryCount [ \"user_id\" ] = myId title = titleBadge ( None , None , count ) dest = [ dict ( title = str ( title ), folder = True , children = [], data = categoryCount )] curDest = dest [ - 1 ][ \"children\" ] curSource = tree for user_id in curSource : userTotal = countUser [ user_id ] userTitle = titleBadge ( user_id , \"u\" , userTotal ) curDest . append ( dict ( title = str ( userTitle ), folder = True , children = [])) curUserDest = curDest [ - 1 ][ \"children\" ] curUserSource = curSource [ user_id ] for key_id in curUserSource : projectNoteInfo = objInfo [ \"n\" ][ key_id ] ( uname , user_id , noteName ) = projectNoteInfo [ \"\" ] noteVersions = projectNoteInfo [ \"v\" ] versionRep = \" \" . join ( formatVersion ( \"n\" , key_id , v , noteVersions [ VERSION_INDEX [ v ]]) for v in VERSION_ORDER ) curUserDest . append ( dict ( title = ( f \"\"\" { versionRep } <a class=\"n keywords\" n=\"1\" key_id=\" { key_id } \" href=\"#\" > { hEsc ( noteName ) } </a> <a class=\"md\" href=\"#\"></a>\"\"\" ), key = f \"n { key_id } \" , folder = False , ), ) return dict ( data = json . dumps ( dest ))","title":"Notetree"},{"location":"server/bymodule/notetree/#notetree","text":"","title":"notetree"},{"location":"server/bymodule/notetree/#notetree.NOTETREE","text":"","title":"NOTETREE"},{"location":"server/bymodule/notetree/#notetree.NOTETREE.__init__","text":"Source code in modules/notetree.py def __init__ ( self ): pass","title":"__init__()"},{"location":"server/bymodule/notetree/#notetree.NOTETREE.get","text":"Get the metadata of all queries and deliver it as json. Source code in modules/notetree.py def get ( self ): \"\"\"Get the metadata of all queries and deliver it as json. \"\"\" auth = current . auth NOTE_DB = current . NOTE_DB VERSION_ORDER = current . VERSION_ORDER VERSION_INDEX = current . VERSION_INDEX myId = None if auth . user : myId = auth . user . id objInfo = collections . defaultdict ( lambda : {}) def titleBadge ( obj_id , objType , tot ): name = objInfo [ objType ][ obj_id ] if objType is not None else \"Shared Notes\" badge = \"\" if tot != 0 : badge = f '<span class=\"total special\"> { tot } </span>' return f '<span n=\"1\"> { hEsc ( name ) } </span><span class=\"brn\">( { badge } )</span>' condition = ( dedent ( \"\"\" where note.is_shared = 'T' \"\"\" ) if myId is None else dedent ( f \"\"\" where note.is_shared = 'T' or note.created_by = { myId } \"\"\" ) ) projectNoteSql = dedent ( f \"\"\" select count(note.id) as amount, note.version, note.keywords, concat(auth_user.first_name, ' ', auth_user.last_name) as uname, auth_user.id as user_id from note inner join shebanq_web.auth_user on note.created_by = shebanq_web.auth_user.id { condition } group by auth_user.id, note.keywords, note.version order by shebanq_web.auth_user.last_name, shebanq_web.auth_user.first_name, note.keywords ; \"\"\" ) projectNote = NOTE_DB . executesql ( projectNoteSql ) projectNotes = collections . OrderedDict () for ( amount , nvr , keywordList , uname , user_id ) in projectNote : for keywords in set ( keywordList . strip () . split ()): key_id = iEncode ( \"n\" , user_id , keywords = keywords ) if key_id not in projectNotes : projectNotes [ key_id ] = { \"\" : ( uname , user_id , keywords ), \"v\" : [ 0 for v in VERSION_ORDER ], } projectNotes [ key_id ][ \"v\" ][ VERSION_INDEX [ nvr ]] = amount tree = collections . OrderedDict () countSet = collections . defaultdict ( lambda : set ()) countUser = collections . defaultdict ( lambda : 0 ) count = 0 for key_id in projectNotes : projectNoteInfo = projectNotes [ key_id ] ( uname , user_id , noteName ) = projectNoteInfo [ \"\" ] countSet [ \"u\" ] . add ( user_id ) countSet [ \"n\" ] . add ( key_id ) objInfo [ \"u\" ][ user_id ] = uname tree . setdefault ( user_id , []) . append ( key_id ) count += 1 countUser [ user_id ] += 1 objInfo [ \"u\" ][ 0 ] = \"\" objInfo [ \"n\" ] = projectNotes categoryCount = dict (( x [ 0 ], len ( x [ 1 ])) for x in countSet . items ()) categoryCount [ \"user_id\" ] = myId title = titleBadge ( None , None , count ) dest = [ dict ( title = str ( title ), folder = True , children = [], data = categoryCount )] curDest = dest [ - 1 ][ \"children\" ] curSource = tree for user_id in curSource : userTotal = countUser [ user_id ] userTitle = titleBadge ( user_id , \"u\" , userTotal ) curDest . append ( dict ( title = str ( userTitle ), folder = True , children = [])) curUserDest = curDest [ - 1 ][ \"children\" ] curUserSource = curSource [ user_id ] for key_id in curUserSource : projectNoteInfo = objInfo [ \"n\" ][ key_id ] ( uname , user_id , noteName ) = projectNoteInfo [ \"\" ] noteVersions = projectNoteInfo [ \"v\" ] versionRep = \" \" . join ( formatVersion ( \"n\" , key_id , v , noteVersions [ VERSION_INDEX [ v ]]) for v in VERSION_ORDER ) curUserDest . append ( dict ( title = ( f \"\"\" { versionRep } <a class=\"n keywords\" n=\"1\" key_id=\" { key_id } \" href=\"#\" > { hEsc ( noteName ) } </a> <a class=\"md\" href=\"#\"></a>\"\"\" ), key = f \"n { key_id } \" , folder = False , ), ) return dict ( data = json . dumps ( dest ))","title":"get()"},{"location":"server/bymodule/query/","text":"query \u00b6 QUERY \u00b6 __init__ ( self ) special \u00b6 Source code in modules/query.py def __init__ ( self ): pass authRead ( self , query_id ) \u00b6 Source code in modules/query.py def authRead ( self , query_id ): auth = current . auth authorized = None if query_id == 0 : authorized = auth . user is not None else : record = self . getPlainInfo ( query_id ) if record : authorized = record [ \"is_shared\" ] or ( auth . user is not None and record [ \"created_by\" ] == auth . user . id ) msg = ( f \"No query with id: { query_id } \" if authorized is None else f \"You have no access to query with id { query_id } \" ) return ( authorized , msg ) authWrite ( self , query_id ) \u00b6 Source code in modules/query.py def authWrite ( self , query_id ): auth = current . auth authorized = None if query_id == 0 : authorized = auth . user is not None else : record = self . getPlainInfo ( query_id ) if record : authorized = ( auth . user is not None and record [ \"created_by\" ] == auth . user . id ) msg = ( f \"No item with id { query_id } \" if authorized is None else f \"You have no access to create/modify query with id { query_id } \" ) return ( authorized , msg ) page ( self , ViewSettings ) \u00b6 Source code in modules/query.py def page ( self , ViewSettings ): Check = current . Check pageConfig = ViewSettings . writeConfig () query_id = Check . isId ( \"goto\" , \"q\" , \"query\" , []) if query_id is not None : ( authorized , msg ) = self . authRead ( query_id ) if not authorized : query_id = 0 return dict ( pageConfig = pageConfig , query_id = query_id , ) body ( self ) \u00b6 Retrieves a query record based on parameters. Source code in modules/query.py def body ( self ): \"\"\"Retrieves a query record based on parameters. \"\"\" Check = current . Check auth = current . auth vr = Check . field ( \"material\" , \"\" , \"version\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) ( iid , keywords ) = iDecode ( \"q\" , iidRep ) ( authorized , msg ) = self . authRead ( iid ) msgs = [] if authorized and iid == 0 : msg = f \"Not a valid query id: { iidRep } \" if not authorized or iid == 0 : msgs . append (( \"error\" , msg )) return dict ( writable = False , iidRep = iidRep , vr = vr , queryRecord = dict (), query = json . dumps ( dict ()), msgs = json . dumps ( msgs ), emdrosVersionsOld = set ( EMDROS_VERSIONS [ 0 : - 1 ]), ) queryRecord = self . getInfo ( auth . user is not None , iid , vr , msgs , withIds = True , singleVersion = False , po = True , ) if queryRecord is None : return dict ( writable = True , iidRep = iidRep , vr = vr , queryRecord = dict (), query = json . dumps ( dict ()), msgs = json . dumps ( msgs ), emdrosVersionsOld = set ( EMDROS_VERSIONS [ 0 : - 1 ]), ) ( authorized , msg ) = self . authWrite ( iid ) return dict ( writable = authorized , iidRep = iidRep , vr = vr , queryRecord = queryRecord , query = json . dumps ( queryRecord ), msgs = json . dumps ( msgs ), emdrosVersionsOld = set ( EMDROS_VERSIONS [ 0 : - 1 ]), ) bodyJson ( self ) \u00b6 Source code in modules/query.py def bodyJson ( self ): Check = current . Check vr = Check . field ( \"material\" , \"\" , \"version\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) ( iid , keywords ) = iDecode ( \"q\" , iidRep ) ( authorized , msg ) = self . authRead ( iid ) if not authorized : result = dict ( good = False , msg = [ msg ], data = {}) else : msgs = [] queryRecord = self . getInfo ( False , iid , vr , msgs , withIds = False , singleVersion = False , po = True ) result = dict ( good = queryRecord is not None , msg = msgs , data = queryRecord ) return dict ( data = json . dumps ( result )) getItems ( self , vr , chapter , onlyPub ) \u00b6 Source code in modules/query.py def getItems ( self , vr , chapter , onlyPub ): Caching = current . Caching pubStatus = Caching . get ( f \"pubStatus_ { vr } _\" , lambda : {}, ALWAYS , ) queriesFromChapter = Caching . get ( f \"queriesFromChapter_ { vr } _\" , lambda : {}, ALWAYS , ) chapter_id = chapter . get ( \"id\" , None ) if chapter_id is None : return [] slots = collections . defaultdict ( lambda : set ()) r = [] for ( query_id , ranges ) in queriesFromChapter . get ( chapter_id , {}) . items (): if onlyPub and not pubStatus . get ( query_id , {}) . get ( vr , False ): continue for ( first_m , last_m ) in ranges : slots [ query_id ] |= set ( range ( first_m , last_m + 1 )) if len ( slots ): msgs = [] queryrecords = self . getInfo ( False , ( str ( q ) for q in slots ), vr , msgs , withIds = False , singleVersion = True , po = False , ) for q in queryrecords : r . append ({ \"item\" : q , \"slots\" : json . dumps ( sorted ( list ( slots [ q [ \"id\" ]])))}) return r read ( self , vr , query_id ) \u00b6 Source code in modules/query.py def read ( self , vr , query_id ): db = current . db query_exe_id = self . getExe ( vr , query_id ) if query_exe_id is None : return normRanges ([]) slotSets = db . executesql ( dedent ( f \"\"\" select first_m, last_m from monads where query_exe_id = { query_exe_id } order by first_m ; \"\"\" ) ) return normRanges ( slotSets ) getExe ( self , vr , query_id ) \u00b6 Source code in modules/query.py def getExe ( self , vr , query_id ): db = current . db recordsExe = db . executesql ( dedent ( f \"\"\" select id from query_exe where query_id = { query_id } and version = ' { vr } ' ; \"\"\" ) ) if recordsExe is None or len ( recordsExe ) != 1 : return None return recordsExe [ 0 ][ 0 ] getPlainInfo ( self , query_id ) \u00b6 Source code in modules/query.py def getPlainInfo ( self , query_id ): db = current . db records = db . executesql ( dedent ( f \"\"\" select * from query where id = { query_id } ; \"\"\" ), as_dict = True , ) return records [ 0 ] if records else {} getBasicInfo ( self , vr , query_id ) \u00b6 Source code in modules/query.py def getBasicInfo ( self , vr , query_id ): db = current . db return db . executesql ( dedent ( f \"\"\" select query.name as name, query.description as description, query.is_shared as is_shared, query_exe.mql as mql, query_exe.is_published as is_published from query inner join query_exe on query.id = query_exe.query_id and query_exe.version = ' { vr } ' where query.id = { query_id } ; \"\"\" ), as_dict = True , ) getTreeInfo ( self , query_id ) \u00b6 Source code in modules/query.py def getTreeInfo ( self , query_id ): db = current . db return db . executesql ( dedent ( f \"\"\" select query.id as id, query.name as name, organization.id as org_id, organization.name as org_name, organization.website as org_website, project.id as project_id, project.name as project_name, project.website as project_website from query inner join organization on query.organization = organization.id inner join project on query.project = project.id where query.id = { query_id } ; \"\"\" ), as_dict = True , ) getInfo ( self , showPrivateFields , query_id , vr , msgs , singleVersion = False , withIds = True , po = False ) \u00b6 If called with singleVersion is True, we are grabbibg queries for the side list of a chapter. In this case: * query_id is an iterable of query ids * we only want the query exe records of these queries for a single version vr * we only want query records that are: * belong to a shared query * up to date: executed after modified Source code in modules/query.py def getInfo ( self , showPrivateFields , query_id , vr , msgs , singleVersion = False , withIds = True , po = False , ): \"\"\" If called with singleVersion is True, we are grabbibg queries for the side list of a chapter. In this case: * query_id is an iterable of query ids * we only want the query exe records of these queries for a single version vr * we only want query records that are: * belong to a shared query * up to date: executed after modified \"\"\" db = current . db sqli = ( dedent ( \"\"\", query.created_by as user_id, project.id as project_id, organization.id as org_id \"\"\" ) if withIds and po else \"\" ) sqlx = ( dedent ( \"\"\", query_exe.id as query_exe_id, query_exe.mql as mql, query_exe.version as version, query_exe.eversion as eversion, query_exe.resultmonads as resultmonads, query_exe.results as results, query_exe.executed_on as executed_on, query_exe.modified_on as xmodified_on, query_exe.is_published as is_published, query_exe.published_on as published_on \"\"\" ) if singleVersion else \"\" ) sqlp = ( dedent ( \"\"\", project.name as project_name, project.website as project_website, organization.name as org_name, organization.website as org_website \"\"\" ) if po else \"\" ) sqlb = ( dedent ( \"\"\", auth_user.email as uemail \"\"\" ) if showPrivateFields else dedent ( \"\"\", 'n.n@not.disclosed' as uemail \"\"\" ) ) sqlm = dedent ( f \"\"\" query.id as id, query.name as name, query.description as description, query.created_on as created_on, query.modified_on as modified_on, query.is_shared as is_shared, query.shared_on as shared_on, auth_user.first_name, auth_user.last_name { sqlb }{ sqli }{ sqlp }{ sqlx } \"\"\" ) sqlr = ( dedent ( f \"\"\" inner join query_exe on query_exe.query_id = query.id and query_exe.version = ' { vr } ' \"\"\" ) if singleVersion else \"\" ) sqlpr = ( dedent ( \"\"\" inner join organization on query.organization = organization.id inner join project on query.project = project.id \"\"\" ) if po else \"\" ) sqlc = ( dedent ( f \"\"\" where query.id in ( { \",\" . join ( query_id ) } ) and query.is_shared = 'T' and query_exe.executed_on >= query_exe.modified_on \"\"\" ) if singleVersion else dedent ( f \"\"\" where query.id = { query_id } \"\"\" ) ) sqlo = ( dedent ( \"\"\" order by auth_user.last_name, query.name \"\"\" ) if singleVersion else \"\" ) sql = dedent ( f \"\"\" select { sqlm } from query inner join auth_user on query.created_by = auth_user.id { sqlr }{ sqlpr }{ sqlc }{ sqlo } ; \"\"\" ) records = db . executesql ( sql , as_dict = True ) if records is None : msgs . append (( \"error\" , \"Cannot lookup query(ies)\" )) return None if singleVersion : for record in records : self . getFields ( vr , record , [], singleVersion = True ) return records else : if len ( records ) == 0 : msgs . append (( \"error\" , f \"No query with id { query_id } \" )) return None record = records [ 0 ] record [ \"description_md\" ] = markdown ( record [ \"description\" ] or \"\" , output_format = \"xhtml5\" ) sql = dedent ( f \"\"\" select id as query_exe_id, mql, version, eversion, resultmonads, results, executed_on, modified_on as xmodified_on, is_published, published_on from query_exe where query_id = { query_id } ; \"\"\" ) recordsExe = db . executesql ( sql , as_dict = True ) self . getFields ( vr , record , recordsExe , singleVersion = False ) return record getFields ( self , vr , record , recordsExe , singleVersion = False ) \u00b6 Source code in modules/query.py def getFields ( self , vr , record , recordsExe , singleVersion = False ): VERSIONS = current . VERSIONS dateTimeStr ( record ) if not singleVersion : record [ \"versions\" ] = dict ( ( v , dict ( query_exe_id = None , mql = None , status = \"warning\" , is_published = None , results = None , resultmonads = None , xmodified_on = None , executed_on = None , eversion = None , published_on = None , ), ) for v in VERSIONS ) for recordExe in recordsExe : versionExe = recordExe [ \"version\" ] if versionExe not in VERSIONS : continue dest = record [ \"versions\" ][ versionExe ] dest . update ( recordExe ) dest [ \"status\" ] = queryStatus ( dest ) dateTimeStr ( dest ) dateTimeStr ( fields ) \u00b6 Source code in modules/query.py def dateTimeStr ( fields ): for f in ( \"created_on\" , \"modified_on\" , \"shared_on\" , \"xmodified_on\" , \"executed_on\" , \"published_on\" , ): if f in fields : ov = fields [ f ] fields [ f ] = str ( ov ) if ov else NULLDT for f in ( \"is_shared\" , \"is_published\" ): if f in fields : fields [ f ] = fields [ f ] == \"T\" queryStatus ( queryExeRecord ) \u00b6 Source code in modules/query.py def queryStatus ( queryExeRecord ): if not queryExeRecord [ \"executed_on\" ]: return \"warning\" if queryExeRecord [ \"executed_on\" ] < queryExeRecord [ \"xmodified_on\" ]: return \"error\" return \"good\"","title":"Query"},{"location":"server/bymodule/query/#query","text":"","title":"query"},{"location":"server/bymodule/query/#query.QUERY","text":"","title":"QUERY"},{"location":"server/bymodule/query/#query.QUERY.__init__","text":"Source code in modules/query.py def __init__ ( self ): pass","title":"__init__()"},{"location":"server/bymodule/query/#query.QUERY.authRead","text":"Source code in modules/query.py def authRead ( self , query_id ): auth = current . auth authorized = None if query_id == 0 : authorized = auth . user is not None else : record = self . getPlainInfo ( query_id ) if record : authorized = record [ \"is_shared\" ] or ( auth . user is not None and record [ \"created_by\" ] == auth . user . id ) msg = ( f \"No query with id: { query_id } \" if authorized is None else f \"You have no access to query with id { query_id } \" ) return ( authorized , msg )","title":"authRead()"},{"location":"server/bymodule/query/#query.QUERY.authWrite","text":"Source code in modules/query.py def authWrite ( self , query_id ): auth = current . auth authorized = None if query_id == 0 : authorized = auth . user is not None else : record = self . getPlainInfo ( query_id ) if record : authorized = ( auth . user is not None and record [ \"created_by\" ] == auth . user . id ) msg = ( f \"No item with id { query_id } \" if authorized is None else f \"You have no access to create/modify query with id { query_id } \" ) return ( authorized , msg )","title":"authWrite()"},{"location":"server/bymodule/query/#query.QUERY.page","text":"Source code in modules/query.py def page ( self , ViewSettings ): Check = current . Check pageConfig = ViewSettings . writeConfig () query_id = Check . isId ( \"goto\" , \"q\" , \"query\" , []) if query_id is not None : ( authorized , msg ) = self . authRead ( query_id ) if not authorized : query_id = 0 return dict ( pageConfig = pageConfig , query_id = query_id , )","title":"page()"},{"location":"server/bymodule/query/#query.QUERY.body","text":"Retrieves a query record based on parameters. Source code in modules/query.py def body ( self ): \"\"\"Retrieves a query record based on parameters. \"\"\" Check = current . Check auth = current . auth vr = Check . field ( \"material\" , \"\" , \"version\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) ( iid , keywords ) = iDecode ( \"q\" , iidRep ) ( authorized , msg ) = self . authRead ( iid ) msgs = [] if authorized and iid == 0 : msg = f \"Not a valid query id: { iidRep } \" if not authorized or iid == 0 : msgs . append (( \"error\" , msg )) return dict ( writable = False , iidRep = iidRep , vr = vr , queryRecord = dict (), query = json . dumps ( dict ()), msgs = json . dumps ( msgs ), emdrosVersionsOld = set ( EMDROS_VERSIONS [ 0 : - 1 ]), ) queryRecord = self . getInfo ( auth . user is not None , iid , vr , msgs , withIds = True , singleVersion = False , po = True , ) if queryRecord is None : return dict ( writable = True , iidRep = iidRep , vr = vr , queryRecord = dict (), query = json . dumps ( dict ()), msgs = json . dumps ( msgs ), emdrosVersionsOld = set ( EMDROS_VERSIONS [ 0 : - 1 ]), ) ( authorized , msg ) = self . authWrite ( iid ) return dict ( writable = authorized , iidRep = iidRep , vr = vr , queryRecord = queryRecord , query = json . dumps ( queryRecord ), msgs = json . dumps ( msgs ), emdrosVersionsOld = set ( EMDROS_VERSIONS [ 0 : - 1 ]), )","title":"body()"},{"location":"server/bymodule/query/#query.QUERY.bodyJson","text":"Source code in modules/query.py def bodyJson ( self ): Check = current . Check vr = Check . field ( \"material\" , \"\" , \"version\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) ( iid , keywords ) = iDecode ( \"q\" , iidRep ) ( authorized , msg ) = self . authRead ( iid ) if not authorized : result = dict ( good = False , msg = [ msg ], data = {}) else : msgs = [] queryRecord = self . getInfo ( False , iid , vr , msgs , withIds = False , singleVersion = False , po = True ) result = dict ( good = queryRecord is not None , msg = msgs , data = queryRecord ) return dict ( data = json . dumps ( result ))","title":"bodyJson()"},{"location":"server/bymodule/query/#query.QUERY.getItems","text":"Source code in modules/query.py def getItems ( self , vr , chapter , onlyPub ): Caching = current . Caching pubStatus = Caching . get ( f \"pubStatus_ { vr } _\" , lambda : {}, ALWAYS , ) queriesFromChapter = Caching . get ( f \"queriesFromChapter_ { vr } _\" , lambda : {}, ALWAYS , ) chapter_id = chapter . get ( \"id\" , None ) if chapter_id is None : return [] slots = collections . defaultdict ( lambda : set ()) r = [] for ( query_id , ranges ) in queriesFromChapter . get ( chapter_id , {}) . items (): if onlyPub and not pubStatus . get ( query_id , {}) . get ( vr , False ): continue for ( first_m , last_m ) in ranges : slots [ query_id ] |= set ( range ( first_m , last_m + 1 )) if len ( slots ): msgs = [] queryrecords = self . getInfo ( False , ( str ( q ) for q in slots ), vr , msgs , withIds = False , singleVersion = True , po = False , ) for q in queryrecords : r . append ({ \"item\" : q , \"slots\" : json . dumps ( sorted ( list ( slots [ q [ \"id\" ]])))}) return r","title":"getItems()"},{"location":"server/bymodule/query/#query.QUERY.read","text":"Source code in modules/query.py def read ( self , vr , query_id ): db = current . db query_exe_id = self . getExe ( vr , query_id ) if query_exe_id is None : return normRanges ([]) slotSets = db . executesql ( dedent ( f \"\"\" select first_m, last_m from monads where query_exe_id = { query_exe_id } order by first_m ; \"\"\" ) ) return normRanges ( slotSets )","title":"read()"},{"location":"server/bymodule/query/#query.QUERY.getExe","text":"Source code in modules/query.py def getExe ( self , vr , query_id ): db = current . db recordsExe = db . executesql ( dedent ( f \"\"\" select id from query_exe where query_id = { query_id } and version = ' { vr } ' ; \"\"\" ) ) if recordsExe is None or len ( recordsExe ) != 1 : return None return recordsExe [ 0 ][ 0 ]","title":"getExe()"},{"location":"server/bymodule/query/#query.QUERY.getPlainInfo","text":"Source code in modules/query.py def getPlainInfo ( self , query_id ): db = current . db records = db . executesql ( dedent ( f \"\"\" select * from query where id = { query_id } ; \"\"\" ), as_dict = True , ) return records [ 0 ] if records else {}","title":"getPlainInfo()"},{"location":"server/bymodule/query/#query.QUERY.getBasicInfo","text":"Source code in modules/query.py def getBasicInfo ( self , vr , query_id ): db = current . db return db . executesql ( dedent ( f \"\"\" select query.name as name, query.description as description, query.is_shared as is_shared, query_exe.mql as mql, query_exe.is_published as is_published from query inner join query_exe on query.id = query_exe.query_id and query_exe.version = ' { vr } ' where query.id = { query_id } ; \"\"\" ), as_dict = True , )","title":"getBasicInfo()"},{"location":"server/bymodule/query/#query.QUERY.getTreeInfo","text":"Source code in modules/query.py def getTreeInfo ( self , query_id ): db = current . db return db . executesql ( dedent ( f \"\"\" select query.id as id, query.name as name, organization.id as org_id, organization.name as org_name, organization.website as org_website, project.id as project_id, project.name as project_name, project.website as project_website from query inner join organization on query.organization = organization.id inner join project on query.project = project.id where query.id = { query_id } ; \"\"\" ), as_dict = True , )","title":"getTreeInfo()"},{"location":"server/bymodule/query/#query.QUERY.getInfo","text":"If called with singleVersion is True, we are grabbibg queries for the side list of a chapter. In this case: * query_id is an iterable of query ids * we only want the query exe records of these queries for a single version vr * we only want query records that are: * belong to a shared query * up to date: executed after modified Source code in modules/query.py def getInfo ( self , showPrivateFields , query_id , vr , msgs , singleVersion = False , withIds = True , po = False , ): \"\"\" If called with singleVersion is True, we are grabbibg queries for the side list of a chapter. In this case: * query_id is an iterable of query ids * we only want the query exe records of these queries for a single version vr * we only want query records that are: * belong to a shared query * up to date: executed after modified \"\"\" db = current . db sqli = ( dedent ( \"\"\", query.created_by as user_id, project.id as project_id, organization.id as org_id \"\"\" ) if withIds and po else \"\" ) sqlx = ( dedent ( \"\"\", query_exe.id as query_exe_id, query_exe.mql as mql, query_exe.version as version, query_exe.eversion as eversion, query_exe.resultmonads as resultmonads, query_exe.results as results, query_exe.executed_on as executed_on, query_exe.modified_on as xmodified_on, query_exe.is_published as is_published, query_exe.published_on as published_on \"\"\" ) if singleVersion else \"\" ) sqlp = ( dedent ( \"\"\", project.name as project_name, project.website as project_website, organization.name as org_name, organization.website as org_website \"\"\" ) if po else \"\" ) sqlb = ( dedent ( \"\"\", auth_user.email as uemail \"\"\" ) if showPrivateFields else dedent ( \"\"\", 'n.n@not.disclosed' as uemail \"\"\" ) ) sqlm = dedent ( f \"\"\" query.id as id, query.name as name, query.description as description, query.created_on as created_on, query.modified_on as modified_on, query.is_shared as is_shared, query.shared_on as shared_on, auth_user.first_name, auth_user.last_name { sqlb }{ sqli }{ sqlp }{ sqlx } \"\"\" ) sqlr = ( dedent ( f \"\"\" inner join query_exe on query_exe.query_id = query.id and query_exe.version = ' { vr } ' \"\"\" ) if singleVersion else \"\" ) sqlpr = ( dedent ( \"\"\" inner join organization on query.organization = organization.id inner join project on query.project = project.id \"\"\" ) if po else \"\" ) sqlc = ( dedent ( f \"\"\" where query.id in ( { \",\" . join ( query_id ) } ) and query.is_shared = 'T' and query_exe.executed_on >= query_exe.modified_on \"\"\" ) if singleVersion else dedent ( f \"\"\" where query.id = { query_id } \"\"\" ) ) sqlo = ( dedent ( \"\"\" order by auth_user.last_name, query.name \"\"\" ) if singleVersion else \"\" ) sql = dedent ( f \"\"\" select { sqlm } from query inner join auth_user on query.created_by = auth_user.id { sqlr }{ sqlpr }{ sqlc }{ sqlo } ; \"\"\" ) records = db . executesql ( sql , as_dict = True ) if records is None : msgs . append (( \"error\" , \"Cannot lookup query(ies)\" )) return None if singleVersion : for record in records : self . getFields ( vr , record , [], singleVersion = True ) return records else : if len ( records ) == 0 : msgs . append (( \"error\" , f \"No query with id { query_id } \" )) return None record = records [ 0 ] record [ \"description_md\" ] = markdown ( record [ \"description\" ] or \"\" , output_format = \"xhtml5\" ) sql = dedent ( f \"\"\" select id as query_exe_id, mql, version, eversion, resultmonads, results, executed_on, modified_on as xmodified_on, is_published, published_on from query_exe where query_id = { query_id } ; \"\"\" ) recordsExe = db . executesql ( sql , as_dict = True ) self . getFields ( vr , record , recordsExe , singleVersion = False ) return record","title":"getInfo()"},{"location":"server/bymodule/query/#query.QUERY.getFields","text":"Source code in modules/query.py def getFields ( self , vr , record , recordsExe , singleVersion = False ): VERSIONS = current . VERSIONS dateTimeStr ( record ) if not singleVersion : record [ \"versions\" ] = dict ( ( v , dict ( query_exe_id = None , mql = None , status = \"warning\" , is_published = None , results = None , resultmonads = None , xmodified_on = None , executed_on = None , eversion = None , published_on = None , ), ) for v in VERSIONS ) for recordExe in recordsExe : versionExe = recordExe [ \"version\" ] if versionExe not in VERSIONS : continue dest = record [ \"versions\" ][ versionExe ] dest . update ( recordExe ) dest [ \"status\" ] = queryStatus ( dest ) dateTimeStr ( dest )","title":"getFields()"},{"location":"server/bymodule/query/#query.dateTimeStr","text":"Source code in modules/query.py def dateTimeStr ( fields ): for f in ( \"created_on\" , \"modified_on\" , \"shared_on\" , \"xmodified_on\" , \"executed_on\" , \"published_on\" , ): if f in fields : ov = fields [ f ] fields [ f ] = str ( ov ) if ov else NULLDT for f in ( \"is_shared\" , \"is_published\" ): if f in fields : fields [ f ] = fields [ f ] == \"T\"","title":"dateTimeStr()"},{"location":"server/bymodule/query/#query.queryStatus","text":"Source code in modules/query.py def queryStatus ( queryExeRecord ): if not queryExeRecord [ \"executed_on\" ]: return \"warning\" if queryExeRecord [ \"executed_on\" ] < queryExeRecord [ \"xmodified_on\" ]: return \"error\" return \"good\"","title":"queryStatus()"},{"location":"server/bymodule/querychapter/","text":"querychapter \u00b6 QUERYCHAPTER \u00b6 __init__ ( self ) special \u00b6 Source code in modules/querychapter.py def __init__ ( self ): pass makeQCindexes ( self ) \u00b6 Source code in modules/querychapter.py def makeQCindexes ( self ): VERSIONS = current . VERSIONS for vr in ( ( \"2017\" , \"2021\" ) if current . SITUATION == \"local\" else VERSIONS ): self . makeQCindex ( vr ) makeQCindex ( self , vr ) \u00b6 We build an index of queries by chapter in which they have results. The index building takes may take multiple seconds per data version. But the result is stored in the cache. We need to prevent that index-making is triggered multiple times by several requests that are fired while index-making is in progress. So we put an indicator value in the cache during index buidling, and we let everybody else wait until the index has been completed. We do this per version. To that end we put an empty dictionary in the cache. We only start computing the index key \"busy\" has a falsy value. Before computing the index, we set the value to 1. After computing the index, we set the value to 2. When the index is needed and the busy status is 1, we wait for it to become 2 before we continue. When the index is needed and busy is 2, the index has been built and we have to do nothing. Note that we do not need anything of the value of the index here, we only need it to be built, so that other parts of the app can get it quickly. We cannot allow that other parts of the app see an unfinished index, because it will lead to served content that is not yet correct. Because this content will be cached, it will take a long time (or forever) until it gets recomputed. Source code in modules/querychapter.py def makeQCindex ( self , vr ): \"\"\"We build an index of queries by chapter in which they have results. The index building takes may take multiple seconds per data version. But the result is stored in the cache. We need to prevent that index-making is triggered multiple times by several requests that are fired while index-making is in progress. So we put an indicator value in the cache during index buidling, and we let everybody else wait until the index has been completed. We do this per version. To that end we put an empty dictionary in the cache. We only start computing the index key \"busy\" has a falsy value. Before computing the index, we set the value to 1. After computing the index, we set the value to 2. When the index is needed and the busy status is 1, we wait for it to become 2 before we continue. When the index is needed and busy is 2, the index has been built and we have to do nothing. Note that we do not need anything of the value of the index here, we only need it to be built, so that other parts of the app can get it quickly. We cannot allow that other parts of the app see an unfinished index, because it will lead to served content that is not yet correct. Because this content will be cached, it will take a long time (or forever) until it gets recomputed. \"\"\" Caching = current . Caching busyStatus = Caching . get ( f \"busyIndex_ { vr } _\" , lambda : {}, ALWAYS ) busy = busyStatus . get ( \"busy\" , 0 ) if busy == 0 : busyStatus [ \"busy\" ] = 1 Caching . get ( f \"qcindex_ { vr } _\" , lambda : self . makeQCindex_c ( vr ), ALWAYS ) busyStatus [ \"busy\" ] = 2 elif busy == 1 : n = 0 while ( Caching . get ( f \"busyIndex_ { vr } _\" , lambda : {}, ALWAYS ) . get ( \"busy\" , 0 ) == 1 ): time . sleep ( 1 ) n += 1 debug ( f \"o-o-o waiting for chapter-query index { vr } ( { n } sec) ...\" ) makeQCindex_c ( self , vr ) \u00b6 Source code in modules/querychapter.py def makeQCindex_c ( self , vr ): Caching = current . Caching db = current . db PASSAGE_DBS = current . PASSAGE_DBS debug ( f \"o-o-o making chapter-query index for version { vr } ...\" ) startTime = time . time () pubStatus = Caching . get ( f \"pubStatus_ { vr } _\" , lambda : {}, ALWAYS , ) slotsFromChapter = Caching . get ( f \"slotsFromChapter_ { vr } _\" , lambda : {}, ALWAYS , ) chapterFromSlot = Caching . get ( f \"chapterFromSlot_ { vr } _\" , lambda : {}, ALWAYS , ) queriesFromChapter = Caching . get ( f \"queriesFromChapter_ { vr } _\" , lambda : {}, ALWAYS , ) chaptersFromQuery = Caching . get ( f \"chaptersFromQuery_ { vr } _\" , lambda : {}, ALWAYS , ) chapterSQL = dedent ( \"\"\" select id, first_m, last_m from chapter ; \"\"\" ) chapterList = PASSAGE_DBS [ vr ] . executesql ( chapterSQL ) for ( chapter_id , first_m , last_m ) in chapterList : for m in range ( first_m , last_m + 1 ): chapterFromSlot [ m ] = chapter_id slotsFromChapter [ chapter_id ] = last_m resultSQL1 = dedent ( f \"\"\" select query_exe.id, query_exe.is_published, query.id from query inner join query_exe on query.id = query_exe.query_id where query_exe.version = ' { vr } ' and query_exe.executed_on >= query_exe.modified_on and query.is_shared = 'T' ; \"\"\" ) queryTime = time . time () results1 = db . executesql ( resultSQL1 ) queryTime = time . time () - queryTime debug ( f \" found { len ( results1 ) } shared queries in { delta ( queryTime ) } \" ) queryFromExe = {} for ( query_exe_id , is_published , query_id ) in results1 : queryFromExe [ query_exe_id ] = query_id pubStatus . setdefault ( query_id , {})[ vr ] = is_published == \"T\" if queryFromExe : doQueryIndex ( db , vr , queryFromExe ) exe = time . time () - startTime debug ( f \"o-o-o made chapter-query index for data { vr } in { delta ( exe ) } \" ) return ( queriesFromChapter , chaptersFromQuery ) updatePubStatus ( self , vr , query_id , is_published ) \u00b6 Source code in modules/querychapter.py def updatePubStatus ( self , vr , query_id , is_published ): Caching = current . Caching debug ( f \"o-o-o updating pubStatus for query { query_id } in version { vr } ...\" ) pubStatus = Caching . get ( f \"pubStatus_ { vr } _\" , lambda : {}, ALWAYS , ) pubStatus . setdefault ( query_id , {})[ vr ] = is_published debug ( f \"o-o-o updating pubStatus for query { query_id } in version { vr } done\" ) updateQCindex ( self , vr , query_id , uptodate = True ) \u00b6 Update the chapter-query index if a query has been run or rerun. We want an up to date mapping from chapters to the shared, up-to-date queries with results in those chapters. We call this function when: * a query has run and a niew set of slots has been stored. * the sharing status of a query changes We do not call this function when: * the published state of a query has changed (see updatePubStatus) * when a query body is edited but not run (see below). In those cases the following will be taken care of: First delete the query from the index. If the query is shared and up to date, we add it back to the index based on its results. However, this function might be called at a time that the results of the query have been stored in the database, before the metadata has arrived there. In that case we can not test on the uptodateness, so we assume that the caller has passed uptodate=True. Indeed, when the sharing status has changed, we are able to perform this test, and then there is no need to pass uptodate=True. What if a query body is edited but not run? It will then become outdated, and should be removed from the index. But that is a rather costly operation, and it is likely that a query is edited many times before it is run again. What we do instead is, that when we fetch queries for the sidebar of a chapter, we skip the ones that are outdated. Source code in modules/querychapter.py def updateQCindex ( self , vr , query_id , uptodate = True ): \"\"\"Update the chapter-query index if a query has been run or rerun. We want an up to date mapping from chapters to the shared, up-to-date queries with results in those chapters. We call this function when: * a query has run and a niew set of slots has been stored. * the sharing status of a query changes We do not call this function when: * the published state of a query has changed (see updatePubStatus) * when a query body is edited but not run (see below). In those cases the following will be taken care of: First delete the query from the index. If the query is shared and up to date, we add it back to the index based on its results. However, this function might be called at a time that the results of the query have been stored in the database, before the metadata has arrived there. In that case we can not test on the uptodateness, so we assume that the caller has passed uptodate=True. Indeed, when the sharing status has changed, we are able to perform this test, and then there is no need to pass uptodate=True. What if a query body is edited but not run? It will then become outdated, and should be removed from the index. But that is a rather costly operation, and it is likely that a query is edited many times before it is run again. What we do instead is, that when we fetch queries for the sidebar of a chapter, we skip the ones that are outdated. \"\"\" Caching = current . Caching db = current . db debug (( f \"o-o-o updating chapter-query index for data { vr } \" )) startTime = time . time () chaptersFromQuery = Caching . get ( f \"chaptersFromQuery_ { vr } _\" , lambda : {}, ALWAYS , ) queriesFromChapter = Caching . get ( f \"queriesFromChapter_ { vr } _\" , lambda : {}, ALWAYS , ) # remove query_id from both indexes: chaptersFromQuery and queriesFromChapter if query_id in chaptersFromQuery : theseChapters = chaptersFromQuery [ query_id ] for chapter_id in theseChapters : if chapter_id in queriesFromChapter : if query_id in queriesFromChapter [ chapter_id ]: del queriesFromChapter [ chapter_id ][ query_id ] if not queriesFromChapter [ chapter_id ]: del queriesFromChapter [ chapter_id ] del chaptersFromQuery [ query_id ] # add query_id again to both indexes (but now with updated results) uptodateSQL = ( \"\" if uptodate else dedent ( \"\"\" and query_exe.executed_on >= query_exe.modified_on \"\"\" ) ) resultSQL1 = dedent ( f \"\"\" select query_exe.id, query.id from query inner join query_exe on query.id = query_exe.query_id where query.id = { query_id } and query_exe.version = ' { vr } ' and query.is_shared = 'T' { uptodateSQL } ; \"\"\" ) queryTime = time . time () results1 = db . executesql ( resultSQL1 ) queryTime = time . time () - queryTime debug ( f \" found { len ( results1 ) } shared queries in { delta ( queryTime ) } \" ) queryFromExe = {} for ( query_exe_id , query_id ) in results1 : queryFromExe [ query_exe_id ] = query_id if queryFromExe : doQueryIndex ( db , vr , queryFromExe ) exe = time . time () - startTime debug ( f \"o-o-o updated chapter-query index for data { vr } in { delta ( exe ) } \" ) doQueryIndex ( db , vr , queryFromExe ) \u00b6 Source code in modules/querychapter.py def doQueryIndex ( db , vr , queryFromExe ): Caching = current . Caching slotsFromChapter = Caching . get ( f \"slotsFromChapter_ { vr } _\" , lambda : {}, ALWAYS ) chapterFromSlot = Caching . get ( f \"chapterFromSlot_ { vr } _\" , lambda : {}, ALWAYS ) chaptersFromQuery = Caching . get ( f \"chaptersFromQuery_ { vr } _\" , lambda : {}, ALWAYS ) queriesFromChapter = Caching . get ( f \"queriesFromChapter_ { vr } _\" , lambda : {}, ALWAYS ) resultSQL2 = dedent ( f \"\"\" select query_exe_id, first_m, last_m from monads where query_exe_id in ( { \",\" . join ( str ( idx ) for idx in queryFromExe ) } ) ; \"\"\" ) queryTime = time . time () results2 = db . executesql ( resultSQL2 ) queryTime = time . time () - queryTime debug ( f \" found { len ( results2 ) } result intervals in { delta ( queryTime ) } \" ) debug ( \" processing information about queries ...\" ) procTime = time . time () resultsByQ = {} for ( query_exe_id , first_m , last_m ) in results2 : query_id = queryFromExe [ query_exe_id ] resultsByQ . setdefault ( query_id , []) . append (( first_m , last_m )) debug ( f \" found { len ( resultsByQ ) } shared queries\" ) for ( query_id , ranges ) in resultsByQ . items (): chapters = {} for ( first_m , last_m ) in ranges : if first_m == last_m : chapter_id = chapterFromSlot [ first_m ] chapters . setdefault ( chapter_id , []) . append (( first_m , first_m )) continue m = first_m while m <= last_m : chapter_id = chapterFromSlot [ m ] chapterLastSlot = slotsFromChapter [ chapter_id ] endM = min (( last_m , chapterLastSlot )) chapters . setdefault ( chapter_id , []) . append (( m , endM )) m = chapterLastSlot + 1 if chapters : chaptersFromQuery [ query_id ] = list ( chapters ) for ( chapter_id , ranges ) in chapters . items (): queriesFromChapter . setdefault ( chapter_id , {})[ query_id ] = ranges procTime = time . time () - procTime debug ( f \" processed shared queries into index in { delta ( procTime ) } \" )","title":"Querychapter"},{"location":"server/bymodule/querychapter/#querychapter","text":"","title":"querychapter"},{"location":"server/bymodule/querychapter/#querychapter.QUERYCHAPTER","text":"","title":"QUERYCHAPTER"},{"location":"server/bymodule/querychapter/#querychapter.QUERYCHAPTER.__init__","text":"Source code in modules/querychapter.py def __init__ ( self ): pass","title":"__init__()"},{"location":"server/bymodule/querychapter/#querychapter.QUERYCHAPTER.makeQCindexes","text":"Source code in modules/querychapter.py def makeQCindexes ( self ): VERSIONS = current . VERSIONS for vr in ( ( \"2017\" , \"2021\" ) if current . SITUATION == \"local\" else VERSIONS ): self . makeQCindex ( vr )","title":"makeQCindexes()"},{"location":"server/bymodule/querychapter/#querychapter.QUERYCHAPTER.makeQCindex","text":"We build an index of queries by chapter in which they have results. The index building takes may take multiple seconds per data version. But the result is stored in the cache. We need to prevent that index-making is triggered multiple times by several requests that are fired while index-making is in progress. So we put an indicator value in the cache during index buidling, and we let everybody else wait until the index has been completed. We do this per version. To that end we put an empty dictionary in the cache. We only start computing the index key \"busy\" has a falsy value. Before computing the index, we set the value to 1. After computing the index, we set the value to 2. When the index is needed and the busy status is 1, we wait for it to become 2 before we continue. When the index is needed and busy is 2, the index has been built and we have to do nothing. Note that we do not need anything of the value of the index here, we only need it to be built, so that other parts of the app can get it quickly. We cannot allow that other parts of the app see an unfinished index, because it will lead to served content that is not yet correct. Because this content will be cached, it will take a long time (or forever) until it gets recomputed. Source code in modules/querychapter.py def makeQCindex ( self , vr ): \"\"\"We build an index of queries by chapter in which they have results. The index building takes may take multiple seconds per data version. But the result is stored in the cache. We need to prevent that index-making is triggered multiple times by several requests that are fired while index-making is in progress. So we put an indicator value in the cache during index buidling, and we let everybody else wait until the index has been completed. We do this per version. To that end we put an empty dictionary in the cache. We only start computing the index key \"busy\" has a falsy value. Before computing the index, we set the value to 1. After computing the index, we set the value to 2. When the index is needed and the busy status is 1, we wait for it to become 2 before we continue. When the index is needed and busy is 2, the index has been built and we have to do nothing. Note that we do not need anything of the value of the index here, we only need it to be built, so that other parts of the app can get it quickly. We cannot allow that other parts of the app see an unfinished index, because it will lead to served content that is not yet correct. Because this content will be cached, it will take a long time (or forever) until it gets recomputed. \"\"\" Caching = current . Caching busyStatus = Caching . get ( f \"busyIndex_ { vr } _\" , lambda : {}, ALWAYS ) busy = busyStatus . get ( \"busy\" , 0 ) if busy == 0 : busyStatus [ \"busy\" ] = 1 Caching . get ( f \"qcindex_ { vr } _\" , lambda : self . makeQCindex_c ( vr ), ALWAYS ) busyStatus [ \"busy\" ] = 2 elif busy == 1 : n = 0 while ( Caching . get ( f \"busyIndex_ { vr } _\" , lambda : {}, ALWAYS ) . get ( \"busy\" , 0 ) == 1 ): time . sleep ( 1 ) n += 1 debug ( f \"o-o-o waiting for chapter-query index { vr } ( { n } sec) ...\" )","title":"makeQCindex()"},{"location":"server/bymodule/querychapter/#querychapter.QUERYCHAPTER.makeQCindex_c","text":"Source code in modules/querychapter.py def makeQCindex_c ( self , vr ): Caching = current . Caching db = current . db PASSAGE_DBS = current . PASSAGE_DBS debug ( f \"o-o-o making chapter-query index for version { vr } ...\" ) startTime = time . time () pubStatus = Caching . get ( f \"pubStatus_ { vr } _\" , lambda : {}, ALWAYS , ) slotsFromChapter = Caching . get ( f \"slotsFromChapter_ { vr } _\" , lambda : {}, ALWAYS , ) chapterFromSlot = Caching . get ( f \"chapterFromSlot_ { vr } _\" , lambda : {}, ALWAYS , ) queriesFromChapter = Caching . get ( f \"queriesFromChapter_ { vr } _\" , lambda : {}, ALWAYS , ) chaptersFromQuery = Caching . get ( f \"chaptersFromQuery_ { vr } _\" , lambda : {}, ALWAYS , ) chapterSQL = dedent ( \"\"\" select id, first_m, last_m from chapter ; \"\"\" ) chapterList = PASSAGE_DBS [ vr ] . executesql ( chapterSQL ) for ( chapter_id , first_m , last_m ) in chapterList : for m in range ( first_m , last_m + 1 ): chapterFromSlot [ m ] = chapter_id slotsFromChapter [ chapter_id ] = last_m resultSQL1 = dedent ( f \"\"\" select query_exe.id, query_exe.is_published, query.id from query inner join query_exe on query.id = query_exe.query_id where query_exe.version = ' { vr } ' and query_exe.executed_on >= query_exe.modified_on and query.is_shared = 'T' ; \"\"\" ) queryTime = time . time () results1 = db . executesql ( resultSQL1 ) queryTime = time . time () - queryTime debug ( f \" found { len ( results1 ) } shared queries in { delta ( queryTime ) } \" ) queryFromExe = {} for ( query_exe_id , is_published , query_id ) in results1 : queryFromExe [ query_exe_id ] = query_id pubStatus . setdefault ( query_id , {})[ vr ] = is_published == \"T\" if queryFromExe : doQueryIndex ( db , vr , queryFromExe ) exe = time . time () - startTime debug ( f \"o-o-o made chapter-query index for data { vr } in { delta ( exe ) } \" ) return ( queriesFromChapter , chaptersFromQuery )","title":"makeQCindex_c()"},{"location":"server/bymodule/querychapter/#querychapter.QUERYCHAPTER.updatePubStatus","text":"Source code in modules/querychapter.py def updatePubStatus ( self , vr , query_id , is_published ): Caching = current . Caching debug ( f \"o-o-o updating pubStatus for query { query_id } in version { vr } ...\" ) pubStatus = Caching . get ( f \"pubStatus_ { vr } _\" , lambda : {}, ALWAYS , ) pubStatus . setdefault ( query_id , {})[ vr ] = is_published debug ( f \"o-o-o updating pubStatus for query { query_id } in version { vr } done\" )","title":"updatePubStatus()"},{"location":"server/bymodule/querychapter/#querychapter.QUERYCHAPTER.updateQCindex","text":"Update the chapter-query index if a query has been run or rerun. We want an up to date mapping from chapters to the shared, up-to-date queries with results in those chapters. We call this function when: * a query has run and a niew set of slots has been stored. * the sharing status of a query changes We do not call this function when: * the published state of a query has changed (see updatePubStatus) * when a query body is edited but not run (see below). In those cases the following will be taken care of: First delete the query from the index. If the query is shared and up to date, we add it back to the index based on its results. However, this function might be called at a time that the results of the query have been stored in the database, before the metadata has arrived there. In that case we can not test on the uptodateness, so we assume that the caller has passed uptodate=True. Indeed, when the sharing status has changed, we are able to perform this test, and then there is no need to pass uptodate=True. What if a query body is edited but not run? It will then become outdated, and should be removed from the index. But that is a rather costly operation, and it is likely that a query is edited many times before it is run again. What we do instead is, that when we fetch queries for the sidebar of a chapter, we skip the ones that are outdated. Source code in modules/querychapter.py def updateQCindex ( self , vr , query_id , uptodate = True ): \"\"\"Update the chapter-query index if a query has been run or rerun. We want an up to date mapping from chapters to the shared, up-to-date queries with results in those chapters. We call this function when: * a query has run and a niew set of slots has been stored. * the sharing status of a query changes We do not call this function when: * the published state of a query has changed (see updatePubStatus) * when a query body is edited but not run (see below). In those cases the following will be taken care of: First delete the query from the index. If the query is shared and up to date, we add it back to the index based on its results. However, this function might be called at a time that the results of the query have been stored in the database, before the metadata has arrived there. In that case we can not test on the uptodateness, so we assume that the caller has passed uptodate=True. Indeed, when the sharing status has changed, we are able to perform this test, and then there is no need to pass uptodate=True. What if a query body is edited but not run? It will then become outdated, and should be removed from the index. But that is a rather costly operation, and it is likely that a query is edited many times before it is run again. What we do instead is, that when we fetch queries for the sidebar of a chapter, we skip the ones that are outdated. \"\"\" Caching = current . Caching db = current . db debug (( f \"o-o-o updating chapter-query index for data { vr } \" )) startTime = time . time () chaptersFromQuery = Caching . get ( f \"chaptersFromQuery_ { vr } _\" , lambda : {}, ALWAYS , ) queriesFromChapter = Caching . get ( f \"queriesFromChapter_ { vr } _\" , lambda : {}, ALWAYS , ) # remove query_id from both indexes: chaptersFromQuery and queriesFromChapter if query_id in chaptersFromQuery : theseChapters = chaptersFromQuery [ query_id ] for chapter_id in theseChapters : if chapter_id in queriesFromChapter : if query_id in queriesFromChapter [ chapter_id ]: del queriesFromChapter [ chapter_id ][ query_id ] if not queriesFromChapter [ chapter_id ]: del queriesFromChapter [ chapter_id ] del chaptersFromQuery [ query_id ] # add query_id again to both indexes (but now with updated results) uptodateSQL = ( \"\" if uptodate else dedent ( \"\"\" and query_exe.executed_on >= query_exe.modified_on \"\"\" ) ) resultSQL1 = dedent ( f \"\"\" select query_exe.id, query.id from query inner join query_exe on query.id = query_exe.query_id where query.id = { query_id } and query_exe.version = ' { vr } ' and query.is_shared = 'T' { uptodateSQL } ; \"\"\" ) queryTime = time . time () results1 = db . executesql ( resultSQL1 ) queryTime = time . time () - queryTime debug ( f \" found { len ( results1 ) } shared queries in { delta ( queryTime ) } \" ) queryFromExe = {} for ( query_exe_id , query_id ) in results1 : queryFromExe [ query_exe_id ] = query_id if queryFromExe : doQueryIndex ( db , vr , queryFromExe ) exe = time . time () - startTime debug ( f \"o-o-o updated chapter-query index for data { vr } in { delta ( exe ) } \" )","title":"updateQCindex()"},{"location":"server/bymodule/querychapter/#querychapter.doQueryIndex","text":"Source code in modules/querychapter.py def doQueryIndex ( db , vr , queryFromExe ): Caching = current . Caching slotsFromChapter = Caching . get ( f \"slotsFromChapter_ { vr } _\" , lambda : {}, ALWAYS ) chapterFromSlot = Caching . get ( f \"chapterFromSlot_ { vr } _\" , lambda : {}, ALWAYS ) chaptersFromQuery = Caching . get ( f \"chaptersFromQuery_ { vr } _\" , lambda : {}, ALWAYS ) queriesFromChapter = Caching . get ( f \"queriesFromChapter_ { vr } _\" , lambda : {}, ALWAYS ) resultSQL2 = dedent ( f \"\"\" select query_exe_id, first_m, last_m from monads where query_exe_id in ( { \",\" . join ( str ( idx ) for idx in queryFromExe ) } ) ; \"\"\" ) queryTime = time . time () results2 = db . executesql ( resultSQL2 ) queryTime = time . time () - queryTime debug ( f \" found { len ( results2 ) } result intervals in { delta ( queryTime ) } \" ) debug ( \" processing information about queries ...\" ) procTime = time . time () resultsByQ = {} for ( query_exe_id , first_m , last_m ) in results2 : query_id = queryFromExe [ query_exe_id ] resultsByQ . setdefault ( query_id , []) . append (( first_m , last_m )) debug ( f \" found { len ( resultsByQ ) } shared queries\" ) for ( query_id , ranges ) in resultsByQ . items (): chapters = {} for ( first_m , last_m ) in ranges : if first_m == last_m : chapter_id = chapterFromSlot [ first_m ] chapters . setdefault ( chapter_id , []) . append (( first_m , first_m )) continue m = first_m while m <= last_m : chapter_id = chapterFromSlot [ m ] chapterLastSlot = slotsFromChapter [ chapter_id ] endM = min (( last_m , chapterLastSlot )) chapters . setdefault ( chapter_id , []) . append (( m , endM )) m = chapterLastSlot + 1 if chapters : chaptersFromQuery [ query_id ] = list ( chapters ) for ( chapter_id , ranges ) in chapters . items (): queriesFromChapter . setdefault ( chapter_id , {})[ query_id ] = ranges procTime = time . time () - procTime debug ( f \" processed shared queries into index in { delta ( procTime ) } \" )","title":"doQueryIndex()"},{"location":"server/bymodule/queryrecent/","text":"queryrecent \u00b6 RECENT_LIMIT \u00b6 QUERYRECENT \u00b6 Handles the set of recent queries. It can select the most recently saved shared queries. It can export them as an RSS feed. __init__ ( self ) special \u00b6 Source code in modules/queryrecent.py def __init__ ( self ): pass recent ( self ) \u00b6 Select the most recently saved shared queries. The next query contains a clever idea from stackoverflow . We want to find the most recent mql queries. Queries may have multiple executions. We want to have the queries with the most recent executions. From such queries, we only want to have the single most recent execution. This idea can be obtained by left outer joining the query_exe table with itself (qe1 with qe2) on the condition that those rows are combined where qe1 and qe2 belong to the same query, and qe2 is more recent. Rows in the combined table where qe2 is null, are such that qe1 is most recent. This is the basic idea. We then have to refine it: we only want shared queries. That is an easy where condition on the final result. We only want to have up-to-date queries. So the join condition is not that qe2 is more recent, but that qe2 is up-to-date and more recent. And we need to add a where to express that qe1 is up to date. Source code in modules/queryrecent.py def recent ( self ): \"\"\"Select the most recently saved shared queries. The next query contains a clever idea from [stackoverflow](https://stackoverflow.com/questions/5657446/mysql-query-max-group-by). We want to find the most recent mql queries. Queries may have multiple executions. We want to have the queries with the most recent executions. From such queries, we only want to have the single most recent execution. This idea can be obtained by left outer joining the `query_exe` table with itself (qe1 with qe2) on the condition that those rows are combined where qe1 and qe2 belong to the same query, and qe2 is more recent. Rows in the combined table where qe2 is null, are such that qe1 is most recent. This is the basic idea. We then have to refine it: we only want shared queries. That is an easy where condition on the final result. We only want to have up-to-date queries. So the join condition is not that qe2 is more recent, but that qe2 is up-to-date and more recent. And we need to add a where to express that qe1 is up to date. \"\"\" db = current . db projectQueryXSql = dedent ( f \"\"\" select query.id as query_id, auth_user.first_name, auth_user.last_name, query.name as query_name, qe.executed_on as qexe, qe.version as qver from query inner join ( select qe1.query_id, qe1.executed_on, qe1.version from query_exe qe1 left outer join query_exe qe2 on ( qe1.query_id = qe2.query_id and qe1.executed_on < qe2.executed_on and qe2.executed_on >= qe2.modified_on ) where ( qe1.executed_on is not null and qe1.executed_on >= qe1.modified_on ) and qe2.query_id is null ) as qe on qe.query_id = query.id inner join auth_user on query.created_by = auth_user.id where query.is_shared = 'T' order by qe.executed_on desc, auth_user.last_name limit { RECENT_LIMIT } ; \"\"\" ) pqueryx = db . executesql ( projectQueryXSql ) pqueries = [] for ( query_id , first_name , last_name , query_name , qexe , qver ) in pqueryx : text = hEsc ( f \" { first_name [ 0 ] } { last_name [ 0 : 9 ] } : { query_name [ 0 : 20 ] } \" ) title = hEsc ( f \" { first_name } { last_name } : { query_name } \" ) pqueries . append ( dict ( id = query_id , text = text , title = title , version = qver )) return dict ( data = json . dumps ( dict ( queries = pqueries , msgs = [], good = True ))) feed ( self ) \u00b6 Source code in modules/queryrecent.py def feed ( self ): db = current . db sql = dedent ( \"\"\" select query.id as query_id, auth_user.first_name, auth_user.last_name, query.name as query_name, query.description, qe.id as qvid, qe.executed_on as qexe, qe.version as qver from query inner join ( select t1.id, t1.query_id, t1.executed_on, t1.version from query_exe t1 left outer join query_exe t2 on ( t1.query_id = t2.query_id and t1.executed_on < t2.executed_on and t2.executed_on >= t2.modified_on ) where ( t1.executed_on is not null and t1.executed_on >= t1.modified_on ) and t2.query_id is null ) as qe on qe.query_id = query.id inner join auth_user on query.created_by = auth_user.id where query.is_shared = 'T' order by qe.executed_on desc, auth_user.last_name \"\"\" ) return db . executesql ( sql )","title":"Queryrecent"},{"location":"server/bymodule/queryrecent/#queryrecent","text":"","title":"queryrecent"},{"location":"server/bymodule/queryrecent/#queryrecent.RECENT_LIMIT","text":"","title":"RECENT_LIMIT"},{"location":"server/bymodule/queryrecent/#queryrecent.QUERYRECENT","text":"Handles the set of recent queries. It can select the most recently saved shared queries. It can export them as an RSS feed.","title":"QUERYRECENT"},{"location":"server/bymodule/queryrecent/#queryrecent.QUERYRECENT.__init__","text":"Source code in modules/queryrecent.py def __init__ ( self ): pass","title":"__init__()"},{"location":"server/bymodule/queryrecent/#queryrecent.QUERYRECENT.recent","text":"Select the most recently saved shared queries. The next query contains a clever idea from stackoverflow . We want to find the most recent mql queries. Queries may have multiple executions. We want to have the queries with the most recent executions. From such queries, we only want to have the single most recent execution. This idea can be obtained by left outer joining the query_exe table with itself (qe1 with qe2) on the condition that those rows are combined where qe1 and qe2 belong to the same query, and qe2 is more recent. Rows in the combined table where qe2 is null, are such that qe1 is most recent. This is the basic idea. We then have to refine it: we only want shared queries. That is an easy where condition on the final result. We only want to have up-to-date queries. So the join condition is not that qe2 is more recent, but that qe2 is up-to-date and more recent. And we need to add a where to express that qe1 is up to date. Source code in modules/queryrecent.py def recent ( self ): \"\"\"Select the most recently saved shared queries. The next query contains a clever idea from [stackoverflow](https://stackoverflow.com/questions/5657446/mysql-query-max-group-by). We want to find the most recent mql queries. Queries may have multiple executions. We want to have the queries with the most recent executions. From such queries, we only want to have the single most recent execution. This idea can be obtained by left outer joining the `query_exe` table with itself (qe1 with qe2) on the condition that those rows are combined where qe1 and qe2 belong to the same query, and qe2 is more recent. Rows in the combined table where qe2 is null, are such that qe1 is most recent. This is the basic idea. We then have to refine it: we only want shared queries. That is an easy where condition on the final result. We only want to have up-to-date queries. So the join condition is not that qe2 is more recent, but that qe2 is up-to-date and more recent. And we need to add a where to express that qe1 is up to date. \"\"\" db = current . db projectQueryXSql = dedent ( f \"\"\" select query.id as query_id, auth_user.first_name, auth_user.last_name, query.name as query_name, qe.executed_on as qexe, qe.version as qver from query inner join ( select qe1.query_id, qe1.executed_on, qe1.version from query_exe qe1 left outer join query_exe qe2 on ( qe1.query_id = qe2.query_id and qe1.executed_on < qe2.executed_on and qe2.executed_on >= qe2.modified_on ) where ( qe1.executed_on is not null and qe1.executed_on >= qe1.modified_on ) and qe2.query_id is null ) as qe on qe.query_id = query.id inner join auth_user on query.created_by = auth_user.id where query.is_shared = 'T' order by qe.executed_on desc, auth_user.last_name limit { RECENT_LIMIT } ; \"\"\" ) pqueryx = db . executesql ( projectQueryXSql ) pqueries = [] for ( query_id , first_name , last_name , query_name , qexe , qver ) in pqueryx : text = hEsc ( f \" { first_name [ 0 ] } { last_name [ 0 : 9 ] } : { query_name [ 0 : 20 ] } \" ) title = hEsc ( f \" { first_name } { last_name } : { query_name } \" ) pqueries . append ( dict ( id = query_id , text = text , title = title , version = qver )) return dict ( data = json . dumps ( dict ( queries = pqueries , msgs = [], good = True )))","title":"recent()"},{"location":"server/bymodule/queryrecent/#queryrecent.QUERYRECENT.feed","text":"Source code in modules/queryrecent.py def feed ( self ): db = current . db sql = dedent ( \"\"\" select query.id as query_id, auth_user.first_name, auth_user.last_name, query.name as query_name, query.description, qe.id as qvid, qe.executed_on as qexe, qe.version as qver from query inner join ( select t1.id, t1.query_id, t1.executed_on, t1.version from query_exe t1 left outer join query_exe t2 on ( t1.query_id = t2.query_id and t1.executed_on < t2.executed_on and t2.executed_on >= t2.modified_on ) where ( t1.executed_on is not null and t1.executed_on >= t1.modified_on ) and t2.query_id is null ) as qe on qe.query_id = query.id inner join auth_user on query.created_by = auth_user.id where query.is_shared = 'T' order by qe.executed_on desc, auth_user.last_name \"\"\" ) return db . executesql ( sql )","title":"feed()"},{"location":"server/bymodule/querysave/","text":"querysave \u00b6 QUERYSAVE \u00b6 __init__ ( self , Query , QueryChapter ) special \u00b6 Source code in modules/querysave.py def __init__ ( self , Query , QueryChapter ): self . Query = Query self . QueryChapter = QueryChapter putSlots ( self , vr , query_id , rows ) \u00b6 Source code in modules/querysave.py def putSlots ( self , vr , query_id , rows ): Caching = current . Caching Query = self . Query QueryChapter = self . QueryChapter db = current . db query_exe_id = Query . getExe ( vr , query_id ) if query_exe_id is None : return db . executesql ( dedent ( f \"\"\" delete from monads where query_exe_id= { query_exe_id } ; \"\"\" ) ) db . commit () # Here we clear stuff that will become invalid # because of a (re)execution of a query # and the deleting of previous results and the storing of new results. Caching . clear ( f \"^verses_ { vr } _q_ { query_id } _\" ) Caching . clear ( f \"^items_q_ { vr } _\" ) Caching . clear ( f \"^chart_ { vr } _q_ { query_id } _\" ) nRows = len ( rows ) if nRows > 0 : limitRow = 10000 start = dedent ( \"\"\" insert into monads (query_exe_id, first_m, last_m) values \"\"\" ) query = \"\" r = 0 while r < nRows : if query != \"\" : db . executesql ( f \" { query } ;\" ) query = \"\" query += start s = min ( r + limitRow , len ( rows )) row = rows [ r ] query += f \"( { query_exe_id } , { row [ 0 ] } , { row [ 1 ] } )\" if r + 1 < nRows : for row in rows [ r + 1 : s ]: query += f \",( { query_exe_id } , { row [ 0 ] } , { row [ 1 ] } )\" r = s if query != \"\" : db . executesql ( f \" { query } ;\" ) query = \"\" db . commit () QueryChapter . updateQCindex ( vr , query_id , uptodate = True ) sharing ( self ) \u00b6 Receives a new sharing status of a query and saves it to the database. Source code in modules/querysave.py def sharing ( self ): \"\"\"Receives a new sharing status of a query and saves it to the database. \"\"\" Check = current . Check Query = self . Query msgs = [] good = False modDates = {} modCls = {} extra = {} requestVars = current . request . vars for x in [ 1 ]: query_id = Check . isId ( \"query_id\" , \"q\" , \"query\" , msgs ) if query_id is None : break fieldName = requestVars . fname val = requestVars . val vr = requestVars . version if fieldName is None or fieldName not in { \"is_shared\" , \"is_published\" }: msgs . append (( \"error\" , f \"Illegal field name { fieldName } \" )) break ( authorized , msg ) = Query . authWrite ( query_id ) if not authorized : msgs . append (( \"error\" , msg )) break ( good , modDates , modCls , extra ) = self . putSharing ( vr , query_id , fieldName , val , msgs ) return dict ( data = json . dumps ( dict ( msgs = msgs , good = good , modDates = modDates , modCls = modCls , extra = extra ) ) ) putSharing ( self , vr , query_id , fname , val , msgs ) \u00b6 Source code in modules/querysave.py def putSharing ( self , vr , query_id , fname , val , msgs ): auth = current . auth db = current . db Check = current . Check now = current . request . utcnow good = False myId = None modDates = {} modCls = {} extra = {} if auth . user : myId = auth . user . id for x in [ 1 ]: valsql = Check . isPublished ( \"q\" , val , msgs ) if valsql is None : break if fname == \"is_shared\" and valsql == \"\" : sql = dedent ( f \"\"\" select count(*) from query_exe where query_id = { query_id } and is_published = 'T' ; \"\"\" ) pv = db . executesql ( sql ) hasPublicVersions = pv is not None and len ( pv ) == 1 and pv [ 0 ][ 0 ] > 0 if hasPublicVersions : msgs . append ( ( \"error\" , ( \"You cannot UNshare this query because there is\" \"a published execution record\" ), ) ) break if fname == \"is_published\" : modCls [ \"#is_pub_ro\" ] = f \"\"\"fa- { \"check\" if valsql == \"T\" else \"close\" } \"\"\" modCls [ f 'div[version=\" { vr } \"]' ] = ( \"published\" if valsql == \"T\" else \"unpublished\" ) extra [ \"execq\" ] = ( \"show\" , valsql != \"T\" ) if valsql == \"T\" : sql = dedent ( f \"\"\" select executed_on, modified_on as xmodified_on from query_exe where query_id = { query_id } and version = ' { vr } ' ; \"\"\" ) pv = db . executesql ( sql , as_dict = True ) if pv is None or len ( pv ) != 1 : msgs . append ( ( \"error\" , \"cannot determine whether query results are up to date\" , ) ) break uptodate = queryStatus ( pv [ 0 ]) if uptodate != \"good\" : msgs . append ( ( \"error\" , ( \"You can only publish \" \"if the query results are up to date\" ), ) ) break sql = dedent ( f \"\"\" select is_shared from query where id = { query_id } ; \"\"\" ) pv = db . executesql ( sql ) is_shared = pv is not None and len ( pv ) == 1 and pv [ 0 ][ 0 ] == \"T\" if not is_shared : ( modDateFld , modDate ) = self . putShared ( myId , query_id , \"T\" , msgs ) modDates [ modDateFld ] = modDate extra [ \"is_shared\" ] = ( \"checked\" , True ) else : sql = dedent ( f \"\"\" select published_on from query_exe where query_id = { query_id } and version = ' { vr } ' ; \"\"\" ) pv = db . executesql ( sql ) pubDateOk = ( pv is None or len ( pv ) != 1 or pv [ 0 ][ 0 ] is None or pv [ 0 ][ 0 ] > now - PUBLISH_FREEZE ) if not pubDateOk : msgs . append ( ( \"error\" , ( \"You cannot UNpublish this query because\" \"it has been published more than \" f \" { PUBLISH_FREEZE_MSG } ago\" ), ) ) break good = True if good : if fname == \"is_shared\" : ( modDateFld , modDate ) = self . putShared ( myId , query_id , valsql , msgs ) else : ( modDateFld , modDate ) = self . putPublished ( myId , vr , query_id , valsql , msgs ) modDates [ modDateFld ] = modDate return ( good , modDates , modCls , extra ) putShared ( self , myId , query_id , valsql , msgs ) \u00b6 Source code in modules/querysave.py def putShared ( self , myId , query_id , valsql , msgs ): Caching = current . Caching QueryChapter = self . QueryChapter db = current . db VERSIONS = current . VERSIONS modDate = None modDateFld = \"shared_on\" table = \"query\" fname = \"is_shared\" Caching . clear ( r \"^items_q_\" ) fieldval = f \" { fname } = ' { valsql } '\" now = current . request . utcnow modDate = now . replace ( microsecond = 0 ) if valsql == \"T\" else None modDateSql = \"null\" if modDate is None else f \" ' { modDate } '\" fieldval += f \", { modDateFld } = { modDateSql } \" sql = dedent ( f \"\"\" update { table } set { fieldval } where id = { query_id } ; \"\"\" ) db . executesql ( sql ) db . commit () for vr in VERSIONS : QueryChapter . updateQCindex ( vr , query_id ) thismsg = \"modified\" thismsg = \"shared\" if valsql == \"T\" else \"UNshared\" msgs . append (( \"good\" , thismsg )) return ( modDateFld , str ( modDate ) if modDate else NULLDT ) putPublished ( self , myId , vr , query_id , valsql , msgs ) \u00b6 Source code in modules/querysave.py def putPublished ( self , myId , vr , query_id , valsql , msgs ): Caching = current . Caching QueryChapter = self . QueryChapter db = current . db modDate = None modDateFld = \"published_on\" table = \"query_exe\" fname = \"is_published\" Caching . clear ( f \"^items_q_ { vr } _\" ) self . verifyVersion ( vr , query_id ) fieldval = f \" { fname } = ' { valsql } '\" now = current . request . utcnow modDate = now . replace ( microsecond = 0 ) if valsql == \"T\" else None modDateSql = \"null\" if modDate is None else f \" ' { modDate } '\" fieldval += f \", { modDateFld } = { modDateSql } \" sql = dedent ( f \"\"\" update { table } set { fieldval } where query_id = { query_id } and version = ' { vr } ' ; \"\"\" ) db . executesql ( sql ) db . commit () thismsg = \"modified\" thismsg = \"published\" if valsql == \"T\" else \"UNpublished\" QueryChapter . updatePubStatus ( vr , query_id , valsql == \"T\" ) msgs . append (( \"good\" , thismsg )) return ( modDateFld , str ( modDate ) if modDate else NULLDT ) putMeta ( self , vr , query_id , fields , fieldsExe ) \u00b6 Source code in modules/querysave.py def putMeta ( self , vr , query_id , fields , fieldsExe ): Caching = current . Caching db = current . db doCommit = False if len ( fields ): fieldRep = \", \" . join ( f \" { f } = ' { fields [ f ] } '\" for f in fields if f != \"status\" ) sql = dedent ( f \"\"\" update query set { fieldRep } where id = { query_id } ; \"\"\" ) db . executesql ( sql ) doCommit = True Caching . clear ( r \"^items_q_\" ) if len ( fieldsExe ): fieldRep = \", \" . join ( f \" { f } = ' { fieldsExe [ f ] } '\" for f in fieldsExe if f != \"status\" ) sql = dedent ( f \"\"\" update query_exe set { fieldRep } where query_id = { query_id } and version = ' { vr } ' ; \"\"\" ) db . executesql ( sql ) doCommit = True Caching . clear ( f \"^items_q_ { vr } _\" ) if doCommit : db . commit () putRecord ( self ) \u00b6 Receives updated record data of a query and stores it in the database. Source code in modules/querysave.py def putRecord ( self ): \"\"\"Receives updated record data of a query and stores it in the database. \"\"\" Check = current . Check Query = self . Query auth = current . auth requestVars = current . request . vars vr = requestVars . version nameNew = requestVars . name mqlNew = requestVars . mql descriptionNew = requestVars . description execute = requestVars . execute myId = auth . user . id if auth . user is not None else None now = current . request . utcnow msgs = [] good = False fields = {} fieldsExe = {} queryRecord = {} is_published = False for x in [ 1 ]: query_id = Check . isId ( \"query_id\" , \"q\" , \"query\" , msgs ) if query_id is None : break ( authorized , msg ) = Query . authWrite ( query_id ) if not authorized : msgs . append (( \"error\" , msg )) break self . verifyVersion ( vr , query_id ) recordOld = Query . getBasicInfo ( vr , query_id ) if recordOld is None or len ( recordOld ) == 0 : msgs . append (( \"error\" , f \"No query with id { query_id } \" )) break valsOld = recordOld [ 0 ] is_published = valsOld [ \"is_published\" ] == \"T\" if not is_published : if valsOld [ \"name\" ] != nameNew : valSql = Check . isName ( \"q\" , query_id , myId , nameNew , msgs ) if valSql is None : break fields [ \"name\" ] = valSql fields [ \"modified_on\" ] = now if valsOld [ \"mql\" ] != mqlNew : msgs . append (( \"warning\" , \"query body modified\" )) valSql = Check . isMql ( \"q\" , mqlNew , msgs ) if valSql is None : break fieldsExe [ \"mql\" ] = valSql fieldsExe [ \"modified_on\" ] = now else : msgs . append (( \"good\" , \"same query body\" )) else : msgs . append ( ( \"warning\" , ( \"only the description can been saved\" \"because this is a published query execution\" ), ) ) if valsOld [ \"description\" ] != descriptionNew : valSql = Check . isDescription ( \"q\" , descriptionNew , msgs ) if valSql is None : break fields [ \"description\" ] = valSql fields [ \"modified_on\" ] = now good = True if good : execute = not is_published and execute exeGood = True if execute == \"true\" : ( exeGood , limitExceeded , nResults , exeSlots , theseMsgs , emdrosVersion , ) = mql ( vr , mqlNew ) if exeGood and not limitExceeded : self . putSlots ( vr , query_id , exeSlots ) fieldsExe [ \"executed_on\" ] = now fieldsExe [ \"eversion\" ] = emdrosVersion nResultSlots = countSlots ( exeSlots ) fieldsExe [ \"results\" ] = nResults fieldsExe [ \"resultmonads\" ] = nResultSlots msgs . append (( \"good\" , \"Query executed\" )) else : self . putSlots ( vr , query_id , []) msgs . extend ( theseMsgs ) self . putMeta ( vr , query_id , fields , fieldsExe ) queryRecord = Query . getInfo ( auth . user is not None , query_id , vr , msgs , withIds = False , singleVersion = False , po = True , ) emdrosVersionsOld = dict (( x , 1 ) for x in EMDROS_VERSIONS [ 0 : - 1 ]) return dict ( data = json . dumps ( dict ( msgs = msgs , good = good and exeGood , query = queryRecord , emdrosVersionsOld = emdrosVersionsOld , ) ) ) verifyVersion ( self , vr , query_id ) \u00b6 Source code in modules/querysave.py def verifyVersion ( self , vr , query_id ): db = current . db existVersion = db . executesql ( dedent ( f \"\"\" select id from query_exe where version = ' { vr } ' and query_id = { query_id } ; \"\"\" ) ) if existVersion is None or len ( existVersion ) == 0 : db . executesql ( dedent ( f \"\"\" insert into query_exe (id, version, query_id) values (null, ' { vr } ', { query_id } ) ; \"\"\" ) ) db . commit ()","title":"Querysave"},{"location":"server/bymodule/querysave/#querysave","text":"","title":"querysave"},{"location":"server/bymodule/querysave/#querysave.QUERYSAVE","text":"","title":"QUERYSAVE"},{"location":"server/bymodule/querysave/#querysave.QUERYSAVE.__init__","text":"Source code in modules/querysave.py def __init__ ( self , Query , QueryChapter ): self . Query = Query self . QueryChapter = QueryChapter","title":"__init__()"},{"location":"server/bymodule/querysave/#querysave.QUERYSAVE.putSlots","text":"Source code in modules/querysave.py def putSlots ( self , vr , query_id , rows ): Caching = current . Caching Query = self . Query QueryChapter = self . QueryChapter db = current . db query_exe_id = Query . getExe ( vr , query_id ) if query_exe_id is None : return db . executesql ( dedent ( f \"\"\" delete from monads where query_exe_id= { query_exe_id } ; \"\"\" ) ) db . commit () # Here we clear stuff that will become invalid # because of a (re)execution of a query # and the deleting of previous results and the storing of new results. Caching . clear ( f \"^verses_ { vr } _q_ { query_id } _\" ) Caching . clear ( f \"^items_q_ { vr } _\" ) Caching . clear ( f \"^chart_ { vr } _q_ { query_id } _\" ) nRows = len ( rows ) if nRows > 0 : limitRow = 10000 start = dedent ( \"\"\" insert into monads (query_exe_id, first_m, last_m) values \"\"\" ) query = \"\" r = 0 while r < nRows : if query != \"\" : db . executesql ( f \" { query } ;\" ) query = \"\" query += start s = min ( r + limitRow , len ( rows )) row = rows [ r ] query += f \"( { query_exe_id } , { row [ 0 ] } , { row [ 1 ] } )\" if r + 1 < nRows : for row in rows [ r + 1 : s ]: query += f \",( { query_exe_id } , { row [ 0 ] } , { row [ 1 ] } )\" r = s if query != \"\" : db . executesql ( f \" { query } ;\" ) query = \"\" db . commit () QueryChapter . updateQCindex ( vr , query_id , uptodate = True )","title":"putSlots()"},{"location":"server/bymodule/querysave/#querysave.QUERYSAVE.sharing","text":"Receives a new sharing status of a query and saves it to the database. Source code in modules/querysave.py def sharing ( self ): \"\"\"Receives a new sharing status of a query and saves it to the database. \"\"\" Check = current . Check Query = self . Query msgs = [] good = False modDates = {} modCls = {} extra = {} requestVars = current . request . vars for x in [ 1 ]: query_id = Check . isId ( \"query_id\" , \"q\" , \"query\" , msgs ) if query_id is None : break fieldName = requestVars . fname val = requestVars . val vr = requestVars . version if fieldName is None or fieldName not in { \"is_shared\" , \"is_published\" }: msgs . append (( \"error\" , f \"Illegal field name { fieldName } \" )) break ( authorized , msg ) = Query . authWrite ( query_id ) if not authorized : msgs . append (( \"error\" , msg )) break ( good , modDates , modCls , extra ) = self . putSharing ( vr , query_id , fieldName , val , msgs ) return dict ( data = json . dumps ( dict ( msgs = msgs , good = good , modDates = modDates , modCls = modCls , extra = extra ) ) )","title":"sharing()"},{"location":"server/bymodule/querysave/#querysave.QUERYSAVE.putSharing","text":"Source code in modules/querysave.py def putSharing ( self , vr , query_id , fname , val , msgs ): auth = current . auth db = current . db Check = current . Check now = current . request . utcnow good = False myId = None modDates = {} modCls = {} extra = {} if auth . user : myId = auth . user . id for x in [ 1 ]: valsql = Check . isPublished ( \"q\" , val , msgs ) if valsql is None : break if fname == \"is_shared\" and valsql == \"\" : sql = dedent ( f \"\"\" select count(*) from query_exe where query_id = { query_id } and is_published = 'T' ; \"\"\" ) pv = db . executesql ( sql ) hasPublicVersions = pv is not None and len ( pv ) == 1 and pv [ 0 ][ 0 ] > 0 if hasPublicVersions : msgs . append ( ( \"error\" , ( \"You cannot UNshare this query because there is\" \"a published execution record\" ), ) ) break if fname == \"is_published\" : modCls [ \"#is_pub_ro\" ] = f \"\"\"fa- { \"check\" if valsql == \"T\" else \"close\" } \"\"\" modCls [ f 'div[version=\" { vr } \"]' ] = ( \"published\" if valsql == \"T\" else \"unpublished\" ) extra [ \"execq\" ] = ( \"show\" , valsql != \"T\" ) if valsql == \"T\" : sql = dedent ( f \"\"\" select executed_on, modified_on as xmodified_on from query_exe where query_id = { query_id } and version = ' { vr } ' ; \"\"\" ) pv = db . executesql ( sql , as_dict = True ) if pv is None or len ( pv ) != 1 : msgs . append ( ( \"error\" , \"cannot determine whether query results are up to date\" , ) ) break uptodate = queryStatus ( pv [ 0 ]) if uptodate != \"good\" : msgs . append ( ( \"error\" , ( \"You can only publish \" \"if the query results are up to date\" ), ) ) break sql = dedent ( f \"\"\" select is_shared from query where id = { query_id } ; \"\"\" ) pv = db . executesql ( sql ) is_shared = pv is not None and len ( pv ) == 1 and pv [ 0 ][ 0 ] == \"T\" if not is_shared : ( modDateFld , modDate ) = self . putShared ( myId , query_id , \"T\" , msgs ) modDates [ modDateFld ] = modDate extra [ \"is_shared\" ] = ( \"checked\" , True ) else : sql = dedent ( f \"\"\" select published_on from query_exe where query_id = { query_id } and version = ' { vr } ' ; \"\"\" ) pv = db . executesql ( sql ) pubDateOk = ( pv is None or len ( pv ) != 1 or pv [ 0 ][ 0 ] is None or pv [ 0 ][ 0 ] > now - PUBLISH_FREEZE ) if not pubDateOk : msgs . append ( ( \"error\" , ( \"You cannot UNpublish this query because\" \"it has been published more than \" f \" { PUBLISH_FREEZE_MSG } ago\" ), ) ) break good = True if good : if fname == \"is_shared\" : ( modDateFld , modDate ) = self . putShared ( myId , query_id , valsql , msgs ) else : ( modDateFld , modDate ) = self . putPublished ( myId , vr , query_id , valsql , msgs ) modDates [ modDateFld ] = modDate return ( good , modDates , modCls , extra )","title":"putSharing()"},{"location":"server/bymodule/querysave/#querysave.QUERYSAVE.putShared","text":"Source code in modules/querysave.py def putShared ( self , myId , query_id , valsql , msgs ): Caching = current . Caching QueryChapter = self . QueryChapter db = current . db VERSIONS = current . VERSIONS modDate = None modDateFld = \"shared_on\" table = \"query\" fname = \"is_shared\" Caching . clear ( r \"^items_q_\" ) fieldval = f \" { fname } = ' { valsql } '\" now = current . request . utcnow modDate = now . replace ( microsecond = 0 ) if valsql == \"T\" else None modDateSql = \"null\" if modDate is None else f \" ' { modDate } '\" fieldval += f \", { modDateFld } = { modDateSql } \" sql = dedent ( f \"\"\" update { table } set { fieldval } where id = { query_id } ; \"\"\" ) db . executesql ( sql ) db . commit () for vr in VERSIONS : QueryChapter . updateQCindex ( vr , query_id ) thismsg = \"modified\" thismsg = \"shared\" if valsql == \"T\" else \"UNshared\" msgs . append (( \"good\" , thismsg )) return ( modDateFld , str ( modDate ) if modDate else NULLDT )","title":"putShared()"},{"location":"server/bymodule/querysave/#querysave.QUERYSAVE.putPublished","text":"Source code in modules/querysave.py def putPublished ( self , myId , vr , query_id , valsql , msgs ): Caching = current . Caching QueryChapter = self . QueryChapter db = current . db modDate = None modDateFld = \"published_on\" table = \"query_exe\" fname = \"is_published\" Caching . clear ( f \"^items_q_ { vr } _\" ) self . verifyVersion ( vr , query_id ) fieldval = f \" { fname } = ' { valsql } '\" now = current . request . utcnow modDate = now . replace ( microsecond = 0 ) if valsql == \"T\" else None modDateSql = \"null\" if modDate is None else f \" ' { modDate } '\" fieldval += f \", { modDateFld } = { modDateSql } \" sql = dedent ( f \"\"\" update { table } set { fieldval } where query_id = { query_id } and version = ' { vr } ' ; \"\"\" ) db . executesql ( sql ) db . commit () thismsg = \"modified\" thismsg = \"published\" if valsql == \"T\" else \"UNpublished\" QueryChapter . updatePubStatus ( vr , query_id , valsql == \"T\" ) msgs . append (( \"good\" , thismsg )) return ( modDateFld , str ( modDate ) if modDate else NULLDT )","title":"putPublished()"},{"location":"server/bymodule/querysave/#querysave.QUERYSAVE.putMeta","text":"Source code in modules/querysave.py def putMeta ( self , vr , query_id , fields , fieldsExe ): Caching = current . Caching db = current . db doCommit = False if len ( fields ): fieldRep = \", \" . join ( f \" { f } = ' { fields [ f ] } '\" for f in fields if f != \"status\" ) sql = dedent ( f \"\"\" update query set { fieldRep } where id = { query_id } ; \"\"\" ) db . executesql ( sql ) doCommit = True Caching . clear ( r \"^items_q_\" ) if len ( fieldsExe ): fieldRep = \", \" . join ( f \" { f } = ' { fieldsExe [ f ] } '\" for f in fieldsExe if f != \"status\" ) sql = dedent ( f \"\"\" update query_exe set { fieldRep } where query_id = { query_id } and version = ' { vr } ' ; \"\"\" ) db . executesql ( sql ) doCommit = True Caching . clear ( f \"^items_q_ { vr } _\" ) if doCommit : db . commit ()","title":"putMeta()"},{"location":"server/bymodule/querysave/#querysave.QUERYSAVE.putRecord","text":"Receives updated record data of a query and stores it in the database. Source code in modules/querysave.py def putRecord ( self ): \"\"\"Receives updated record data of a query and stores it in the database. \"\"\" Check = current . Check Query = self . Query auth = current . auth requestVars = current . request . vars vr = requestVars . version nameNew = requestVars . name mqlNew = requestVars . mql descriptionNew = requestVars . description execute = requestVars . execute myId = auth . user . id if auth . user is not None else None now = current . request . utcnow msgs = [] good = False fields = {} fieldsExe = {} queryRecord = {} is_published = False for x in [ 1 ]: query_id = Check . isId ( \"query_id\" , \"q\" , \"query\" , msgs ) if query_id is None : break ( authorized , msg ) = Query . authWrite ( query_id ) if not authorized : msgs . append (( \"error\" , msg )) break self . verifyVersion ( vr , query_id ) recordOld = Query . getBasicInfo ( vr , query_id ) if recordOld is None or len ( recordOld ) == 0 : msgs . append (( \"error\" , f \"No query with id { query_id } \" )) break valsOld = recordOld [ 0 ] is_published = valsOld [ \"is_published\" ] == \"T\" if not is_published : if valsOld [ \"name\" ] != nameNew : valSql = Check . isName ( \"q\" , query_id , myId , nameNew , msgs ) if valSql is None : break fields [ \"name\" ] = valSql fields [ \"modified_on\" ] = now if valsOld [ \"mql\" ] != mqlNew : msgs . append (( \"warning\" , \"query body modified\" )) valSql = Check . isMql ( \"q\" , mqlNew , msgs ) if valSql is None : break fieldsExe [ \"mql\" ] = valSql fieldsExe [ \"modified_on\" ] = now else : msgs . append (( \"good\" , \"same query body\" )) else : msgs . append ( ( \"warning\" , ( \"only the description can been saved\" \"because this is a published query execution\" ), ) ) if valsOld [ \"description\" ] != descriptionNew : valSql = Check . isDescription ( \"q\" , descriptionNew , msgs ) if valSql is None : break fields [ \"description\" ] = valSql fields [ \"modified_on\" ] = now good = True if good : execute = not is_published and execute exeGood = True if execute == \"true\" : ( exeGood , limitExceeded , nResults , exeSlots , theseMsgs , emdrosVersion , ) = mql ( vr , mqlNew ) if exeGood and not limitExceeded : self . putSlots ( vr , query_id , exeSlots ) fieldsExe [ \"executed_on\" ] = now fieldsExe [ \"eversion\" ] = emdrosVersion nResultSlots = countSlots ( exeSlots ) fieldsExe [ \"results\" ] = nResults fieldsExe [ \"resultmonads\" ] = nResultSlots msgs . append (( \"good\" , \"Query executed\" )) else : self . putSlots ( vr , query_id , []) msgs . extend ( theseMsgs ) self . putMeta ( vr , query_id , fields , fieldsExe ) queryRecord = Query . getInfo ( auth . user is not None , query_id , vr , msgs , withIds = False , singleVersion = False , po = True , ) emdrosVersionsOld = dict (( x , 1 ) for x in EMDROS_VERSIONS [ 0 : - 1 ]) return dict ( data = json . dumps ( dict ( msgs = msgs , good = good and exeGood , query = queryRecord , emdrosVersionsOld = emdrosVersionsOld , ) ) )","title":"putRecord()"},{"location":"server/bymodule/querysave/#querysave.QUERYSAVE.verifyVersion","text":"Source code in modules/querysave.py def verifyVersion ( self , vr , query_id ): db = current . db existVersion = db . executesql ( dedent ( f \"\"\" select id from query_exe where version = ' { vr } ' and query_id = { query_id } ; \"\"\" ) ) if existVersion is None or len ( existVersion ) == 0 : db . executesql ( dedent ( f \"\"\" insert into query_exe (id, version, query_id) values (null, ' { vr } ', { query_id } ) ; \"\"\" ) ) db . commit ()","title":"verifyVersion()"},{"location":"server/bymodule/querytree/","text":"querytree \u00b6 QUERYTREE \u00b6 __init__ ( self ) special \u00b6 Source code in modules/querytree.py def __init__ ( self ): pass get ( self ) \u00b6 Get the metadata of all queries and deliver it as json. Source code in modules/querytree.py def get ( self ): \"\"\"Get the metadata of all queries and deliver it as json. \"\"\" auth = current . auth db = current . db VERSION_ORDER = current . VERSION_ORDER VERSION_INDEX = current . VERSION_INDEX myId = None if auth . user : myId = auth . user . id objInfo = collections . defaultdict ( lambda : {}) def titleBadge ( obj_id , objType , publ , good , num , tot ): name = objInfo [ objType ][ obj_id ] if objType is not None else \"Shared Queries\" nums = [] if publ != 0 : nums . append ( f '<span class=\"special fa fa-quote-right\"> { publ } </span>' ) if good != 0 : nums . append ( f '<span class=\"good fa fa-gears\"> { good } </span>' ) badge = \"\" if len ( nums ) == 0 : if tot == num : badge = f '<span class=\"total\"> { tot } </span>' else : badge = f ' { num } of <span class=\"total\"> { tot } </span>' else : nRep = \", \" . join ( nums ) if tot == num : badge = f ' { nRep } of <span class=\"total\"> { tot } </span>' else : badge = f ' { nRep } of { num } of all <span class=\"total\"> { tot } </span>' rename = \"\" select = \"\" if objType in { \"o\" , \"p\" }: if myId is not None : if obj_id : rename = ( f '<a class=\"r_ { objType } \" obj_id=\" { obj_id } \" href=\"#\"></a>' ) select = dedent ( f \"\"\"<a class=\"s_ { objType } fa fa-lg\" obj_id=\" { obj_id } \" href=\"#\"></a>\"\"\" ) else : if obj_id : rename = ( f '<a class=\"v_ { objType } \" obj_id=\" { obj_id } \" href=\"#\"></a>' ) return dedent ( f \"\"\" { select } <span n=\"1\"> { hEsc ( name ) } </span><span class=\"brq\">( { badge } )</span> { rename } \"\"\" ) condition = ( dedent ( \"\"\" where query.is_shared = 'T' \"\"\" ) if myId is None else dedent ( f \"\"\" where query.is_shared = 'T' or query.created_by = { myId } \"\"\" ) ) projectQueryXSql = dedent ( f \"\"\" select query_exe.query_id, query_exe.version, query_exe.is_published, query_exe.published_on, query_exe.modified_on, query_exe.executed_on from query_exe inner join query on query.id = query_exe.query_id { condition } ; \"\"\" ) projectQuerySql = dedent ( f \"\"\" select query.id as query_id, organization.name as org_name, organization.id as org_id, project.name as project_name, project.id as project_id, concat(auth_user.first_name, ' ', auth_user.last_name) as uname, auth_user.id as user_id, query.name as query_name, query.is_shared as is_shared from query inner join auth_user on query.created_by = auth_user.id inner join project on query.project = project.id inner join organization on query.organization = organization.id { condition } order by organization.name, project.name, auth_user.last_name, auth_user.first_name, query.name ; \"\"\" ) projectQuery = db . executesql ( projectQuerySql ) projectQueryX = db . executesql ( projectQueryXSql ) projectQueries = collections . OrderedDict () for ( query_id , orgName , org_id , projectName , project_id , userName , user_id , queryName , queryShared , ) in projectQuery : qSharedStatus = queryShared == \"T\" qOwnStatus = user_id == myId projectQueries [ query_id ] = { \"\" : ( orgName , org_id , projectName , project_id , userName , user_id , queryName , qSharedStatus , qOwnStatus , ), \"publ\" : False , \"good\" : False , \"v\" : [ 4 for v in VERSION_ORDER ], } now = current . request . utcnow for ( query_id , vr , queryIs_published , queryPublished_on , queryMod_on , queryExe_on , ) in projectQueryX : queryInfo = projectQueries [ query_id ] queryExeStatus = None if queryExe_on : queryExeStatus = queryExe_on >= queryMod_on queryPubStatus = ( False if queryIs_published != \"T\" else None if queryPublished_on > now - PUBLISH_FREEZE else True ) queryStatus = ( 1 if queryPubStatus else 2 if queryPubStatus is None else 3 if queryExeStatus else 4 if queryExeStatus is None else 5 ) queryInfo [ \"v\" ][ VERSION_INDEX [ vr ]] = queryStatus if queryPubStatus or queryPubStatus is None : queryInfo [ \"publ\" ] = True if queryExeStatus : queryInfo [ \"good\" ] = True projectOrgSql = dedent ( \"\"\" select name, id from organization order by name ; \"\"\" ) porg = db . executesql ( projectOrgSql ) projectSql = dedent ( \"\"\" select name, id from project order by name ; \"\"\" ) project = db . executesql ( projectSql ) tree = collections . OrderedDict () countSet = collections . defaultdict ( lambda : set ()) countOrg = collections . defaultdict ( lambda : 0 ) countOrgPub = collections . defaultdict ( lambda : 0 ) countOrgGood = collections . defaultdict ( lambda : 0 ) countOrgTotal = collections . defaultdict ( lambda : 0 ) countProject = collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 ) ) countProjectPub = collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 ) ) countProjectGood = collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 ) ) countProjectTotal = collections . defaultdict ( lambda : 0 ) countUser = collections . defaultdict ( lambda : collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 )) ) countUserPub = collections . defaultdict ( lambda : collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 )) ) countUserGood = collections . defaultdict ( lambda : collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 )) ) countUserTotal = collections . defaultdict ( lambda : 0 ) count = 0 countPub = 0 countGood = 0 for query_id in projectQueries : projectQueryInfo = projectQueries [ query_id ] ( orgName , org_id , projectName , project_id , userName , user_id , queryName , queryShared , queryOwn , ) = projectQueryInfo [ \"\" ] queryPub = projectQueryInfo [ \"publ\" ] queryGood = projectQueryInfo [ \"good\" ] countSet [ \"o\" ] . add ( org_id ) countSet [ \"p\" ] . add ( project_id ) countSet [ \"u\" ] . add ( user_id ) countSet [ \"q\" ] . add ( query_id ) objInfo [ \"o\" ][ org_id ] = orgName objInfo [ \"p\" ][ project_id ] = projectName objInfo [ \"u\" ][ user_id ] = userName if queryOwn : countSet [ \"m\" ] . add ( query_id ) if not queryShared : countSet [ \"r\" ] . add ( query_id ) if queryPub : countUserPub [ org_id ][ project_id ][ user_id ] += 1 countProjectPub [ org_id ][ project_id ] += 1 countOrgPub [ org_id ] += 1 countPub += 1 if queryGood : countUserGood [ org_id ][ project_id ][ user_id ] += 1 countProjectGood [ org_id ][ project_id ] += 1 countOrgGood [ org_id ] += 1 countGood += 1 tree . setdefault ( org_id , collections . OrderedDict ()) . setdefault ( project_id , collections . OrderedDict () ) . setdefault ( user_id , []) . append ( query_id ) count += 1 countOrg [ org_id ] += 1 countProject [ org_id ][ project_id ] += 1 countUser [ org_id ][ project_id ][ user_id ] += 1 countOrgTotal [ org_id ] += 1 countProjectTotal [ project_id ] += 1 countUserTotal [ user_id ] += 1 objInfo [ \"o\" ][ 0 ] = \"Projects without Queries\" objInfo [ \"p\" ][ 0 ] = \"New Project\" objInfo [ \"u\" ][ 0 ] = \"\" objInfo [ \"q\" ] = projectQueries countOrg [ 0 ] = 0 countProject [ 0 ][ 0 ] = 0 for ( orgName , org_id ) in porg : if org_id in objInfo [ \"o\" ]: continue countSet [ \"o\" ] . add ( org_id ) objInfo [ \"o\" ][ org_id ] = orgName tree [ org_id ] = collections . OrderedDict () for ( projectName , project_id ) in project : if project_id in objInfo [ \"p\" ]: continue countSet [ \"o\" ] . add ( 0 ) countSet [ \"p\" ] . add ( project_id ) objInfo [ \"p\" ][ project_id ] = projectName tree . setdefault ( 0 , collections . OrderedDict ())[ project_id ] = collections . OrderedDict () categoryCount = dict (( x [ 0 ], len ( x [ 1 ])) for x in countSet . items ()) categoryCount [ \"user_id\" ] = myId title = titleBadge ( None , None , countPub , countGood , count , count ) dest = [ dict ( title = str ( title ), folder = True , children = [], data = categoryCount )] curDest = dest [ - 1 ][ \"children\" ] curSource = tree for org_id in curSource : orgN = countOrg [ org_id ] orgPub = countOrgPub [ org_id ] orgGood = countOrgGood [ org_id ] orgTot = countOrgTotal [ org_id ] orgTitle = titleBadge ( org_id , \"o\" , orgPub , orgGood , orgN , orgTot ) curDest . append ( dict ( title = str ( orgTitle ), folder = True , children = [])) curOrgDest = curDest [ - 1 ][ \"children\" ] curOrgSource = curSource [ org_id ] for project_id in curOrgSource : projectN = countProject [ org_id ][ project_id ] projectPub = countProjectPub [ org_id ][ project_id ] projectPub = countProjectGood [ org_id ][ project_id ] projectTot = countProjectTotal [ project_id ] projectTitle = titleBadge ( project_id , \"p\" , projectPub , projectPub , projectN , projectTot ) curOrgDest . append ( dict ( title = str ( projectTitle ), folder = True , children = []) ) curProjectDest = curOrgDest [ - 1 ][ \"children\" ] curProjectSource = curOrgSource [ project_id ] for user_id in curProjectSource : userN = countUser [ org_id ][ project_id ][ user_id ] userPub = countUserPub [ org_id ][ project_id ][ user_id ] userGood = countUserGood [ org_id ][ project_id ][ user_id ] userTot = countUserTotal [ user_id ] userTitle = titleBadge ( user_id , \"u\" , userPub , userGood , userN , userTot ) curProjectDest . append ( dict ( title = str ( userTitle ), folder = True , children = []) ) curUserDest = curProjectDest [ - 1 ][ \"children\" ] curUserSource = curProjectSource [ user_id ] for query_id in curUserSource : projectQueryInfo = objInfo [ \"q\" ][ query_id ] ( orgName , org_id , projectName , project_id , userName , user_id , queryName , queryShared , queryOwn , ) = projectQueryInfo [ \"\" ] queryPub = projectQueryInfo [ \"publ\" ] queryGood = projectQueryInfo [ \"good\" ] queryVersions = projectQueryInfo [ \"v\" ] queryOwnRep = \"r\" if queryOwn else \"v\" queryMyRep = \"qmy\" if queryOwn else \"\" querySharedRep = \"\" if queryShared else \"qpriv\" queryIdRep = iEncode ( \"q\" , query_id ) rename = dedent ( f \"\"\"<a class=\" { queryOwnRep } _q\" obj_id=\" { queryIdRep } \" href=\"#\"></a>\"\"\" ) versionRep = \" \" . join ( formatVersion ( \"q\" , query_id , v , queryVersions [ VERSION_INDEX [ v ]] ) for v in VERSION_ORDER ) curUserDest . append ( dict ( title = dedent ( f \"\"\" { versionRep } <a class=\"q { queryMyRep } { querySharedRep } \" n=\"1\" query_id=\" { query_id } \" href=\"#\"> { hEsc ( queryName ) } </a> <a class=\"md\" href=\"#\"></a> { rename } \"\"\" ), key = f \"q { query_id } \" , folder = False , ) ) return dict ( data = json . dumps ( dest ))","title":"Querytree"},{"location":"server/bymodule/querytree/#querytree","text":"","title":"querytree"},{"location":"server/bymodule/querytree/#querytree.QUERYTREE","text":"","title":"QUERYTREE"},{"location":"server/bymodule/querytree/#querytree.QUERYTREE.__init__","text":"Source code in modules/querytree.py def __init__ ( self ): pass","title":"__init__()"},{"location":"server/bymodule/querytree/#querytree.QUERYTREE.get","text":"Get the metadata of all queries and deliver it as json. Source code in modules/querytree.py def get ( self ): \"\"\"Get the metadata of all queries and deliver it as json. \"\"\" auth = current . auth db = current . db VERSION_ORDER = current . VERSION_ORDER VERSION_INDEX = current . VERSION_INDEX myId = None if auth . user : myId = auth . user . id objInfo = collections . defaultdict ( lambda : {}) def titleBadge ( obj_id , objType , publ , good , num , tot ): name = objInfo [ objType ][ obj_id ] if objType is not None else \"Shared Queries\" nums = [] if publ != 0 : nums . append ( f '<span class=\"special fa fa-quote-right\"> { publ } </span>' ) if good != 0 : nums . append ( f '<span class=\"good fa fa-gears\"> { good } </span>' ) badge = \"\" if len ( nums ) == 0 : if tot == num : badge = f '<span class=\"total\"> { tot } </span>' else : badge = f ' { num } of <span class=\"total\"> { tot } </span>' else : nRep = \", \" . join ( nums ) if tot == num : badge = f ' { nRep } of <span class=\"total\"> { tot } </span>' else : badge = f ' { nRep } of { num } of all <span class=\"total\"> { tot } </span>' rename = \"\" select = \"\" if objType in { \"o\" , \"p\" }: if myId is not None : if obj_id : rename = ( f '<a class=\"r_ { objType } \" obj_id=\" { obj_id } \" href=\"#\"></a>' ) select = dedent ( f \"\"\"<a class=\"s_ { objType } fa fa-lg\" obj_id=\" { obj_id } \" href=\"#\"></a>\"\"\" ) else : if obj_id : rename = ( f '<a class=\"v_ { objType } \" obj_id=\" { obj_id } \" href=\"#\"></a>' ) return dedent ( f \"\"\" { select } <span n=\"1\"> { hEsc ( name ) } </span><span class=\"brq\">( { badge } )</span> { rename } \"\"\" ) condition = ( dedent ( \"\"\" where query.is_shared = 'T' \"\"\" ) if myId is None else dedent ( f \"\"\" where query.is_shared = 'T' or query.created_by = { myId } \"\"\" ) ) projectQueryXSql = dedent ( f \"\"\" select query_exe.query_id, query_exe.version, query_exe.is_published, query_exe.published_on, query_exe.modified_on, query_exe.executed_on from query_exe inner join query on query.id = query_exe.query_id { condition } ; \"\"\" ) projectQuerySql = dedent ( f \"\"\" select query.id as query_id, organization.name as org_name, organization.id as org_id, project.name as project_name, project.id as project_id, concat(auth_user.first_name, ' ', auth_user.last_name) as uname, auth_user.id as user_id, query.name as query_name, query.is_shared as is_shared from query inner join auth_user on query.created_by = auth_user.id inner join project on query.project = project.id inner join organization on query.organization = organization.id { condition } order by organization.name, project.name, auth_user.last_name, auth_user.first_name, query.name ; \"\"\" ) projectQuery = db . executesql ( projectQuerySql ) projectQueryX = db . executesql ( projectQueryXSql ) projectQueries = collections . OrderedDict () for ( query_id , orgName , org_id , projectName , project_id , userName , user_id , queryName , queryShared , ) in projectQuery : qSharedStatus = queryShared == \"T\" qOwnStatus = user_id == myId projectQueries [ query_id ] = { \"\" : ( orgName , org_id , projectName , project_id , userName , user_id , queryName , qSharedStatus , qOwnStatus , ), \"publ\" : False , \"good\" : False , \"v\" : [ 4 for v in VERSION_ORDER ], } now = current . request . utcnow for ( query_id , vr , queryIs_published , queryPublished_on , queryMod_on , queryExe_on , ) in projectQueryX : queryInfo = projectQueries [ query_id ] queryExeStatus = None if queryExe_on : queryExeStatus = queryExe_on >= queryMod_on queryPubStatus = ( False if queryIs_published != \"T\" else None if queryPublished_on > now - PUBLISH_FREEZE else True ) queryStatus = ( 1 if queryPubStatus else 2 if queryPubStatus is None else 3 if queryExeStatus else 4 if queryExeStatus is None else 5 ) queryInfo [ \"v\" ][ VERSION_INDEX [ vr ]] = queryStatus if queryPubStatus or queryPubStatus is None : queryInfo [ \"publ\" ] = True if queryExeStatus : queryInfo [ \"good\" ] = True projectOrgSql = dedent ( \"\"\" select name, id from organization order by name ; \"\"\" ) porg = db . executesql ( projectOrgSql ) projectSql = dedent ( \"\"\" select name, id from project order by name ; \"\"\" ) project = db . executesql ( projectSql ) tree = collections . OrderedDict () countSet = collections . defaultdict ( lambda : set ()) countOrg = collections . defaultdict ( lambda : 0 ) countOrgPub = collections . defaultdict ( lambda : 0 ) countOrgGood = collections . defaultdict ( lambda : 0 ) countOrgTotal = collections . defaultdict ( lambda : 0 ) countProject = collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 ) ) countProjectPub = collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 ) ) countProjectGood = collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 ) ) countProjectTotal = collections . defaultdict ( lambda : 0 ) countUser = collections . defaultdict ( lambda : collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 )) ) countUserPub = collections . defaultdict ( lambda : collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 )) ) countUserGood = collections . defaultdict ( lambda : collections . defaultdict ( lambda : collections . defaultdict ( lambda : 0 )) ) countUserTotal = collections . defaultdict ( lambda : 0 ) count = 0 countPub = 0 countGood = 0 for query_id in projectQueries : projectQueryInfo = projectQueries [ query_id ] ( orgName , org_id , projectName , project_id , userName , user_id , queryName , queryShared , queryOwn , ) = projectQueryInfo [ \"\" ] queryPub = projectQueryInfo [ \"publ\" ] queryGood = projectQueryInfo [ \"good\" ] countSet [ \"o\" ] . add ( org_id ) countSet [ \"p\" ] . add ( project_id ) countSet [ \"u\" ] . add ( user_id ) countSet [ \"q\" ] . add ( query_id ) objInfo [ \"o\" ][ org_id ] = orgName objInfo [ \"p\" ][ project_id ] = projectName objInfo [ \"u\" ][ user_id ] = userName if queryOwn : countSet [ \"m\" ] . add ( query_id ) if not queryShared : countSet [ \"r\" ] . add ( query_id ) if queryPub : countUserPub [ org_id ][ project_id ][ user_id ] += 1 countProjectPub [ org_id ][ project_id ] += 1 countOrgPub [ org_id ] += 1 countPub += 1 if queryGood : countUserGood [ org_id ][ project_id ][ user_id ] += 1 countProjectGood [ org_id ][ project_id ] += 1 countOrgGood [ org_id ] += 1 countGood += 1 tree . setdefault ( org_id , collections . OrderedDict ()) . setdefault ( project_id , collections . OrderedDict () ) . setdefault ( user_id , []) . append ( query_id ) count += 1 countOrg [ org_id ] += 1 countProject [ org_id ][ project_id ] += 1 countUser [ org_id ][ project_id ][ user_id ] += 1 countOrgTotal [ org_id ] += 1 countProjectTotal [ project_id ] += 1 countUserTotal [ user_id ] += 1 objInfo [ \"o\" ][ 0 ] = \"Projects without Queries\" objInfo [ \"p\" ][ 0 ] = \"New Project\" objInfo [ \"u\" ][ 0 ] = \"\" objInfo [ \"q\" ] = projectQueries countOrg [ 0 ] = 0 countProject [ 0 ][ 0 ] = 0 for ( orgName , org_id ) in porg : if org_id in objInfo [ \"o\" ]: continue countSet [ \"o\" ] . add ( org_id ) objInfo [ \"o\" ][ org_id ] = orgName tree [ org_id ] = collections . OrderedDict () for ( projectName , project_id ) in project : if project_id in objInfo [ \"p\" ]: continue countSet [ \"o\" ] . add ( 0 ) countSet [ \"p\" ] . add ( project_id ) objInfo [ \"p\" ][ project_id ] = projectName tree . setdefault ( 0 , collections . OrderedDict ())[ project_id ] = collections . OrderedDict () categoryCount = dict (( x [ 0 ], len ( x [ 1 ])) for x in countSet . items ()) categoryCount [ \"user_id\" ] = myId title = titleBadge ( None , None , countPub , countGood , count , count ) dest = [ dict ( title = str ( title ), folder = True , children = [], data = categoryCount )] curDest = dest [ - 1 ][ \"children\" ] curSource = tree for org_id in curSource : orgN = countOrg [ org_id ] orgPub = countOrgPub [ org_id ] orgGood = countOrgGood [ org_id ] orgTot = countOrgTotal [ org_id ] orgTitle = titleBadge ( org_id , \"o\" , orgPub , orgGood , orgN , orgTot ) curDest . append ( dict ( title = str ( orgTitle ), folder = True , children = [])) curOrgDest = curDest [ - 1 ][ \"children\" ] curOrgSource = curSource [ org_id ] for project_id in curOrgSource : projectN = countProject [ org_id ][ project_id ] projectPub = countProjectPub [ org_id ][ project_id ] projectPub = countProjectGood [ org_id ][ project_id ] projectTot = countProjectTotal [ project_id ] projectTitle = titleBadge ( project_id , \"p\" , projectPub , projectPub , projectN , projectTot ) curOrgDest . append ( dict ( title = str ( projectTitle ), folder = True , children = []) ) curProjectDest = curOrgDest [ - 1 ][ \"children\" ] curProjectSource = curOrgSource [ project_id ] for user_id in curProjectSource : userN = countUser [ org_id ][ project_id ][ user_id ] userPub = countUserPub [ org_id ][ project_id ][ user_id ] userGood = countUserGood [ org_id ][ project_id ][ user_id ] userTot = countUserTotal [ user_id ] userTitle = titleBadge ( user_id , \"u\" , userPub , userGood , userN , userTot ) curProjectDest . append ( dict ( title = str ( userTitle ), folder = True , children = []) ) curUserDest = curProjectDest [ - 1 ][ \"children\" ] curUserSource = curProjectSource [ user_id ] for query_id in curUserSource : projectQueryInfo = objInfo [ \"q\" ][ query_id ] ( orgName , org_id , projectName , project_id , userName , user_id , queryName , queryShared , queryOwn , ) = projectQueryInfo [ \"\" ] queryPub = projectQueryInfo [ \"publ\" ] queryGood = projectQueryInfo [ \"good\" ] queryVersions = projectQueryInfo [ \"v\" ] queryOwnRep = \"r\" if queryOwn else \"v\" queryMyRep = \"qmy\" if queryOwn else \"\" querySharedRep = \"\" if queryShared else \"qpriv\" queryIdRep = iEncode ( \"q\" , query_id ) rename = dedent ( f \"\"\"<a class=\" { queryOwnRep } _q\" obj_id=\" { queryIdRep } \" href=\"#\"></a>\"\"\" ) versionRep = \" \" . join ( formatVersion ( \"q\" , query_id , v , queryVersions [ VERSION_INDEX [ v ]] ) for v in VERSION_ORDER ) curUserDest . append ( dict ( title = dedent ( f \"\"\" { versionRep } <a class=\"q { queryMyRep } { querySharedRep } \" n=\"1\" query_id=\" { query_id } \" href=\"#\"> { hEsc ( queryName ) } </a> <a class=\"md\" href=\"#\"></a> { rename } \"\"\" ), key = f \"q { query_id } \" , folder = False , ) ) return dict ( data = json . dumps ( dest ))","title":"get()"},{"location":"server/bymodule/record/","text":"record \u00b6 RECORD \u00b6 Handles record data. This is about some aspects of query and note records and organization and project records by which they are organized. And it is about word records. It is called by controllers that fetch sidebar material, see M:RECORD.body . __init__ ( self ) special \u00b6 Source code in modules/record.py def __init__ ( self ): pass authWriteGeneric ( self , label ) \u00b6 Source code in modules/record.py def authWriteGeneric ( self , label ): auth = current . auth authorized = auth . user is not None errorMessage = f \"You have no access to create/modify a { label } \" return ( authorized , \"\" if authorized else errorMessage ) authReadGeneric ( self , label ) \u00b6 Source code in modules/record.py def authReadGeneric ( self , label ): authorized = True errorMessage = \"\" return ( authorized , errorMessage ) authRead ( self , mr , qw , iidRep ) \u00b6 Source code in modules/record.py def authRead ( self , mr , qw , iidRep ): if mr == \"m\" : return ( True , \"\" ) if qw == \"w\" : return ( True , \"\" ) if qw == \"n\" : if not iidRep : return ( False , f \"Not a valid note id: { iidRep } \" ) return ( True , \"\" ) if qw == \"q\" : if iidRep is not None : ( iid , keywords ) = iDecode ( qw , iidRep ) if iid > 0 : Query = self . Query return Query . authRead ( iid ) return ( False , f \"Not a valid query id: { iidRep } \" ) return ( None , f \"Not a valid id: { iidRep } \" ) body ( self ) \u00b6 Produce data that will get sidebar material later via AJAX. Web2py device We use a web2py device here that shields the mechanics of an AJAX call. That leads to code that is not very clear. These calls are hidden in Web2Py javascript, and you will not find them in the SHEBANQ client app code. This is where the controllers C:hebrew.sidewordbody , C:hebrew.sidequerybody and C:hebrew.sidenotebody will be used. These calls are used when the user requests a record page directly. The web2py device takes care that when the sidebar is editable, the edits will be submitted via AJAX. So far so good. However, when a user navigates between material pages and record pages, the pages are not served from scratch, and new sidebar material has to be fetched through AJAX as well. In the SHEBANQ code we do these AJAX calls explicitly client code: {sidecontent.fetch} . Since I was not able to use the Web2py approach for this part of the use case, it is probably a good idea ditch this usage of the web2py mechanism altogehter in favour fo the more explicit way, which is already in our code. Now we have two ways of doing the same thing! My apologies. Source code in modules/record.py def body ( self ): \"\"\"Produce data that will get sidebar material later via AJAX. !!! caution \"Web2py device\" We use a [web2py device]({{web2pyComponents}}) here that shields the mechanics of an AJAX call. That leads to code that is not very clear. These calls are hidden in Web2Py javascript, and you will not find them in the SHEBANQ client app code. This is where the controllers [C:hebrew.sidewordbody][controllers.hebrew.sidewordbody], [C:hebrew.sidequerybody][controllers.hebrew.sidequerybody] and [C:hebrew.sidenotebody][controllers.hebrew.sidenotebody] will be used. These calls are used when the user requests a **record** page directly. The web2py device takes care that when the sidebar is editable, the edits will be submitted via AJAX. So far so good. However, when a user navigates between **material** pages and **record** pages, the pages are not served from scratch, and new sidebar material has to be fetched through AJAX as well. In the SHEBANQ code we do these AJAX calls explicitly client code: [{sidecontent.fetch}][sidecontentfetch]. Since I was not able to use the Web2py approach for this part of the use case, it is probably a good idea ditch this usage of the web2py mechanism altogehter in favour fo the more explicit way, which is already in our code. Now we have two ways of doing the same thing! My apologies. \"\"\" # noqa E501 Check = current . Check LOAD = current . LOAD iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) vr = Check . field ( \"material\" , \"\" , \"version\" ) mr = Check . field ( \"material\" , \"\" , \"mr\" ) qw = Check . field ( \"material\" , \"\" , \"qw\" ) kind = \"word\" if qw == \"w\" else \"query\" if qw == \"q\" else \"note\" ( authorized , msg ) = self . authRead ( mr , qw , iidRep ) if authorized : msg = f \"fetching { kind } \" return dict ( load = LOAD ( \"hebrew\" , f \"side { kind } body\" , extension = \"load\" , vars = dict ( mr = \"r\" , qw = \"w\" , version = vr , iid = iidRep ), ajax = False , ajax_trap = True , target = f \" { kind } body\" , content = msg , ) ) setItem ( self ) \u00b6 Saves a record to the database. Meant for: objects that organize the notes and query overviews: organizations and projects. Can also save query records. Note records and word records Word records are readonly and will nver be saved. There are no such things as note records. Notes are organized in sets bases on keywords and authoring users, but a notes set does not have an embodiment as record in the database. Source code in modules/record.py def setItem ( self ): \"\"\"Saves a record to the database. Meant for: objects that organize the notes and query overviews: organizations and projects. Can also save query records. !!! hint \"Note records and word records\" Word records are readonly and will nver be saved. There are no such things as note records. Notes are organized in sets bases on keywords and authoring users, but a notes set does not have an embodiment as record in the database. \"\"\" Check = current . Check auth = current . auth msgs = [] orgRecord = {} projectRecord = {} good = False orgGood = False projectGood = False obj_id = None label = None table = None fields = None myId = auth . user . id if auth . user is not None else None requestVars = current . request . vars for x in [ 1 ]: tp = requestVars . tp if tp not in TPS : msgs . append (( \"error\" , f \"unknown type { tp } !\" )) break ( label , table ) = TPS [ tp ] obj_id = Check . isId ( \"obj_id\" , tp , label , msgs ) upd = requestVars . upd if obj_id is None : break if upd not in { \"true\" , \"false\" }: msgs . append (( \"error\" , f \"invalid instruction { upd } !\" )) break upd = True if upd == \"true\" else False if upd and not myId : msgs . append (( \"error\" , \"for updating you have to be logged in!\" )) break fields = [ \"name\" ] if tp == \"q\" : Query = self . Query fields . append ( \"organization\" ) fields . append ( \"project\" ) else : fields . append ( \"website\" ) if upd : ( authorized , msg ) = ( Query . authWrite ( obj_id ) if tp == \"q\" else self . authWriteGeneric ( label ) ) else : ( authorized , msg ) = ( Query . authRead ( obj_id ) if tp == \"q\" else self . authReadGeneric ( label ) ) if not authorized : msgs . append (( \"error\" , msg )) break if upd : if tp == \"q\" : subfields = [ \"name\" , \"website\" ] fieldValues = [ requestVars . name ] doNewOrg = requestVars . doNewOrg doNewProject = requestVars . doNewProject if doNewOrg not in { \"true\" , \"false\" }: msgs . append ( ( \"error\" , f \"invalid instruction for organization { doNewOrg } !\" , ) ) break doNewOrg = doNewOrg == \"true\" if doNewProject not in { \"true\" , \"false\" }: msgs . append ( ( \"error\" , f \"invalid instruction for project { doNewProject } !\" , ) ) break doNewProject = doNewProject == \"true\" orgGood = True if doNewOrg : ( orgGood , org_id ) = self . update ( \"o\" , 0 , myId , subfields , [ requestVars . org_name , requestVars . org_website ], msgs , ) if orgGood : orgRecord = dict ( id = org_id , name = requestVars . org_name , website = requestVars . org_website , ) else : org_id = Check . isId ( \"org_id\" , \"o\" , TPS [ \"o\" ][ 0 ], msgs ) projectGood = True if doNewProject : ( projectGood , project_id ) = self . update ( \"p\" , 0 , myId , subfields , [ requestVars . project_name , requestVars . project_website ], msgs , ) if projectGood : projectRecord = dict ( id = project_id , name = requestVars . project_name , website = requestVars . project_website , ) else : project_id = Check . isId ( \"project_id\" , \"p\" , TPS [ \"o\" ][ 0 ], msgs ) if not orgGood or not projectGood : break if org_id is None or project_id is None : break fieldValues . extend ([ org_id , project_id ]) else : fieldValues = [ requestVars [ field ] for field in fields ] ( good , obj_idNew ) = self . update ( tp , obj_id , myId , fields , fieldValues , msgs ) if not good : break obj_id = obj_idNew else : good = True record = self . make ( tp , label , table , fields , obj_id , good , msgs ) return dict ( data = json . dumps ( dict ( record = record , orgRecord = orgRecord , projectRecord = projectRecord , msgs = msgs , good = good , orgGood = orgGood , projectGood = projectGood , ) ) ) make ( self , tp , label , table , fields , obj_id , good , msgs ) \u00b6 Source code in modules/record.py def make ( self , tp , label , table , fields , obj_id , good , msgs ): db = current . db record = {} if good : dbRecord = None if tp == \"q\" : if obj_id == 0 : dbRecord = [ 0 , \"\" , 0 , \"\" , \"\" , 0 , \"\" , \"\" ] else : Query = self . Query dbRecord = Query . getTreeInfo ( obj_id ) else : if obj_id == 0 : dbRecord = [ 0 , \"\" , \"\" ] else : dbRecord = db . executesql ( dedent ( f \"\"\" select { \",\" . join ( fields ) } from { table } where id = { obj_id } ; \"\"\" ), as_dict = True , ) if dbRecord : record = dbRecord [ 0 ] else : msgs . append (( \"error\" , f \"No { label } with id { obj_id } \" )) return record update ( self , tp , obj_id , myId , fields , fieldValues , msgs ) \u00b6 Source code in modules/record.py def update ( self , tp , obj_id , myId , fields , fieldValues , msgs ): Check = current . Check db = current . db fieldsUpd = {} good = False ( label , table ) = TPS [ tp ] useValues = {} for i in range ( len ( fields )): field = fields [ i ] value = fieldValues [ i ] useValues [ field ] = value now = current . request . utcnow for x in [ 1 ]: valSql = Check . isName ( tp , obj_id , myId , useValues [ \"name\" ], msgs , ) if valSql is None : break fieldsUpd [ \"name\" ] = valSql if tp == \"q\" : val = Check . isId ( \"org_id\" , \"o\" , TPS [ \"o\" ][ 0 ], msgs , valrep = str ( useValues [ \"organization\" ]), ) if val is None : break valSql = Check . isRel ( \"o\" , val , msgs ) if valSql is None : break fieldsUpd [ \"organization\" ] = valSql val = Check . isId ( \"project_id\" , \"p\" , TPS [ \"p\" ][ 0 ], msgs , valrep = str ( useValues [ \"project\" ]), ) valSql = Check . isRel ( \"p\" , val , msgs ) if valSql is None : break fieldsUpd [ \"project\" ] = valSql fld = \"modified_on\" fieldsUpd [ fld ] = now fields . append ( fld ) if obj_id == 0 : fld = \"created_on\" fieldsUpd [ fld ] = now fields . append ( fld ) fld = \"created_by\" fieldsUpd [ fld ] = myId fields . append ( fld ) else : valSql = Check . isWebsite ( tp , useValues [ \"website\" ], msgs ) if valSql is None : break fieldsUpd [ \"website\" ] = valSql good = True if good : if obj_id : fieldVals = [ f \" { f } = ' { fieldsUpd [ f ] } '\" for f in fields ] sql = dedent ( f \"\"\" update { table } set { \",\" . join ( fieldVals ) } where id = { obj_id } ; \"\"\" ) thisMsg = \"updated\" else : fieldVals = [ f \"' { fieldsUpd [ f ] } '\" for f in fields ] sql = dedent ( f \"\"\" insert into { table } ( { \",\" . join ( fields ) } ) values ( { \",\" . join ( fieldVals ) } ) ; \"\"\" ) thisMsg = f \" { label } added\" db . executesql ( sql ) db . commit () if obj_id == 0 : obj_id = db . executesql ( dedent ( \"\"\" select last_insert_id() as x ; \"\"\" ) )[ 0 ][ 0 ] msgs . append (( \"good\" , thisMsg )) return ( good , obj_id ) RECORDQUERY ( RECORD ) \u00b6 __init__ ( self , Query ) special \u00b6 Source code in modules/record.py def __init__ ( self , Query ): super () . __init__ () self . Query = Query","title":"Record"},{"location":"server/bymodule/record/#record","text":"","title":"record"},{"location":"server/bymodule/record/#record.RECORD","text":"Handles record data. This is about some aspects of query and note records and organization and project records by which they are organized. And it is about word records. It is called by controllers that fetch sidebar material, see M:RECORD.body .","title":"RECORD"},{"location":"server/bymodule/record/#record.RECORD.__init__","text":"Source code in modules/record.py def __init__ ( self ): pass","title":"__init__()"},{"location":"server/bymodule/record/#record.RECORD.authWriteGeneric","text":"Source code in modules/record.py def authWriteGeneric ( self , label ): auth = current . auth authorized = auth . user is not None errorMessage = f \"You have no access to create/modify a { label } \" return ( authorized , \"\" if authorized else errorMessage )","title":"authWriteGeneric()"},{"location":"server/bymodule/record/#record.RECORD.authReadGeneric","text":"Source code in modules/record.py def authReadGeneric ( self , label ): authorized = True errorMessage = \"\" return ( authorized , errorMessage )","title":"authReadGeneric()"},{"location":"server/bymodule/record/#record.RECORD.authRead","text":"Source code in modules/record.py def authRead ( self , mr , qw , iidRep ): if mr == \"m\" : return ( True , \"\" ) if qw == \"w\" : return ( True , \"\" ) if qw == \"n\" : if not iidRep : return ( False , f \"Not a valid note id: { iidRep } \" ) return ( True , \"\" ) if qw == \"q\" : if iidRep is not None : ( iid , keywords ) = iDecode ( qw , iidRep ) if iid > 0 : Query = self . Query return Query . authRead ( iid ) return ( False , f \"Not a valid query id: { iidRep } \" ) return ( None , f \"Not a valid id: { iidRep } \" )","title":"authRead()"},{"location":"server/bymodule/record/#record.RECORD.body","text":"Produce data that will get sidebar material later via AJAX. Web2py device We use a web2py device here that shields the mechanics of an AJAX call. That leads to code that is not very clear. These calls are hidden in Web2Py javascript, and you will not find them in the SHEBANQ client app code. This is where the controllers C:hebrew.sidewordbody , C:hebrew.sidequerybody and C:hebrew.sidenotebody will be used. These calls are used when the user requests a record page directly. The web2py device takes care that when the sidebar is editable, the edits will be submitted via AJAX. So far so good. However, when a user navigates between material pages and record pages, the pages are not served from scratch, and new sidebar material has to be fetched through AJAX as well. In the SHEBANQ code we do these AJAX calls explicitly client code: {sidecontent.fetch} . Since I was not able to use the Web2py approach for this part of the use case, it is probably a good idea ditch this usage of the web2py mechanism altogehter in favour fo the more explicit way, which is already in our code. Now we have two ways of doing the same thing! My apologies. Source code in modules/record.py def body ( self ): \"\"\"Produce data that will get sidebar material later via AJAX. !!! caution \"Web2py device\" We use a [web2py device]({{web2pyComponents}}) here that shields the mechanics of an AJAX call. That leads to code that is not very clear. These calls are hidden in Web2Py javascript, and you will not find them in the SHEBANQ client app code. This is where the controllers [C:hebrew.sidewordbody][controllers.hebrew.sidewordbody], [C:hebrew.sidequerybody][controllers.hebrew.sidequerybody] and [C:hebrew.sidenotebody][controllers.hebrew.sidenotebody] will be used. These calls are used when the user requests a **record** page directly. The web2py device takes care that when the sidebar is editable, the edits will be submitted via AJAX. So far so good. However, when a user navigates between **material** pages and **record** pages, the pages are not served from scratch, and new sidebar material has to be fetched through AJAX as well. In the SHEBANQ code we do these AJAX calls explicitly client code: [{sidecontent.fetch}][sidecontentfetch]. Since I was not able to use the Web2py approach for this part of the use case, it is probably a good idea ditch this usage of the web2py mechanism altogehter in favour fo the more explicit way, which is already in our code. Now we have two ways of doing the same thing! My apologies. \"\"\" # noqa E501 Check = current . Check LOAD = current . LOAD iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) vr = Check . field ( \"material\" , \"\" , \"version\" ) mr = Check . field ( \"material\" , \"\" , \"mr\" ) qw = Check . field ( \"material\" , \"\" , \"qw\" ) kind = \"word\" if qw == \"w\" else \"query\" if qw == \"q\" else \"note\" ( authorized , msg ) = self . authRead ( mr , qw , iidRep ) if authorized : msg = f \"fetching { kind } \" return dict ( load = LOAD ( \"hebrew\" , f \"side { kind } body\" , extension = \"load\" , vars = dict ( mr = \"r\" , qw = \"w\" , version = vr , iid = iidRep ), ajax = False , ajax_trap = True , target = f \" { kind } body\" , content = msg , ) )","title":"body()"},{"location":"server/bymodule/record/#record.RECORD.setItem","text":"Saves a record to the database. Meant for: objects that organize the notes and query overviews: organizations and projects. Can also save query records. Note records and word records Word records are readonly and will nver be saved. There are no such things as note records. Notes are organized in sets bases on keywords and authoring users, but a notes set does not have an embodiment as record in the database. Source code in modules/record.py def setItem ( self ): \"\"\"Saves a record to the database. Meant for: objects that organize the notes and query overviews: organizations and projects. Can also save query records. !!! hint \"Note records and word records\" Word records are readonly and will nver be saved. There are no such things as note records. Notes are organized in sets bases on keywords and authoring users, but a notes set does not have an embodiment as record in the database. \"\"\" Check = current . Check auth = current . auth msgs = [] orgRecord = {} projectRecord = {} good = False orgGood = False projectGood = False obj_id = None label = None table = None fields = None myId = auth . user . id if auth . user is not None else None requestVars = current . request . vars for x in [ 1 ]: tp = requestVars . tp if tp not in TPS : msgs . append (( \"error\" , f \"unknown type { tp } !\" )) break ( label , table ) = TPS [ tp ] obj_id = Check . isId ( \"obj_id\" , tp , label , msgs ) upd = requestVars . upd if obj_id is None : break if upd not in { \"true\" , \"false\" }: msgs . append (( \"error\" , f \"invalid instruction { upd } !\" )) break upd = True if upd == \"true\" else False if upd and not myId : msgs . append (( \"error\" , \"for updating you have to be logged in!\" )) break fields = [ \"name\" ] if tp == \"q\" : Query = self . Query fields . append ( \"organization\" ) fields . append ( \"project\" ) else : fields . append ( \"website\" ) if upd : ( authorized , msg ) = ( Query . authWrite ( obj_id ) if tp == \"q\" else self . authWriteGeneric ( label ) ) else : ( authorized , msg ) = ( Query . authRead ( obj_id ) if tp == \"q\" else self . authReadGeneric ( label ) ) if not authorized : msgs . append (( \"error\" , msg )) break if upd : if tp == \"q\" : subfields = [ \"name\" , \"website\" ] fieldValues = [ requestVars . name ] doNewOrg = requestVars . doNewOrg doNewProject = requestVars . doNewProject if doNewOrg not in { \"true\" , \"false\" }: msgs . append ( ( \"error\" , f \"invalid instruction for organization { doNewOrg } !\" , ) ) break doNewOrg = doNewOrg == \"true\" if doNewProject not in { \"true\" , \"false\" }: msgs . append ( ( \"error\" , f \"invalid instruction for project { doNewProject } !\" , ) ) break doNewProject = doNewProject == \"true\" orgGood = True if doNewOrg : ( orgGood , org_id ) = self . update ( \"o\" , 0 , myId , subfields , [ requestVars . org_name , requestVars . org_website ], msgs , ) if orgGood : orgRecord = dict ( id = org_id , name = requestVars . org_name , website = requestVars . org_website , ) else : org_id = Check . isId ( \"org_id\" , \"o\" , TPS [ \"o\" ][ 0 ], msgs ) projectGood = True if doNewProject : ( projectGood , project_id ) = self . update ( \"p\" , 0 , myId , subfields , [ requestVars . project_name , requestVars . project_website ], msgs , ) if projectGood : projectRecord = dict ( id = project_id , name = requestVars . project_name , website = requestVars . project_website , ) else : project_id = Check . isId ( \"project_id\" , \"p\" , TPS [ \"o\" ][ 0 ], msgs ) if not orgGood or not projectGood : break if org_id is None or project_id is None : break fieldValues . extend ([ org_id , project_id ]) else : fieldValues = [ requestVars [ field ] for field in fields ] ( good , obj_idNew ) = self . update ( tp , obj_id , myId , fields , fieldValues , msgs ) if not good : break obj_id = obj_idNew else : good = True record = self . make ( tp , label , table , fields , obj_id , good , msgs ) return dict ( data = json . dumps ( dict ( record = record , orgRecord = orgRecord , projectRecord = projectRecord , msgs = msgs , good = good , orgGood = orgGood , projectGood = projectGood , ) ) )","title":"setItem()"},{"location":"server/bymodule/record/#record.RECORD.make","text":"Source code in modules/record.py def make ( self , tp , label , table , fields , obj_id , good , msgs ): db = current . db record = {} if good : dbRecord = None if tp == \"q\" : if obj_id == 0 : dbRecord = [ 0 , \"\" , 0 , \"\" , \"\" , 0 , \"\" , \"\" ] else : Query = self . Query dbRecord = Query . getTreeInfo ( obj_id ) else : if obj_id == 0 : dbRecord = [ 0 , \"\" , \"\" ] else : dbRecord = db . executesql ( dedent ( f \"\"\" select { \",\" . join ( fields ) } from { table } where id = { obj_id } ; \"\"\" ), as_dict = True , ) if dbRecord : record = dbRecord [ 0 ] else : msgs . append (( \"error\" , f \"No { label } with id { obj_id } \" )) return record","title":"make()"},{"location":"server/bymodule/record/#record.RECORD.update","text":"Source code in modules/record.py def update ( self , tp , obj_id , myId , fields , fieldValues , msgs ): Check = current . Check db = current . db fieldsUpd = {} good = False ( label , table ) = TPS [ tp ] useValues = {} for i in range ( len ( fields )): field = fields [ i ] value = fieldValues [ i ] useValues [ field ] = value now = current . request . utcnow for x in [ 1 ]: valSql = Check . isName ( tp , obj_id , myId , useValues [ \"name\" ], msgs , ) if valSql is None : break fieldsUpd [ \"name\" ] = valSql if tp == \"q\" : val = Check . isId ( \"org_id\" , \"o\" , TPS [ \"o\" ][ 0 ], msgs , valrep = str ( useValues [ \"organization\" ]), ) if val is None : break valSql = Check . isRel ( \"o\" , val , msgs ) if valSql is None : break fieldsUpd [ \"organization\" ] = valSql val = Check . isId ( \"project_id\" , \"p\" , TPS [ \"p\" ][ 0 ], msgs , valrep = str ( useValues [ \"project\" ]), ) valSql = Check . isRel ( \"p\" , val , msgs ) if valSql is None : break fieldsUpd [ \"project\" ] = valSql fld = \"modified_on\" fieldsUpd [ fld ] = now fields . append ( fld ) if obj_id == 0 : fld = \"created_on\" fieldsUpd [ fld ] = now fields . append ( fld ) fld = \"created_by\" fieldsUpd [ fld ] = myId fields . append ( fld ) else : valSql = Check . isWebsite ( tp , useValues [ \"website\" ], msgs ) if valSql is None : break fieldsUpd [ \"website\" ] = valSql good = True if good : if obj_id : fieldVals = [ f \" { f } = ' { fieldsUpd [ f ] } '\" for f in fields ] sql = dedent ( f \"\"\" update { table } set { \",\" . join ( fieldVals ) } where id = { obj_id } ; \"\"\" ) thisMsg = \"updated\" else : fieldVals = [ f \"' { fieldsUpd [ f ] } '\" for f in fields ] sql = dedent ( f \"\"\" insert into { table } ( { \",\" . join ( fields ) } ) values ( { \",\" . join ( fieldVals ) } ) ; \"\"\" ) thisMsg = f \" { label } added\" db . executesql ( sql ) db . commit () if obj_id == 0 : obj_id = db . executesql ( dedent ( \"\"\" select last_insert_id() as x ; \"\"\" ) )[ 0 ][ 0 ] msgs . append (( \"good\" , thisMsg )) return ( good , obj_id )","title":"update()"},{"location":"server/bymodule/record/#record.RECORDQUERY","text":"","title":"RECORDQUERY"},{"location":"server/bymodule/record/#record.RECORDQUERY.__init__","text":"Source code in modules/record.py def __init__ ( self , Query ): super () . __init__ () self . Query = Query","title":"__init__()"},{"location":"server/bymodule/side/","text":"side \u00b6 SIDE \u00b6 __init__ ( self , Material , Word , Query , Note ) special \u00b6 Source code in modules/side.py def __init__ ( self , Material , Word , Query , Note ): self . Material = Material self . Word = Word self . Query = Query self . Note = Note page ( self ) \u00b6 Source code in modules/side.py def page ( self ): Check = current . Check vr = Check . field ( \"material\" , \"\" , \"version\" ) qw = Check . field ( \"material\" , \"\" , \"qw\" ) bk = Check . field ( \"material\" , \"\" , \"book\" ) ch = Check . field ( \"material\" , \"\" , \"chapter\" ) is_published = Check . field ( \"highlights\" , qw , \"pub\" ) if qw != \"w\" else \"\" return self . get ( vr , qw , bk , ch , is_published ) get ( self , vr , qw , bk , ch , is_published ) \u00b6 Source code in modules/side.py def get ( self , vr , qw , bk , ch , is_published ): Caching = current . Caching return Caching . get ( f \"items_ { qw } _ { vr } _ { bk } _ { ch } _ { is_published } _\" , lambda : self . get_c ( vr , qw , bk , ch , is_published ), ONE_HOUR , ) get_c ( self , vr , qw , bk , ch , is_published ) \u00b6 Source code in modules/side.py def get_c ( self , vr , qw , bk , ch , is_published ): ViewDefs = current . ViewDefs Material = self . Material Word = self . Word Query = self . Query Note = self . Note ( book , chapter ) = Material . getPassage ( vr , bk , ch ) if not chapter : result = dict ( colorPicker = ViewDefs . colorPicker , sideItems = [], qw = qw , ) else : if qw == \"q\" : sideItems = Query . getItems ( vr , chapter , is_published == \"v\" ) elif qw == \"w\" : sideItems = Word . getItems ( vr , chapter ) elif qw == \"n\" : sideItems = Note . getItems ( vr , book , chapter , is_published ) else : sideItems = [] result = dict ( colorPicker = ViewDefs . colorPicker , sideItems = sideItems , qw = qw , ) return result","title":"Side"},{"location":"server/bymodule/side/#side","text":"","title":"side"},{"location":"server/bymodule/side/#side.SIDE","text":"","title":"SIDE"},{"location":"server/bymodule/side/#side.SIDE.__init__","text":"Source code in modules/side.py def __init__ ( self , Material , Word , Query , Note ): self . Material = Material self . Word = Word self . Query = Query self . Note = Note","title":"__init__()"},{"location":"server/bymodule/side/#side.SIDE.page","text":"Source code in modules/side.py def page ( self ): Check = current . Check vr = Check . field ( \"material\" , \"\" , \"version\" ) qw = Check . field ( \"material\" , \"\" , \"qw\" ) bk = Check . field ( \"material\" , \"\" , \"book\" ) ch = Check . field ( \"material\" , \"\" , \"chapter\" ) is_published = Check . field ( \"highlights\" , qw , \"pub\" ) if qw != \"w\" else \"\" return self . get ( vr , qw , bk , ch , is_published )","title":"page()"},{"location":"server/bymodule/side/#side.SIDE.get","text":"Source code in modules/side.py def get ( self , vr , qw , bk , ch , is_published ): Caching = current . Caching return Caching . get ( f \"items_ { qw } _ { vr } _ { bk } _ { ch } _ { is_published } _\" , lambda : self . get_c ( vr , qw , bk , ch , is_published ), ONE_HOUR , )","title":"get()"},{"location":"server/bymodule/side/#side.SIDE.get_c","text":"Source code in modules/side.py def get_c ( self , vr , qw , bk , ch , is_published ): ViewDefs = current . ViewDefs Material = self . Material Word = self . Word Query = self . Query Note = self . Note ( book , chapter ) = Material . getPassage ( vr , bk , ch ) if not chapter : result = dict ( colorPicker = ViewDefs . colorPicker , sideItems = [], qw = qw , ) else : if qw == \"q\" : sideItems = Query . getItems ( vr , chapter , is_published == \"v\" ) elif qw == \"w\" : sideItems = Word . getItems ( vr , chapter ) elif qw == \"n\" : sideItems = Note . getItems ( vr , book , chapter , is_published ) else : sideItems = [] result = dict ( colorPicker = ViewDefs . colorPicker , sideItems = sideItems , qw = qw , ) return result","title":"get_c()"},{"location":"server/bymodule/urls/","text":"urls \u00b6 Urls \u00b6 __init__ ( self ) special \u00b6 Source code in modules/urls.py def __init__ ( self ): URL = current . URL imagePat = re . compile ( \"\"\"<a [^>]*href=['\"]image[\\n\\t ]+([^)\\n\\t '\"]+)['\"][^>]*>(.*?)</a>\"\"\" ) def imageRepl ( match ): return f \"\"\"<br/><img src=\" { match . group ( 1 ) } \"/><br/> { match . group ( 2 ) } <br/>\"\"\" versePat = re . compile ( r \"\"\"(<a [^>]*href=['\"])([^)\\n\\t ]+)[\\n\\t ]+([^:)\\n\\t '\"]+)\"\"\" r \"\"\":([^)\\n\\t '\"]+)(['\"][^>]*>.*?</a>)\"\"\" ) def verseRepl ( match ): return ( match . group ( 1 ) + hEsc ( URL ( \"hebrew\" , \"text\" , host = True , vars = dict ( book = match . group ( 2 ), chapter = match . group ( 3 ), verse = match . group ( 4 ), mr = \"m\" , ), ) ) + match . group ( 5 ) ) chapterPat = re . compile ( \"\"\"(<a [^>]*href=['\"])([^)\\n\\t ]+)[\\n\\t ]+\"\"\" \"\"\"([^)\\n\\t '\"]+)(['\"][^>]*>.*?</a>)\"\"\" ) def chapterRepl ( match ): return ( match . group ( 1 ) + hEsc ( URL ( \"hebrew\" , \"text\" , host = True , vars = dict ( book = match . group ( 2 ), chapter = match . group ( 3 ), verse = \"1\" , mr = \"m\" , ), ) ) + match . group ( 4 ) ) shebanqPat = re . compile ( \"\"\"(href=['\"])shebanq:([^) \\n\\t '\"]+['\"])\"\"\" ) def shebanqRepl ( match ): return match . group ( 1 ) + URL ( \"hebrew\" , \"text\" , host = True ) + match . group ( 2 ) featurePat = re . compile ( \"\"\"(href=['\"])feature:([^) \\n\\t '\"]+)(['\"])\"\"\" ) def featureRepl ( match ): return ( f \"\"\" { match . group ( 1 ) }{ URL ( \"static\" , \"docs/features\" , host = True ) } /\"\"\" f \"\"\" { match . group ( 2 ) }{ match . group ( 3 ) } \"\"\" '''target=\"_blank\"''' ) def specialLinks ( md ): md = imagePat . sub ( imageRepl , md ) md = versePat . sub ( verseRepl , md ) md = chapterPat . sub ( chapterRepl , md ) md = shebanqPat . sub ( shebanqRepl , md ) md = featurePat . sub ( featureRepl , md ) return md setattr ( self , \"specialLinks\" , specialLinks )","title":"Urls"},{"location":"server/bymodule/urls/#urls","text":"","title":"urls"},{"location":"server/bymodule/urls/#urls.Urls","text":"","title":"Urls"},{"location":"server/bymodule/urls/#urls.Urls.__init__","text":"Source code in modules/urls.py def __init__ ( self ): URL = current . URL imagePat = re . compile ( \"\"\"<a [^>]*href=['\"]image[\\n\\t ]+([^)\\n\\t '\"]+)['\"][^>]*>(.*?)</a>\"\"\" ) def imageRepl ( match ): return f \"\"\"<br/><img src=\" { match . group ( 1 ) } \"/><br/> { match . group ( 2 ) } <br/>\"\"\" versePat = re . compile ( r \"\"\"(<a [^>]*href=['\"])([^)\\n\\t ]+)[\\n\\t ]+([^:)\\n\\t '\"]+)\"\"\" r \"\"\":([^)\\n\\t '\"]+)(['\"][^>]*>.*?</a>)\"\"\" ) def verseRepl ( match ): return ( match . group ( 1 ) + hEsc ( URL ( \"hebrew\" , \"text\" , host = True , vars = dict ( book = match . group ( 2 ), chapter = match . group ( 3 ), verse = match . group ( 4 ), mr = \"m\" , ), ) ) + match . group ( 5 ) ) chapterPat = re . compile ( \"\"\"(<a [^>]*href=['\"])([^)\\n\\t ]+)[\\n\\t ]+\"\"\" \"\"\"([^)\\n\\t '\"]+)(['\"][^>]*>.*?</a>)\"\"\" ) def chapterRepl ( match ): return ( match . group ( 1 ) + hEsc ( URL ( \"hebrew\" , \"text\" , host = True , vars = dict ( book = match . group ( 2 ), chapter = match . group ( 3 ), verse = \"1\" , mr = \"m\" , ), ) ) + match . group ( 4 ) ) shebanqPat = re . compile ( \"\"\"(href=['\"])shebanq:([^) \\n\\t '\"]+['\"])\"\"\" ) def shebanqRepl ( match ): return match . group ( 1 ) + URL ( \"hebrew\" , \"text\" , host = True ) + match . group ( 2 ) featurePat = re . compile ( \"\"\"(href=['\"])feature:([^) \\n\\t '\"]+)(['\"])\"\"\" ) def featureRepl ( match ): return ( f \"\"\" { match . group ( 1 ) }{ URL ( \"static\" , \"docs/features\" , host = True ) } /\"\"\" f \"\"\" { match . group ( 2 ) }{ match . group ( 3 ) } \"\"\" '''target=\"_blank\"''' ) def specialLinks ( md ): md = imagePat . sub ( imageRepl , md ) md = versePat . sub ( verseRepl , md ) md = chapterPat . sub ( chapterRepl , md ) md = shebanqPat . sub ( shebanqRepl , md ) md = featurePat . sub ( featureRepl , md ) return md setattr ( self , \"specialLinks\" , specialLinks )","title":"__init__()"},{"location":"server/bymodule/verse/","text":"verse \u00b6 VERSE \u00b6 Get verse data of a verse. The verse data are the linguistic feature data for the words in a verse. __init__ ( self ) special \u00b6 Source code in modules/verse.py def __init__ ( self ): pass get ( self ) \u00b6 Get linguistic data of a verse. Source code in modules/verse.py def get ( self ): \"\"\"Get linguistic data of a verse. \"\"\" extension = current . request . extension if extension == \"json\" : return self . getJson () Check = current . Check Caching = current . Caching vr = Check . field ( \"material\" , \"\" , \"version\" ) bk = Check . field ( \"material\" , \"\" , \"book\" ) ch = Check . field ( \"material\" , \"\" , \"chapter\" ) vs = Check . field ( \"material\" , \"\" , \"verse\" ) tr = Check . field ( \"material\" , \"\" , \"tr\" ) if vs is None : return dict ( good = False , msgs = []) return Caching . get ( f \"verse_ { vr } _ { bk } _ { ch } _ { vs } _ { tr } _\" , lambda : self . get_c ( vr , bk , ch , vs , tr ), ONE_HOUR , ) get_c ( self , vr , bk , ch , vs , tr ) \u00b6 Source code in modules/verse.py def get_c ( self , vr , bk , ch , vs , tr ): material = VERSECONTENT ( vr , bk , ch , vs , xml = None , wordData = None , tp = \"txtd\" , tr = tr , mr = None , ) good = True msgs = [] if len ( material . wordData ) == 0 : msgs = [( \"error\" , f \" { bk } { ch } : { vs } does not exist\" )] good = False return dict ( good = good , msgs = msgs , material = material , ) getJson ( self , vr , bk , ch , vs ) \u00b6 Source code in modules/verse.py def getJson ( self , vr , bk , ch , vs ): Caching = current . Caching return Caching . get ( f \"versej_ { vr } _ { bk } _ { ch } _ { vs } _\" , lambda : self . getJson_c ( vr , bk , ch , vs ), ONE_HOUR , ) getJson_c ( self ) \u00b6 Source code in modules/verse.py def getJson_c ( self ): Check = current . Check PASSAGE_DBS = current . PASSAGE_DBS vr = Check . field ( \"material\" , \"\" , \"version\" ) bk = Check . field ( \"material\" , \"\" , \"book\" ) ch = Check . field ( \"material\" , \"\" , \"chapter\" ) vs = Check . field ( \"material\" , \"\" , \"verse\" ) passageDb = PASSAGE_DBS [ vr ] if vr in PASSAGE_DBS else None msgs = [] good = True data = dict () if passageDb is None : msgs . append (( \"Error\" , f \"No such version: { vr } \" )) good = False if good : verseInfo = passageDb . executesql ( dedent ( f \"\"\" select verse.id, verse.text from verse inner join chapter on verse.chapter_id=chapter.id inner join book on chapter.book_id=book.id where book.name = ' { bk } ' and chapter.chapter_num = { ch } and verse_num = { vs } ; \"\"\" ) ) if len ( verseInfo ) == 0 : msgs . append (( \"Error\" , f \"No such verse: { bk } { ch } : { vs } \" )) good = False else : data = verseInfo [ 0 ] vid = data [ 0 ] wordInfo = passageDb . executesql ( dedent ( f \"\"\" select word.word_phono, word.word_phono_sep from word inner join word_verse on word_number = word_verse.anchor inner join verse on verse.id = word_verse.verse_id where verse.id = { vid } order by word_number ; \"\"\" ) ) data = dict ( text = data [ 1 ], phonetic = \"\" . join ( x [ 0 ] + x [ 1 ] for x in wordInfo ) ) return json . dumps ( dict ( good = good , msgs = msgs , data = data ), ensure_ascii = False )","title":"Verse"},{"location":"server/bymodule/verse/#verse","text":"","title":"verse"},{"location":"server/bymodule/verse/#verse.VERSE","text":"Get verse data of a verse. The verse data are the linguistic feature data for the words in a verse.","title":"VERSE"},{"location":"server/bymodule/verse/#verse.VERSE.__init__","text":"Source code in modules/verse.py def __init__ ( self ): pass","title":"__init__()"},{"location":"server/bymodule/verse/#verse.VERSE.get","text":"Get linguistic data of a verse. Source code in modules/verse.py def get ( self ): \"\"\"Get linguistic data of a verse. \"\"\" extension = current . request . extension if extension == \"json\" : return self . getJson () Check = current . Check Caching = current . Caching vr = Check . field ( \"material\" , \"\" , \"version\" ) bk = Check . field ( \"material\" , \"\" , \"book\" ) ch = Check . field ( \"material\" , \"\" , \"chapter\" ) vs = Check . field ( \"material\" , \"\" , \"verse\" ) tr = Check . field ( \"material\" , \"\" , \"tr\" ) if vs is None : return dict ( good = False , msgs = []) return Caching . get ( f \"verse_ { vr } _ { bk } _ { ch } _ { vs } _ { tr } _\" , lambda : self . get_c ( vr , bk , ch , vs , tr ), ONE_HOUR , )","title":"get()"},{"location":"server/bymodule/verse/#verse.VERSE.get_c","text":"Source code in modules/verse.py def get_c ( self , vr , bk , ch , vs , tr ): material = VERSECONTENT ( vr , bk , ch , vs , xml = None , wordData = None , tp = \"txtd\" , tr = tr , mr = None , ) good = True msgs = [] if len ( material . wordData ) == 0 : msgs = [( \"error\" , f \" { bk } { ch } : { vs } does not exist\" )] good = False return dict ( good = good , msgs = msgs , material = material , )","title":"get_c()"},{"location":"server/bymodule/verse/#verse.VERSE.getJson","text":"Source code in modules/verse.py def getJson ( self , vr , bk , ch , vs ): Caching = current . Caching return Caching . get ( f \"versej_ { vr } _ { bk } _ { ch } _ { vs } _\" , lambda : self . getJson_c ( vr , bk , ch , vs ), ONE_HOUR , )","title":"getJson()"},{"location":"server/bymodule/verse/#verse.VERSE.getJson_c","text":"Source code in modules/verse.py def getJson_c ( self ): Check = current . Check PASSAGE_DBS = current . PASSAGE_DBS vr = Check . field ( \"material\" , \"\" , \"version\" ) bk = Check . field ( \"material\" , \"\" , \"book\" ) ch = Check . field ( \"material\" , \"\" , \"chapter\" ) vs = Check . field ( \"material\" , \"\" , \"verse\" ) passageDb = PASSAGE_DBS [ vr ] if vr in PASSAGE_DBS else None msgs = [] good = True data = dict () if passageDb is None : msgs . append (( \"Error\" , f \"No such version: { vr } \" )) good = False if good : verseInfo = passageDb . executesql ( dedent ( f \"\"\" select verse.id, verse.text from verse inner join chapter on verse.chapter_id=chapter.id inner join book on chapter.book_id=book.id where book.name = ' { bk } ' and chapter.chapter_num = { ch } and verse_num = { vs } ; \"\"\" ) ) if len ( verseInfo ) == 0 : msgs . append (( \"Error\" , f \"No such verse: { bk } { ch } : { vs } \" )) good = False else : data = verseInfo [ 0 ] vid = data [ 0 ] wordInfo = passageDb . executesql ( dedent ( f \"\"\" select word.word_phono, word.word_phono_sep from word inner join word_verse on word_number = word_verse.anchor inner join verse on verse.id = word_verse.verse_id where verse.id = { vid } order by word_number ; \"\"\" ) ) data = dict ( text = data [ 1 ], phonetic = \"\" . join ( x [ 0 ] + x [ 1 ] for x in wordInfo ) ) return json . dumps ( dict ( good = good , msgs = msgs , data = data ), ensure_ascii = False )","title":"getJson_c()"},{"location":"server/bymodule/versecontent/","text":"versecontent \u00b6 VERSECONTENT \u00b6 Handle a single verse. It can retrieve word data from the database and render it in various textual formats. __init__ ( self , vr , book_name , chapter_num , verse_num , xml = None , wordData = None , tp = None , tr = None , mr = None , lang = 'en' ) special \u00b6 Source code in modules/versecontent.py def __init__ ( self , vr , book_name , chapter_num , verse_num , xml = None , wordData = None , tp = None , tr = None , mr = None , lang = \"en\" , ): self . version = vr self . tp = tp self . tr = tr self . mr = mr self . lang = lang self . book_name = book_name self . chapter_num = chapter_num self . verse_num = verse_num self . xml = xml self . wordData = wordData self . process () process ( self ) \u00b6 Source code in modules/versecontent.py def process ( self ): vr = self . version book_name = self . book_name chapter_num = self . chapter_num verse_num = self . verse_num xml = self . xml wordData = self . wordData if xml is None : xml = \"\" PASSAGE_DBS = current . PASSAGE_DBS passageDb = PASSAGE_DBS . get ( vr , None ) if wordData is None and passageDb : fieldNames = \",\" . join ( FIELDNAMES [ \"txtd\" ]) wsql = dedent ( f \"\"\" select { fieldNames } , lexicon_id from word inner join word_verse on word_number = word_verse.anchor inner join verse on verse.id = word_verse.verse_id inner join chapter on verse.chapter_id = chapter.id inner join book on chapter.book_id = book.id where book.name = ' { book_name } ' and chapter.chapter_num = { chapter_num } and verse.verse_num = { verse_num } order by word_number ; \"\"\" ) wordRecords = passageDb . executesql ( wsql , as_dict = True ) if passageDb else [] wordData = [] for record in wordRecords : wordData . append ( dict ( ( ( x , hEsc ( str ( y ), not ( x . endswith ( \"_border\" ) or x in NOTFILLFIELDS ), ), ) for ( x , y ) in record . items () ), ) ) self . xml = xml self . wordData = wordData self . words = [] label ( self ) \u00b6 Source code in modules/versecontent.py def label ( self ): return ( BOOK_TRANS [ self . lang ][ self . book_name ] . replace ( \"_\" , \" \" ), self . book_name , self . chapter_num , self . verse_num , ) getWords ( self ) \u00b6 Source code in modules/versecontent.py def getWords ( self ): if len ( self . words ) == 0 : root = ET . fromstring ( f \"<verse> { self . xml } </verse>\" . encode ( \"utf-8\" )) i = 0 for child in root : slotid = int ( child . attrib [ \"m\" ]) lexicon_id = child . attrib [ \"l\" ] text = \"\" if child . text is None else child . text thisWordData = self . wordData [ i ] phonoText = thisWordData [ \"word_phono\" ] phonoSep = thisWordData [ \"word_phono_sep\" ] trailer = child . get ( \"t\" , \"\" ) self . words . append ( ( slotid , lexicon_id , text , trailer , phonoText , phonoSep ) ) i += 1 return self . words material ( self , userAgent ) \u00b6 Source code in modules/versecontent.py def material ( self , userAgent ): if self . tp == \"txtp\" : return self . plainText ( userAgent ) elif self . tp == \"txt1\" : return self . tab1Text ( userAgent ) elif self . tp == \"txt2\" : return self . tab2Text ( userAgent ) elif self . tp == \"txt3\" : return self . tab3Text ( userAgent ) elif self . tp == \"txtd\" : return self . dataText ( userAgent ) plainText ( self , userAgent ) \u00b6 Present text in plain Hebrew or plain phonetic text. See \u2208 text-representation Source code in modules/versecontent.py def plainText ( self , userAgent ): \"\"\"Present text in plain Hebrew or plain phonetic text. See [\u2208 text-representation][elem-text-representation] \"\"\" material = [] for word in self . getWords (): if self . tr == \"hb\" : wordText = word [ 2 ] sep = word [ 3 ] elif self . tr == \"ph\" : wordText = word [ 4 ] sep = word [ 5 ] material . append ( f \"\"\"<span m=\" { word [ 0 ] } \" l=\" { word [ 1 ] } \"> { wordText } </span> { sep } \"\"\" ) return \"\" . join ( material ) dataText ( self , userAgent ) \u00b6 Present text in data format. Linguistic features of the words will be shown, according to the current settings of the legend. See \u2208 legend , \u2208 show-verse-data Source code in modules/versecontent.py def dataText ( self , userAgent ): \"\"\"Present text in data format. Linguistic features of the words will be shown, according to the current settings of the legend. See [\u2208 legend][elem-feature-legend], [\u2208 show-verse-data][elem-show-verse-data] \"\"\" material = [] for word in self . wordData : material . append ( TEXT_TPL . format ( ** word )) return \"\" . join ( material ) tab1Text ( self , userAgent ) \u00b6 Present text in a table, mode 1. Mode 1 is notes view, i.e. notes are viewed interlinear with the clause atoms. See \u2208 text-presentation Source code in modules/versecontent.py def tab1Text ( self , userAgent ): \"\"\"Present text in a table, mode 1. Mode 1 is notes view, i.e. notes are viewed interlinear with the clause atoms. See [\u2208 text-presentation][elem-text-presentation] \"\"\" material = [ \"\"\"<table class=\"t1_table\">\"\"\" ] curNum = ( 0 , 0 , 0 ) curClauseAtom = [] for word in self . wordData : thisNum = ( word [ \"sentence_number\" ], word [ \"clause_number\" ], word [ \"clause_atom_number\" ], ) if thisNum != curNum : material . append ( self . putClauseAtom1 ( curClauseAtom )) curClauseAtom = [] curNum = thisNum curClauseAtom . append ( word ) material . append ( self . putClauseAtom1 ( curClauseAtom )) material . append ( \"</table>\" ) return \"\" . join ( material ) tab2Text ( self , userAgent ) \u00b6 Present text in a table, mode 2. Mode 2 is syntactic view, i.e. indentation is used to represent linguistic embedding. See \u2208 text-presentation Source code in modules/versecontent.py def tab2Text ( self , userAgent ): \"\"\"Present text in a table, mode 2. Mode 2 is syntactic view, i.e. indentation is used to represent linguistic embedding. See [\u2208 text-presentation][elem-text-presentation] \"\"\" material = [ '<dl class=\"lv2\">' ] curNum = ( 0 , 0 , 0 ) curClauseAtom = [] for word in self . wordData : thisNum = ( word [ \"sentence_number\" ], word [ \"clause_number\" ], word [ \"clause_atom_number\" ], ) if thisNum != curNum : material . append ( self . putClauseAtom2 ( curClauseAtom )) curClauseAtom = [] curNum = thisNum curClauseAtom . append ( word ) material . append ( self . putClauseAtom2 ( curClauseAtom )) material . append ( \"</dl>\" ) return \"\" . join ( material ) tab3Text ( self , userAgent ) \u00b6 Present text in a table, mode 3. Mode 3 is abstract view, i.e. letters are replaced by abstract symbols, where many letters map to the same symbol. represent linguistic embedding. See \u2208 text-presentation Source code in modules/versecontent.py def tab3Text ( self , userAgent ): \"\"\"Present text in a table, mode 3. Mode 3 is abstract view, i.e. letters are replaced by abstract symbols, where many letters map to the same symbol. represent linguistic embedding. See [\u2208 text-presentation][elem-text-presentation] \"\"\" material = [ '<dl class=\"lv3\">' ] curNum = ( 0 , 0 , 0 ) curClauseAtom = [] for word in self . wordData : thisNum = ( word [ \"sentence_number\" ], word [ \"clause_number\" ], word [ \"clause_atom_number\" ], ) if thisNum != curNum : material . append ( self . putClauseAtom3 ( curClauseAtom )) curClauseAtom = [] curNum = thisNum curClauseAtom . append ( word ) material . append ( self . putClauseAtom3 ( curClauseAtom )) material . append ( \"</dl>\" ) return \"\" . join ( material ) putClauseAtom1 ( self , words ) \u00b6 Source code in modules/versecontent.py def putClauseAtom1 ( self , words ): if len ( words ) == 0 : return \"\" textType = words [ 0 ][ \"clause_txt\" ] . replace ( \"?\" , \"\" ) clauseType = words [ 0 ][ \"clause_typ\" ] tabN = int ( words [ 0 ][ \"clause_atom_tab\" ]) clauseAtomNumber = int ( words [ 0 ][ \"clause_atom_number\" ]) tab10s = int ( tabN // 10 ) tab10r = tabN % 10 smalltab = \"&lt;\" * tab10r bigtab = \"&lt;\" * tab10s result = [ dedent ( f \"\"\" <tr clause_atom=\" { clauseAtomNumber } \"> <td colspan=\"3\" class=\"t1_txt\"> \"\"\" ) ] for word in words : if \"r\" in word [ \"phrase_border\" ]: result . append ( dedent ( f \"\"\"<span class=\"t1_phf1\" > { word [ \"phrase_function\" ] } </span><span class=\"t1_phfn\"> { word [ \"phrase_number\" ] } </span>\"\"\" ) ) if self . tr == \"hb\" : wordText = word [ \"word_heb\" ] elif self . tr == \"ph\" : wordText = word [ \"word_phono\" ] + word [ \"word_phono_sep\" ] result . append ( f \"\"\"<span m=\" { word [ \"word_number\" ] } \" l=\" { word [ \"lexicon_id\" ] } \">\"\"\" f \"\"\" { wordText } </span>\"\"\" ) result . append ( dedent ( f \"\"\" </td> <td class=\"t1_tb1\"> { smalltab } </td> <td class=\"t1_tb10\"> { bigtab } </td> <td class=\"t1_txttp\"> { textType } </td> <td class=\"t1_ctp\"> { clauseType } </td> </tr> \"\"\" ) ) return \"\" . join ( result ) putClauseAtom2 ( self , words ) \u00b6 Source code in modules/versecontent.py def putClauseAtom2 ( self , words ): if len ( words ) == 0 : return \"\" textType = words [ 0 ][ \"clause_txt\" ] clauseType = words [ 0 ][ \"clause_typ\" ] code = words [ 0 ][ \"clause_atom_code\" ] tabN = int ( words [ 0 ][ \"clause_atom_tab\" ]) tab = '<span class=\"fa\">&#xf060;</span>' * tabN # arrow-left result = [ dedent ( f \"\"\"<dt class=\"lv2\"><span class=\"ctxt2\" > { textType } </span> <span class=\"ctp2\"> { clauseType } </span> <span class=\"ccode2\" > { code } </span></dt><dd class=\"lv2\" ><span class=\"tb2\"> { tab } </span>&nbsp;\"\"\" ) ] for word in words : if \"r\" in word [ \"phrase_border\" ]: result . append ( f ' <span class=\"phf2\"> { word [ \"phrase_function\" ] } </span> ' ) if self . tr == \"hb\" : wordText = word [ \"word_heb\" ] elif self . tr == \"ph\" : wordText = word [ \"word_phono\" ] + word [ \"word_phono_sep\" ] result . append ( f \"\"\"<span m=\" { word [ \"word_number\" ] } \" l=\" { word [ \"lexicon_id\" ] } \">\"\"\" f \" { wordText } </span> \" ) result . append ( \"</dd>\" ) return \"\" . join ( result ) putClauseAtom3 ( self , words ) \u00b6 Source code in modules/versecontent.py def putClauseAtom3 ( self , words ): if len ( words ) == 0 : return \"\" tabN = int ( words [ 0 ][ \"clause_atom_tab\" ]) tab = '<span class=\"fa\">&#xf060;</span>' * tabN # arrow-left result = [ f '<dt class=\"lv3\"><span class=\"tb3\"> { tab } </span></dt><dd class=\"lv3\">' ] phrb_table = dict ( rr = \"&nbsp;\" , # arrow-circle-right r = '<span class=\"fa\">&#xf105;</span>' , # arrow-circle-o-left l = '<span class=\"fa\">&#xf104;</span>' , # arrow-circle-o-right ll = \"&nbsp;\" , # arrow-circle-left, ) for word in words : phraseBorders = word [ \"phrase_border\" ] . split () borderSymStart = \"\" borderSymEnd = \"\" for phraseBorder in phraseBorders : borderSymbols = phrb_table . get ( phraseBorder , \"\" ) if \"r\" in phraseBorder : borderSymStart = borderSymbols elif \"l\" in phraseBorder : borderSymEnd = borderSymbols if word [ \"word_lex\" ] == \"H\" : textSymbol = \"0d9\" # caret-left elif word [ \"word_lex\" ] == \"W\" : textSymbol = \"0d8\" # caret-up elif word [ \"word_lex\" ] == \"&gt;LHJM/\" : textSymbol = \"0ed\" # elif word [ \"word_lex\" ] == \"JHWH/\" : textSymbol = \"0ee\" # elif word [ \"word_pos\" ] == \"nmpr\" : if word [ \"word_gender\" ] == \"m\" : textSymbol = \"222\" # mars elif word [ \"word_gender\" ] == \"f\" : textSymbol = \"221\" # venus elif word [ \"word_gender\" ] == \"NA\" : textSymbol = \"1db\" # genderless elif word [ \"word_gender\" ] == \"unknown\" : textSymbol = \"1db\" # genderless elif word [ \"word_pos\" ] == \"verb\" : textSymbol = \"013\" # cog elif word [ \"word_pos\" ] == \"subs\" : textSymbol = \"146\" # minus-square else : textSymbol = \"068\" # minus result . append ( f \"\"\" { borderSymStart } <span m=\" { word [ \"word_number\" ] } \" l=\" { word [ \"lexicon_id\" ] } \" ><span class=\"fa\">&#xf { textSymbol } ;</span></span> { borderSymEnd } \"\"\" ) result . append ( \"</dd>\" ) return \"\" . join ( result )","title":"Versecontent"},{"location":"server/bymodule/versecontent/#versecontent","text":"","title":"versecontent"},{"location":"server/bymodule/versecontent/#versecontent.VERSECONTENT","text":"Handle a single verse. It can retrieve word data from the database and render it in various textual formats.","title":"VERSECONTENT"},{"location":"server/bymodule/versecontent/#versecontent.VERSECONTENT.__init__","text":"Source code in modules/versecontent.py def __init__ ( self , vr , book_name , chapter_num , verse_num , xml = None , wordData = None , tp = None , tr = None , mr = None , lang = \"en\" , ): self . version = vr self . tp = tp self . tr = tr self . mr = mr self . lang = lang self . book_name = book_name self . chapter_num = chapter_num self . verse_num = verse_num self . xml = xml self . wordData = wordData self . process ()","title":"__init__()"},{"location":"server/bymodule/versecontent/#versecontent.VERSECONTENT.process","text":"Source code in modules/versecontent.py def process ( self ): vr = self . version book_name = self . book_name chapter_num = self . chapter_num verse_num = self . verse_num xml = self . xml wordData = self . wordData if xml is None : xml = \"\" PASSAGE_DBS = current . PASSAGE_DBS passageDb = PASSAGE_DBS . get ( vr , None ) if wordData is None and passageDb : fieldNames = \",\" . join ( FIELDNAMES [ \"txtd\" ]) wsql = dedent ( f \"\"\" select { fieldNames } , lexicon_id from word inner join word_verse on word_number = word_verse.anchor inner join verse on verse.id = word_verse.verse_id inner join chapter on verse.chapter_id = chapter.id inner join book on chapter.book_id = book.id where book.name = ' { book_name } ' and chapter.chapter_num = { chapter_num } and verse.verse_num = { verse_num } order by word_number ; \"\"\" ) wordRecords = passageDb . executesql ( wsql , as_dict = True ) if passageDb else [] wordData = [] for record in wordRecords : wordData . append ( dict ( ( ( x , hEsc ( str ( y ), not ( x . endswith ( \"_border\" ) or x in NOTFILLFIELDS ), ), ) for ( x , y ) in record . items () ), ) ) self . xml = xml self . wordData = wordData self . words = []","title":"process()"},{"location":"server/bymodule/versecontent/#versecontent.VERSECONTENT.label","text":"Source code in modules/versecontent.py def label ( self ): return ( BOOK_TRANS [ self . lang ][ self . book_name ] . replace ( \"_\" , \" \" ), self . book_name , self . chapter_num , self . verse_num , )","title":"label()"},{"location":"server/bymodule/versecontent/#versecontent.VERSECONTENT.getWords","text":"Source code in modules/versecontent.py def getWords ( self ): if len ( self . words ) == 0 : root = ET . fromstring ( f \"<verse> { self . xml } </verse>\" . encode ( \"utf-8\" )) i = 0 for child in root : slotid = int ( child . attrib [ \"m\" ]) lexicon_id = child . attrib [ \"l\" ] text = \"\" if child . text is None else child . text thisWordData = self . wordData [ i ] phonoText = thisWordData [ \"word_phono\" ] phonoSep = thisWordData [ \"word_phono_sep\" ] trailer = child . get ( \"t\" , \"\" ) self . words . append ( ( slotid , lexicon_id , text , trailer , phonoText , phonoSep ) ) i += 1 return self . words","title":"getWords()"},{"location":"server/bymodule/versecontent/#versecontent.VERSECONTENT.material","text":"Source code in modules/versecontent.py def material ( self , userAgent ): if self . tp == \"txtp\" : return self . plainText ( userAgent ) elif self . tp == \"txt1\" : return self . tab1Text ( userAgent ) elif self . tp == \"txt2\" : return self . tab2Text ( userAgent ) elif self . tp == \"txt3\" : return self . tab3Text ( userAgent ) elif self . tp == \"txtd\" : return self . dataText ( userAgent )","title":"material()"},{"location":"server/bymodule/versecontent/#versecontent.VERSECONTENT.plainText","text":"Present text in plain Hebrew or plain phonetic text. See \u2208 text-representation Source code in modules/versecontent.py def plainText ( self , userAgent ): \"\"\"Present text in plain Hebrew or plain phonetic text. See [\u2208 text-representation][elem-text-representation] \"\"\" material = [] for word in self . getWords (): if self . tr == \"hb\" : wordText = word [ 2 ] sep = word [ 3 ] elif self . tr == \"ph\" : wordText = word [ 4 ] sep = word [ 5 ] material . append ( f \"\"\"<span m=\" { word [ 0 ] } \" l=\" { word [ 1 ] } \"> { wordText } </span> { sep } \"\"\" ) return \"\" . join ( material )","title":"plainText()"},{"location":"server/bymodule/versecontent/#versecontent.VERSECONTENT.dataText","text":"Present text in data format. Linguistic features of the words will be shown, according to the current settings of the legend. See \u2208 legend , \u2208 show-verse-data Source code in modules/versecontent.py def dataText ( self , userAgent ): \"\"\"Present text in data format. Linguistic features of the words will be shown, according to the current settings of the legend. See [\u2208 legend][elem-feature-legend], [\u2208 show-verse-data][elem-show-verse-data] \"\"\" material = [] for word in self . wordData : material . append ( TEXT_TPL . format ( ** word )) return \"\" . join ( material )","title":"dataText()"},{"location":"server/bymodule/versecontent/#versecontent.VERSECONTENT.tab1Text","text":"Present text in a table, mode 1. Mode 1 is notes view, i.e. notes are viewed interlinear with the clause atoms. See \u2208 text-presentation Source code in modules/versecontent.py def tab1Text ( self , userAgent ): \"\"\"Present text in a table, mode 1. Mode 1 is notes view, i.e. notes are viewed interlinear with the clause atoms. See [\u2208 text-presentation][elem-text-presentation] \"\"\" material = [ \"\"\"<table class=\"t1_table\">\"\"\" ] curNum = ( 0 , 0 , 0 ) curClauseAtom = [] for word in self . wordData : thisNum = ( word [ \"sentence_number\" ], word [ \"clause_number\" ], word [ \"clause_atom_number\" ], ) if thisNum != curNum : material . append ( self . putClauseAtom1 ( curClauseAtom )) curClauseAtom = [] curNum = thisNum curClauseAtom . append ( word ) material . append ( self . putClauseAtom1 ( curClauseAtom )) material . append ( \"</table>\" ) return \"\" . join ( material )","title":"tab1Text()"},{"location":"server/bymodule/versecontent/#versecontent.VERSECONTENT.tab2Text","text":"Present text in a table, mode 2. Mode 2 is syntactic view, i.e. indentation is used to represent linguistic embedding. See \u2208 text-presentation Source code in modules/versecontent.py def tab2Text ( self , userAgent ): \"\"\"Present text in a table, mode 2. Mode 2 is syntactic view, i.e. indentation is used to represent linguistic embedding. See [\u2208 text-presentation][elem-text-presentation] \"\"\" material = [ '<dl class=\"lv2\">' ] curNum = ( 0 , 0 , 0 ) curClauseAtom = [] for word in self . wordData : thisNum = ( word [ \"sentence_number\" ], word [ \"clause_number\" ], word [ \"clause_atom_number\" ], ) if thisNum != curNum : material . append ( self . putClauseAtom2 ( curClauseAtom )) curClauseAtom = [] curNum = thisNum curClauseAtom . append ( word ) material . append ( self . putClauseAtom2 ( curClauseAtom )) material . append ( \"</dl>\" ) return \"\" . join ( material )","title":"tab2Text()"},{"location":"server/bymodule/versecontent/#versecontent.VERSECONTENT.tab3Text","text":"Present text in a table, mode 3. Mode 3 is abstract view, i.e. letters are replaced by abstract symbols, where many letters map to the same symbol. represent linguistic embedding. See \u2208 text-presentation Source code in modules/versecontent.py def tab3Text ( self , userAgent ): \"\"\"Present text in a table, mode 3. Mode 3 is abstract view, i.e. letters are replaced by abstract symbols, where many letters map to the same symbol. represent linguistic embedding. See [\u2208 text-presentation][elem-text-presentation] \"\"\" material = [ '<dl class=\"lv3\">' ] curNum = ( 0 , 0 , 0 ) curClauseAtom = [] for word in self . wordData : thisNum = ( word [ \"sentence_number\" ], word [ \"clause_number\" ], word [ \"clause_atom_number\" ], ) if thisNum != curNum : material . append ( self . putClauseAtom3 ( curClauseAtom )) curClauseAtom = [] curNum = thisNum curClauseAtom . append ( word ) material . append ( self . putClauseAtom3 ( curClauseAtom )) material . append ( \"</dl>\" ) return \"\" . join ( material )","title":"tab3Text()"},{"location":"server/bymodule/versecontent/#versecontent.VERSECONTENT.putClauseAtom1","text":"Source code in modules/versecontent.py def putClauseAtom1 ( self , words ): if len ( words ) == 0 : return \"\" textType = words [ 0 ][ \"clause_txt\" ] . replace ( \"?\" , \"\" ) clauseType = words [ 0 ][ \"clause_typ\" ] tabN = int ( words [ 0 ][ \"clause_atom_tab\" ]) clauseAtomNumber = int ( words [ 0 ][ \"clause_atom_number\" ]) tab10s = int ( tabN // 10 ) tab10r = tabN % 10 smalltab = \"&lt;\" * tab10r bigtab = \"&lt;\" * tab10s result = [ dedent ( f \"\"\" <tr clause_atom=\" { clauseAtomNumber } \"> <td colspan=\"3\" class=\"t1_txt\"> \"\"\" ) ] for word in words : if \"r\" in word [ \"phrase_border\" ]: result . append ( dedent ( f \"\"\"<span class=\"t1_phf1\" > { word [ \"phrase_function\" ] } </span><span class=\"t1_phfn\"> { word [ \"phrase_number\" ] } </span>\"\"\" ) ) if self . tr == \"hb\" : wordText = word [ \"word_heb\" ] elif self . tr == \"ph\" : wordText = word [ \"word_phono\" ] + word [ \"word_phono_sep\" ] result . append ( f \"\"\"<span m=\" { word [ \"word_number\" ] } \" l=\" { word [ \"lexicon_id\" ] } \">\"\"\" f \"\"\" { wordText } </span>\"\"\" ) result . append ( dedent ( f \"\"\" </td> <td class=\"t1_tb1\"> { smalltab } </td> <td class=\"t1_tb10\"> { bigtab } </td> <td class=\"t1_txttp\"> { textType } </td> <td class=\"t1_ctp\"> { clauseType } </td> </tr> \"\"\" ) ) return \"\" . join ( result )","title":"putClauseAtom1()"},{"location":"server/bymodule/versecontent/#versecontent.VERSECONTENT.putClauseAtom2","text":"Source code in modules/versecontent.py def putClauseAtom2 ( self , words ): if len ( words ) == 0 : return \"\" textType = words [ 0 ][ \"clause_txt\" ] clauseType = words [ 0 ][ \"clause_typ\" ] code = words [ 0 ][ \"clause_atom_code\" ] tabN = int ( words [ 0 ][ \"clause_atom_tab\" ]) tab = '<span class=\"fa\">&#xf060;</span>' * tabN # arrow-left result = [ dedent ( f \"\"\"<dt class=\"lv2\"><span class=\"ctxt2\" > { textType } </span> <span class=\"ctp2\"> { clauseType } </span> <span class=\"ccode2\" > { code } </span></dt><dd class=\"lv2\" ><span class=\"tb2\"> { tab } </span>&nbsp;\"\"\" ) ] for word in words : if \"r\" in word [ \"phrase_border\" ]: result . append ( f ' <span class=\"phf2\"> { word [ \"phrase_function\" ] } </span> ' ) if self . tr == \"hb\" : wordText = word [ \"word_heb\" ] elif self . tr == \"ph\" : wordText = word [ \"word_phono\" ] + word [ \"word_phono_sep\" ] result . append ( f \"\"\"<span m=\" { word [ \"word_number\" ] } \" l=\" { word [ \"lexicon_id\" ] } \">\"\"\" f \" { wordText } </span> \" ) result . append ( \"</dd>\" ) return \"\" . join ( result )","title":"putClauseAtom2()"},{"location":"server/bymodule/versecontent/#versecontent.VERSECONTENT.putClauseAtom3","text":"Source code in modules/versecontent.py def putClauseAtom3 ( self , words ): if len ( words ) == 0 : return \"\" tabN = int ( words [ 0 ][ \"clause_atom_tab\" ]) tab = '<span class=\"fa\">&#xf060;</span>' * tabN # arrow-left result = [ f '<dt class=\"lv3\"><span class=\"tb3\"> { tab } </span></dt><dd class=\"lv3\">' ] phrb_table = dict ( rr = \"&nbsp;\" , # arrow-circle-right r = '<span class=\"fa\">&#xf105;</span>' , # arrow-circle-o-left l = '<span class=\"fa\">&#xf104;</span>' , # arrow-circle-o-right ll = \"&nbsp;\" , # arrow-circle-left, ) for word in words : phraseBorders = word [ \"phrase_border\" ] . split () borderSymStart = \"\" borderSymEnd = \"\" for phraseBorder in phraseBorders : borderSymbols = phrb_table . get ( phraseBorder , \"\" ) if \"r\" in phraseBorder : borderSymStart = borderSymbols elif \"l\" in phraseBorder : borderSymEnd = borderSymbols if word [ \"word_lex\" ] == \"H\" : textSymbol = \"0d9\" # caret-left elif word [ \"word_lex\" ] == \"W\" : textSymbol = \"0d8\" # caret-up elif word [ \"word_lex\" ] == \"&gt;LHJM/\" : textSymbol = \"0ed\" # elif word [ \"word_lex\" ] == \"JHWH/\" : textSymbol = \"0ee\" # elif word [ \"word_pos\" ] == \"nmpr\" : if word [ \"word_gender\" ] == \"m\" : textSymbol = \"222\" # mars elif word [ \"word_gender\" ] == \"f\" : textSymbol = \"221\" # venus elif word [ \"word_gender\" ] == \"NA\" : textSymbol = \"1db\" # genderless elif word [ \"word_gender\" ] == \"unknown\" : textSymbol = \"1db\" # genderless elif word [ \"word_pos\" ] == \"verb\" : textSymbol = \"013\" # cog elif word [ \"word_pos\" ] == \"subs\" : textSymbol = \"146\" # minus-square else : textSymbol = \"068\" # minus result . append ( f \"\"\" { borderSymStart } <span m=\" { word [ \"word_number\" ] } \" l=\" { word [ \"lexicon_id\" ] } \" ><span class=\"fa\">&#xf { textSymbol } ;</span></span> { borderSymEnd } \"\"\" ) result . append ( \"</dd>\" ) return \"\" . join ( result )","title":"putClauseAtom3()"},{"location":"server/bymodule/versescontent/","text":"versescontent \u00b6 VERSESCONTENT \u00b6 __init__ ( self , vr , mr , verseIds = None , chapter = None , tp = None , tr = None , lang = 'en' ) special \u00b6 my docs Source code in modules/versescontent.py def __init__ ( self , vr , mr , verseIds = None , chapter = None , tp = None , tr = None , lang = \"en\" , ): \"\"\"my docs\"\"\" if tr is None : tr = \"hb\" self . version = vr self . mr = mr self . tp = tp self . tr = tr self . lang = lang self . chapter = chapter self . verseIds = verseIds self . process () process ( self ) \u00b6 Source code in modules/versescontent.py def process ( self ): vr = self . version mr = self . mr tp = self . tp tr = self . tr lang = self . lang chapter = self . chapter verseIds = self . verseIds PASSAGE_DBS = current . PASSAGE_DBS passageDb = PASSAGE_DBS . get ( vr , None ) if passageDb is None : return self . verses = [] if self . mr == \"r\" and ( verseIds is None or len ( verseIds ) == 0 ): return verseIdsStr = ( \",\" . join (( str ( verse_id ) for verse_id in verseIds )) if verseIds is not None else None ) verseIdField = \"verse.id\" wordVerseField = \"word_verse.verse_id\" conditionPre = ( dedent ( f \"\"\" where {{}} in ( { verseIdsStr } ) \"\"\" ) if verseIds is not None else dedent ( f \"\"\" where chapter_id = { chapter } \"\"\" ) if chapter is not None else \"\" ) condition = conditionPre . format ( verseIdField ) wcondition = conditionPre . format ( wordVerseField ) verseInfo = ( passageDb . executesql ( dedent ( f \"\"\" select verse.id, book.name, chapter.chapter_num, verse.verse_num { \", verse.xml\" if tp == \"txtp\" else \"\" } from verse inner join chapter on verse.chapter_id=chapter.id inner join book on chapter.book_id=book.id { condition } order by verse.id ; \"\"\" ) ) if passageDb else [] ) wordRecords = [] wordRecords = ( passageDb . executesql ( dedent ( f \"\"\" select { \",\" . join ( FIELDNAMES [ tp ]) } , verse_id, lexicon_id from word inner join word_verse on word_number = word_verse.anchor inner join verse on verse.id = word_verse.verse_id { wcondition } order by word_number ; \"\"\" ), as_dict = True , ) if passageDb else [] ) wordData = collections . defaultdict ( lambda : []) for record in wordRecords : wordData [ record [ \"verse_id\" ]] . append ( dict ( ( x , hEsc ( str ( y ), not ( x . endswith ( \"_border\" ) or x in NOTFILLFIELDS )), ) for ( x , y ) in record . items () ) ) for verse in verseInfo : verse_id = int ( verse [ 0 ]) xml = verse [ 4 ] if tp == \"txtp\" else \"\" self . verses . append ( VERSECONTENT ( vr , verse [ 1 ], verse [ 2 ], verse [ 3 ], xml = xml , wordData = wordData [ verse_id ], tp = tp , tr = tr , mr = mr , lang = lang , ) )","title":"Versescontent"},{"location":"server/bymodule/versescontent/#versescontent","text":"","title":"versescontent"},{"location":"server/bymodule/versescontent/#versescontent.VERSESCONTENT","text":"","title":"VERSESCONTENT"},{"location":"server/bymodule/versescontent/#versescontent.VERSESCONTENT.__init__","text":"my docs Source code in modules/versescontent.py def __init__ ( self , vr , mr , verseIds = None , chapter = None , tp = None , tr = None , lang = \"en\" , ): \"\"\"my docs\"\"\" if tr is None : tr = \"hb\" self . version = vr self . mr = mr self . tp = tp self . tr = tr self . lang = lang self . chapter = chapter self . verseIds = verseIds self . process ()","title":"__init__()"},{"location":"server/bymodule/versescontent/#versescontent.VERSESCONTENT.process","text":"Source code in modules/versescontent.py def process ( self ): vr = self . version mr = self . mr tp = self . tp tr = self . tr lang = self . lang chapter = self . chapter verseIds = self . verseIds PASSAGE_DBS = current . PASSAGE_DBS passageDb = PASSAGE_DBS . get ( vr , None ) if passageDb is None : return self . verses = [] if self . mr == \"r\" and ( verseIds is None or len ( verseIds ) == 0 ): return verseIdsStr = ( \",\" . join (( str ( verse_id ) for verse_id in verseIds )) if verseIds is not None else None ) verseIdField = \"verse.id\" wordVerseField = \"word_verse.verse_id\" conditionPre = ( dedent ( f \"\"\" where {{}} in ( { verseIdsStr } ) \"\"\" ) if verseIds is not None else dedent ( f \"\"\" where chapter_id = { chapter } \"\"\" ) if chapter is not None else \"\" ) condition = conditionPre . format ( verseIdField ) wcondition = conditionPre . format ( wordVerseField ) verseInfo = ( passageDb . executesql ( dedent ( f \"\"\" select verse.id, book.name, chapter.chapter_num, verse.verse_num { \", verse.xml\" if tp == \"txtp\" else \"\" } from verse inner join chapter on verse.chapter_id=chapter.id inner join book on chapter.book_id=book.id { condition } order by verse.id ; \"\"\" ) ) if passageDb else [] ) wordRecords = [] wordRecords = ( passageDb . executesql ( dedent ( f \"\"\" select { \",\" . join ( FIELDNAMES [ tp ]) } , verse_id, lexicon_id from word inner join word_verse on word_number = word_verse.anchor inner join verse on verse.id = word_verse.verse_id { wcondition } order by word_number ; \"\"\" ), as_dict = True , ) if passageDb else [] ) wordData = collections . defaultdict ( lambda : []) for record in wordRecords : wordData [ record [ \"verse_id\" ]] . append ( dict ( ( x , hEsc ( str ( y ), not ( x . endswith ( \"_border\" ) or x in NOTFILLFIELDS )), ) for ( x , y ) in record . items () ) ) for verse in verseInfo : verse_id = int ( verse [ 0 ]) xml = verse [ 4 ] if tp == \"txtp\" else \"\" self . verses . append ( VERSECONTENT ( vr , verse [ 1 ], verse [ 2 ], verse [ 3 ], xml = xml , wordData = wordData [ verse_id ], tp = tp , tr = tr , mr = mr , lang = lang , ) )","title":"process()"},{"location":"server/bymodule/viewdefs/","text":"viewdefs \u00b6 Make \u00b6 Set up the definition of all settings and parameters. This involves specifying value types, defining default values defining validation functions value compilation exporting setttings data in Javascript to the client See also {SideSettings} . Page elements: \u2208 highlight-published \u2208 highlight-reset \u2208 highlight-many \u2208 highlight-custom \u2208 highlight-one \u2208 highlight-off \u2208 highlight-select-single-color __init__ ( self ) special \u00b6 Source code in modules/viewdefs.py def __init__ ( self ): nColorRows = 4 nColorCols = 4 nDefaultClrRows = 3 nDefaultClrCols = 4 colorSpec = dedent ( \"\"\" red,#ff0000,#ff0000,1 salmon,#ff6688,#ee7799,1 orange,#ffcc66,#eebb55,1 yellow,#ffff00,#dddd00,1 green,#00ff00,#00bb00,1 spring,#ddff77,#77dd44,1 tropical,#66ffcc,#55ddbb,1 turquoise,#00ffff,#00eeee,1 blue,#8888ff,#0000ff,1 skye,#66ccff,#55bbff,1 lilac,#cc88ff,#aa22ff,1 magenta,#ff00ff,#ee00ee,1 grey,#eeeeee,#eeeeee,0 gray,#aaaaaa,#aaaaaa,0 black,#000000,#000000,0 white,#ffffff,#ffffff,0 \"\"\" ) colorSpecCls = dedent ( \"\"\" 0,z0 1,z1 2,z2 5,z3 10,z4 20,z5 50,z6 51,z7 \"\"\" ) colorProto = [ tuple ( spec . split ( \",\" )) for spec in colorSpec . strip () . split ()] colorsDefault = [ x [ 0 ] for x in colorProto if x [ 3 ] == \"1\" ] colorNames = [ x [ 0 ] for x in colorProto ] colors = dict (( x [ 0 ], dict ( q = x [ 1 ], w = x [ 2 ])) for x in colorProto ) if nColorRows * nColorCols != len ( colorNames ): debug ( \"View settings: mismatch in number of colors: \" f \" { nColorRows } * { nColorCols } != { len ( colorNames ) } \" ) if nDefaultClrRows * nDefaultClrCols != len ( colorsDefault ): debug ( \"View settings: mismatch in number of default colors: \" f \" { nDefaultClrRows } * { nDefaultClrCols } != { len ( colorsDefault ) } \" ) tabInfo = dict ( txt1 = \"Notes view\" , txt2 = \"Syntax view\" , txt3 = \"Abstract view\" , ) tabLabels = dict ( txtp = \"text\" , txt1 = \"Notes\" , txt2 = \"Syntax\" , txt3 = \"Abstract\" , txtd = \"data\" , ) trInfo = [ \"hb\" , \"ph\" ] trLabels = dict ( hb = \"hebrew\" , ph = \"phonetic\" , ) nTabViews = len ( tabInfo ) # nextTp is a mapping from a text type to the next: # it goes txtp => txt1 => txt2 => ... => txtp nextTp = dict ( ( \"txtp\" if i == 0 else f \"txt { i } \" , f \"txt { i + 1 } \" if i < nTabViews else \"txtp\" , ) for i in range ( nTabViews + 1 ) ) # nextTr is a mapping from a script type to the next: it goes hb => ph => hb nextTr = dict (( trInfo [ i ], trInfo [( i + 1 ) % 2 ]) for i in range ( len ( trInfo ))) noteStatusOrder = \"o*+?-!\" noteStatusCls = { \"o\" : \"nt_info\" , \"+\" : \"nt_good\" , \"-\" : \"nt_error\" , \"?\" : \"nt_warning\" , \"!\" : \"nt_special\" , \"*\" : \"nt_note\" , } noteStatusSym = { \"o\" : \"circle\" , \"+\" : \"check-circle\" , \"-\" : \"times-circle\" , \"?\" : \"exclamation-circle\" , \"!\" : \"info-circle\" , \"*\" : \"star\" , } noteStatusNxt = {} for ( i , x ) in enumerate ( noteStatusOrder ): noteStatusNxt [ x ] = noteStatusOrder [( i + 1 ) % len ( noteStatusOrder )] featureFields = dict ( txtp = [ ( \"word_number\" , \"slot\" ), ( \"word_heb\" , \"text\" ), ( \"word_ktv\" , \"ktv\" ), ( \"word_phono\" , \"phtext\" ), ( \"word_phono_sep\" , \"phsep\" ), ], txt1 = [ ( \"word_number\" , \"slot\" ), ( \"word_heb\" , \"text\" ), ( \"word_ktv\" , \"ktv\" ), ( \"word_phono\" , \"phtext\" ), ( \"word_phono_sep\" , \"phsep\" ), ( \"phrase_number\" , \"phrase#\" ), ( \"phrase_function\" , \"function\" ), ( \"clause_txt\" , \"txt\" ), ( \"clause_typ\" , \"typ\" ), ( \"clause_atom_tab\" , \"tab\" ), ], txt2 = [ ( \"word_number\" , \"slot\" ), ( \"word_heb\" , \"text\" ), ( \"word_ktv\" , \"ktv\" ), ( \"word_phono\" , \"phtext\" ), ( \"word_phono_sep\" , \"phsep\" ), ( \"phrase_number\" , \"phrase#\" ), ( \"phrase_function\" , \"function\" ), ( \"clause_txt\" , \"txt\" ), ( \"clause_typ\" , \"typ\" ), ( \"clause_atom_tab\" , \"tab\" ), ( \"clause_atom_code\" , \"code\" ), ], txt3 = [ ( \"word_number\" , \"slot\" ), ( \"word_heb\" , \"text\" ), ( \"word_ktv\" , \"ktv\" ), ( \"word_lex\" , \"lexeme-t\" ), ( \"word_pos\" , \"part-of-speech\" ), ( \"word_gender\" , \"gender\" ), ( \"phrase_number\" , \"phrase#\" ), ( \"clause_atom_tab\" , \"tab\" ), ], ) featureFieldSpec = ( dedent ( \"\"\" ht:ht_ht=word_heb=text-h,ht_hk=word_ktv=ketiv pt:pt=word_phono=text-p hl:hl_hlv=word_vlex=lexeme-v,hl_hlc=word_clex=lexeme-c tt:tt=word_tran=text-t tl:tl_tlv=word_glex=lexeme-g,tl_tlc=word_lex=lexeme-t gl:gl=word_gloss=gloss wd1:wd1_nmtp=word_nmtp=nametype,wd1_subpos=word_subpos=lexical_set,wd1_pos=word_pos=part-of-speech,wd1_pdp=word_pdp=phrase-dependent-part-of-speech,wd1_lang=word_lang=language,wd1_n=word_number=slot wd2:wd2_gender=word_gender=gender,wd2_gnumber=word_gnumber=number,wd2_person=word_person=person,wd2_state=word_state=state,wd2_tense=word_tense=tense,wd2_stem=word_stem=verbal_stem wd3:wd3_nme=word_nme=nme,wd3_pfm=word_pfm=pfm,wd3_prs=word_prs=prs,wd3_uvf=word_uvf=uvf,wd3_vbe=word_vbe=vbe,wd3_vbs=word_vbs=vbs wd4:wd4_statfl=word_freq_lex=freq-lex,wd4_statrl=word_rank_lex=rank-lex,wd4_statfo=word_freq_occ=freq-occ,wd4_statro=word_rank_occ=rank-occ sp:sp_rela=subphrase_rela=rela,sp_n=subphrase_number=subphrase# ph:ph_det=phrase_det=determination,ph_fun=phrase_function=function,ph_typ=phrase_typ=type-ph,ph_rela=phrase_rela=rela,ph_arela=phrase_atom_rela=rela_a,ph_an=phrase_atom_number=phrase_a#,ph_n=phrase_number=phrase# cl:cl_txt=clause_txt=txt,cl_typ=clause_typ=type-cl,cl_rela=clause_rela=rela,cl_tab=clause_atom_tab=tab,cl_par=clause_atom_pargr=par,cl_code=clause_atom_code=code,cl_an=clause_atom_number=clause_a#,cl_n=clause_number=clause# sn:sn_an=sentence_atom_number=sentence_a#,sn_n=sentence_number=sentence# \"\"\" ) . strip () . split () ) featureLines = [] for item in featureFieldSpec : ( line , fieldSpec ) = item . split ( \":\" ) fields = [ x . split ( \"=\" ) for x in fieldSpec . split ( \",\" )] featureLines . append (( line , tuple ( fields ))) itemStyle = dict ( q = dict ( prop = \"background-color\" , default = \"grey\" , off = \"white\" , subtract = 250 , T = \"Q\" , t = \"q\" , Tag = \"Query\" , tag = \"query\" , Tags = \"Queries\" , tags = \"queries\" , ), w = dict ( prop = \"color\" , default = \"gray\" , off = \"black\" , subtract = 250 , T = \"W\" , t = \"w\" , Tag = \"Word\" , tag = \"word\" , Tags = \"Words\" , tags = \"words\" , ), n = dict ( subtract = 250 , T = \"N\" , t = \"n\" , Tag = \"Note\" , tag = \"note\" , Tags = \"Notes\" , tags = \"notes\" , ), m = dict ( subtract = 250 , T = \"I\" , t = \"i\" , Tag = \"Item\" , tag = \"item\" , Tags = \"Items\" , tags = \"items\" , ), ) txtTbs = \",\" . join ( f \"txt { t } \" for t in range ( 1 , nTabViews + 1 )) trLabs = \",\" . join ( trLabels ) specs = dict ( material = ( \"\"\"version book chapter verse iid page mr qw tp tr lang\"\"\" , ( \"\"\"alnum:10 alnum:30 int:1-150 int:1-200 base64:1024 \"\"\" f \"\"\"int:1-1000000 enum:m,r enum:q,w,n enum:txtp, { txtTbs } ,txtd \"\"\" f \"\"\"enum: { trLabs } enum: { BK_NAMES } \"\"\" ), { \"\" : \"\"\"2021 Genesis 1 1 None 1 m x txtp hb en\"\"\" }, ), hebrewdata = ( dedent ( \"\"\" ht ht_ht ht_hk pt hl hl_hlv hl_hlc tt tl tl_tlv tl_tlc gl wd1 wd1_nmtp wd1_subpos wd1_pos wd1_pdp wd1_lang wd1_n wd2 wd2_gender wd2_gnumber wd2_person wd2_state wd2_tense wd2_stem wd3 wd3_nme wd3_pfm wd3_prs wd3_uvf wd3_vbe wd3_vbs wd4 wd4_statfl wd4_statrl wd4_statfo wd4_statro sp sp_rela sp_n ph ph_det ph_fun ph_typ ph_rela ph_arela ph_an ph_n cl cl_txt cl_typ cl_rela cl_tab cl_par cl_code cl_an cl_n sn sn_an sn_n \"\"\" ), dedent ( \"\"\" bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool \"\"\" ), { \"\" : dedent ( \"\"\" v v v v v v x v x x x v v v x v x x x v v v v v v v x x x v x v x v v v x x v v v v v v x x v v v v v v v v v v v v v v v \"\"\" ) }, ), highlights = ( \"\"\"get active sel_one pub\"\"\" , \"\"\"bool enum:hloff,hlone,hlcustom,hlmany enum:color bool\"\"\" , dict ( q = \"x hlcustom grey x\" , w = \"x hlcustom gray x\" , n = \"x hlcustom black v\" ), ), colormap = ( \"0\" , \"\"\"enum:color\"\"\" , dict ( q = \"white\" , w = \"black\" ), ), rest = ( \"\"\"pref lan letter extra\"\"\" , \"\"\"alnum:30 enum:hbo,arc int:1-100000 alnum:64\"\"\" , { \"\" : \"\"\"my hbo 1488 None\"\"\" }, ), ) self . nColorRows = nColorRows self . nColorCols = nColorCols self . nDefaultClrRows = nDefaultClrRows self . nDefaultClrCols = nDefaultClrCols self . colorsDefault = colorsDefault self . colorSpecCls = colorSpecCls self . colorNames = colorNames self . colors = colors self . nTabViews = nTabViews self . tabInfo = tabInfo self . tabLabels = tabLabels self . trInfo = trInfo self . trLabels = trLabels self . nextTp = nextTp self . nextTr = nextTr self . noteStatusCls = noteStatusCls self . noteStatusSym = noteStatusSym self . noteStatusNxt = noteStatusNxt self . featureFields = featureFields self . featureLines = featureLines self . itemStyle = itemStyle self . specs = specs self . setupValidation () setupValidation ( self ) \u00b6 Source code in modules/viewdefs.py def setupValidation ( self ): specs = self . specs settings = collections . defaultdict ( lambda : collections . defaultdict ( lambda : {})) validation = collections . defaultdict ( lambda : collections . defaultdict ( lambda : {}) ) for group in specs : ( flds , types , init ) = specs [ group ] flds = flds . strip () . split () types = types . strip () . split () valtype = [ self . compileValues ( tp ) for tp in types ] for qw in init : initK = init [ qw ] . strip () . split () for ( i , f ) in enumerate ( flds ): thisInitK = initK [ i ] if thisInitK == \"None\" : thisInitK = \"\" settings [ group ][ qw ][ f ] = thisInitK validation [ group ][ qw ][ f ] = valtype [ i ] self . settings = settings self . validation = validation compileValues ( self , tp ) \u00b6 Source code in modules/viewdefs.py def compileValues ( self , tp ): colors = self . colors if tp == \"bool\" : return lambda d , x : x if x in { \"x\" , \"v\" } else d ( t , v ) = tp . split ( \":\" ) if t == \"alnum\" : return ( lambda d , x : x if x is not None and len ( str ( x )) < int ( v ) and str ( x ) . replace ( \"_\" , \"\" ) . replace ( \" \" , \"\" ) . isalnum () else d ) elif t == \"base64\" : return ( lambda d , x : d if x is None else x if ( type ( x ) is str or type ( x ) is str ) and len ( x ) < int ( v ) and x . replace ( \"_\" , \"\" ) . isalnum () else d ) elif t == \"int\" : ( lowest , highest ) = v . split ( \"-\" ) return ( lambda d , x : int ( x ) if x is not None and str ( x ) . isdigit () and int ( x ) >= int ( lowest ) and int ( x ) <= int ( highest ) else int ( d ) if d is not None else d ) elif t == \"enum\" : vals = set ( colors . keys ()) if v == \"color\" else set ( v . split ( \",\" )) return lambda d , x : x if x is not None and x in vals else d export ( self ) \u00b6 Source code in modules/viewdefs.py def export ( self ): return { key : getattr ( self , key ) for key in dedent ( \"\"\" nColorRows nColorCols nDefaultClrRows nDefaultClrCols colorsDefault colorSpecCls colorNames colors nTabViews tabInfo tabLabels trInfo trLabels nextTp nextTr noteStatusCls noteStatusSym noteStatusNxt featureFields featureLines itemStyle specs settings validation \"\"\" ) . strip () . split () } VIEWDEFS \u00b6 __init__ ( self ) special \u00b6 Source code in modules/viewdefs.py def __init__ ( self ): Caching = current . Caching def make (): makeObj = Make () return makeObj . export () keyValues = Caching . get ( \"viewsettings_\" , make , ALWAYS ) for ( key , value ) in keyValues . items (): setattr ( self , key , value ) colorPicker ( self , qw , iid , typ ) \u00b6 Source code in modules/viewdefs.py def colorPicker ( self , qw , iid , typ ): return f \" { self . selectColor ( qw , iid , typ ) }{ self . colorTable ( qw , iid ) } \\n \" makeColors ( self ) \u00b6 Source code in modules/viewdefs.py def makeColors ( self ): colorSpecCls = self . colorSpecCls colorProtoCls = [ tuple ( spec . split ( \",\" )) for spec in colorSpecCls . strip () . split () ] colorsCls = [] lPrev = 0 for ( l , z ) in colorProtoCls : lNew = int ( l ) + 1 for i in range ( lPrev , lNew ): colorsCls . append ( z ) lPrev = lNew return colorsCls colorTable ( self , qw , iid ) \u00b6 Source code in modules/viewdefs.py def colorTable ( self , qw , iid ): nColorRows = self . nColorRows cs = \" \\n \" . join ( self . colorRow ( qw , iid , r ) for r in range ( nColorRows )) return f '<table class=\"picker\" id=\"picker_ { qw }{ iid } \"> \\n { cs } \\n </table> \\n ' colorRow ( self , qw , iid , r ) \u00b6 Source code in modules/viewdefs.py def colorRow ( self , qw , iid , r ): nColorCols = self . nColorCols cells = \" \\n \" . join ( self . colorCell ( qw , iid , c ) for c in range ( r * nColorCols , ( r + 1 ) * nColorCols ) ) return f \" \\t <tr> \\n { cells } \\n\\t </tr>\" colorCell ( self , qw , iid , c ) \u00b6 Source code in modules/viewdefs.py def colorCell ( self , qw , iid , c ): colorNames = self . colorNames return ( f \"\"\" \\t\\t <td class=\"c { qw } { qw }{ iid } \"><a href=\"#\"> { colorNames [ c ] } </a></td>\"\"\" ) selectColor ( self , qw , iid , typ ) \u00b6 Source code in modules/viewdefs.py def selectColor ( self , qw , iid , typ ): content = \"&nbsp;\" if qw == \"q\" else \"w\" selCtl = ( \"\" if typ else f \"\"\"<span class=\"pickedc\" ><input type=\"checkbox\" id=\"select_ { qw }{ iid } \" name=\"select_ { qw }{ iid } \" /></span>&nbsp;\"\"\" ) sel = f \"\"\"<span class=\"picked colorselect_ { qw } \" id=\"sel_ { qw }{ iid } \" ><a href=\"#\"> { content } </a></span>\"\"\" return selCtl + sel","title":"Viewdefs"},{"location":"server/bymodule/viewdefs/#viewdefs","text":"","title":"viewdefs"},{"location":"server/bymodule/viewdefs/#viewdefs.Make","text":"Set up the definition of all settings and parameters. This involves specifying value types, defining default values defining validation functions value compilation exporting setttings data in Javascript to the client See also {SideSettings} . Page elements: \u2208 highlight-published \u2208 highlight-reset \u2208 highlight-many \u2208 highlight-custom \u2208 highlight-one \u2208 highlight-off \u2208 highlight-select-single-color","title":"Make"},{"location":"server/bymodule/viewdefs/#viewdefs.Make.__init__","text":"Source code in modules/viewdefs.py def __init__ ( self ): nColorRows = 4 nColorCols = 4 nDefaultClrRows = 3 nDefaultClrCols = 4 colorSpec = dedent ( \"\"\" red,#ff0000,#ff0000,1 salmon,#ff6688,#ee7799,1 orange,#ffcc66,#eebb55,1 yellow,#ffff00,#dddd00,1 green,#00ff00,#00bb00,1 spring,#ddff77,#77dd44,1 tropical,#66ffcc,#55ddbb,1 turquoise,#00ffff,#00eeee,1 blue,#8888ff,#0000ff,1 skye,#66ccff,#55bbff,1 lilac,#cc88ff,#aa22ff,1 magenta,#ff00ff,#ee00ee,1 grey,#eeeeee,#eeeeee,0 gray,#aaaaaa,#aaaaaa,0 black,#000000,#000000,0 white,#ffffff,#ffffff,0 \"\"\" ) colorSpecCls = dedent ( \"\"\" 0,z0 1,z1 2,z2 5,z3 10,z4 20,z5 50,z6 51,z7 \"\"\" ) colorProto = [ tuple ( spec . split ( \",\" )) for spec in colorSpec . strip () . split ()] colorsDefault = [ x [ 0 ] for x in colorProto if x [ 3 ] == \"1\" ] colorNames = [ x [ 0 ] for x in colorProto ] colors = dict (( x [ 0 ], dict ( q = x [ 1 ], w = x [ 2 ])) for x in colorProto ) if nColorRows * nColorCols != len ( colorNames ): debug ( \"View settings: mismatch in number of colors: \" f \" { nColorRows } * { nColorCols } != { len ( colorNames ) } \" ) if nDefaultClrRows * nDefaultClrCols != len ( colorsDefault ): debug ( \"View settings: mismatch in number of default colors: \" f \" { nDefaultClrRows } * { nDefaultClrCols } != { len ( colorsDefault ) } \" ) tabInfo = dict ( txt1 = \"Notes view\" , txt2 = \"Syntax view\" , txt3 = \"Abstract view\" , ) tabLabels = dict ( txtp = \"text\" , txt1 = \"Notes\" , txt2 = \"Syntax\" , txt3 = \"Abstract\" , txtd = \"data\" , ) trInfo = [ \"hb\" , \"ph\" ] trLabels = dict ( hb = \"hebrew\" , ph = \"phonetic\" , ) nTabViews = len ( tabInfo ) # nextTp is a mapping from a text type to the next: # it goes txtp => txt1 => txt2 => ... => txtp nextTp = dict ( ( \"txtp\" if i == 0 else f \"txt { i } \" , f \"txt { i + 1 } \" if i < nTabViews else \"txtp\" , ) for i in range ( nTabViews + 1 ) ) # nextTr is a mapping from a script type to the next: it goes hb => ph => hb nextTr = dict (( trInfo [ i ], trInfo [( i + 1 ) % 2 ]) for i in range ( len ( trInfo ))) noteStatusOrder = \"o*+?-!\" noteStatusCls = { \"o\" : \"nt_info\" , \"+\" : \"nt_good\" , \"-\" : \"nt_error\" , \"?\" : \"nt_warning\" , \"!\" : \"nt_special\" , \"*\" : \"nt_note\" , } noteStatusSym = { \"o\" : \"circle\" , \"+\" : \"check-circle\" , \"-\" : \"times-circle\" , \"?\" : \"exclamation-circle\" , \"!\" : \"info-circle\" , \"*\" : \"star\" , } noteStatusNxt = {} for ( i , x ) in enumerate ( noteStatusOrder ): noteStatusNxt [ x ] = noteStatusOrder [( i + 1 ) % len ( noteStatusOrder )] featureFields = dict ( txtp = [ ( \"word_number\" , \"slot\" ), ( \"word_heb\" , \"text\" ), ( \"word_ktv\" , \"ktv\" ), ( \"word_phono\" , \"phtext\" ), ( \"word_phono_sep\" , \"phsep\" ), ], txt1 = [ ( \"word_number\" , \"slot\" ), ( \"word_heb\" , \"text\" ), ( \"word_ktv\" , \"ktv\" ), ( \"word_phono\" , \"phtext\" ), ( \"word_phono_sep\" , \"phsep\" ), ( \"phrase_number\" , \"phrase#\" ), ( \"phrase_function\" , \"function\" ), ( \"clause_txt\" , \"txt\" ), ( \"clause_typ\" , \"typ\" ), ( \"clause_atom_tab\" , \"tab\" ), ], txt2 = [ ( \"word_number\" , \"slot\" ), ( \"word_heb\" , \"text\" ), ( \"word_ktv\" , \"ktv\" ), ( \"word_phono\" , \"phtext\" ), ( \"word_phono_sep\" , \"phsep\" ), ( \"phrase_number\" , \"phrase#\" ), ( \"phrase_function\" , \"function\" ), ( \"clause_txt\" , \"txt\" ), ( \"clause_typ\" , \"typ\" ), ( \"clause_atom_tab\" , \"tab\" ), ( \"clause_atom_code\" , \"code\" ), ], txt3 = [ ( \"word_number\" , \"slot\" ), ( \"word_heb\" , \"text\" ), ( \"word_ktv\" , \"ktv\" ), ( \"word_lex\" , \"lexeme-t\" ), ( \"word_pos\" , \"part-of-speech\" ), ( \"word_gender\" , \"gender\" ), ( \"phrase_number\" , \"phrase#\" ), ( \"clause_atom_tab\" , \"tab\" ), ], ) featureFieldSpec = ( dedent ( \"\"\" ht:ht_ht=word_heb=text-h,ht_hk=word_ktv=ketiv pt:pt=word_phono=text-p hl:hl_hlv=word_vlex=lexeme-v,hl_hlc=word_clex=lexeme-c tt:tt=word_tran=text-t tl:tl_tlv=word_glex=lexeme-g,tl_tlc=word_lex=lexeme-t gl:gl=word_gloss=gloss wd1:wd1_nmtp=word_nmtp=nametype,wd1_subpos=word_subpos=lexical_set,wd1_pos=word_pos=part-of-speech,wd1_pdp=word_pdp=phrase-dependent-part-of-speech,wd1_lang=word_lang=language,wd1_n=word_number=slot wd2:wd2_gender=word_gender=gender,wd2_gnumber=word_gnumber=number,wd2_person=word_person=person,wd2_state=word_state=state,wd2_tense=word_tense=tense,wd2_stem=word_stem=verbal_stem wd3:wd3_nme=word_nme=nme,wd3_pfm=word_pfm=pfm,wd3_prs=word_prs=prs,wd3_uvf=word_uvf=uvf,wd3_vbe=word_vbe=vbe,wd3_vbs=word_vbs=vbs wd4:wd4_statfl=word_freq_lex=freq-lex,wd4_statrl=word_rank_lex=rank-lex,wd4_statfo=word_freq_occ=freq-occ,wd4_statro=word_rank_occ=rank-occ sp:sp_rela=subphrase_rela=rela,sp_n=subphrase_number=subphrase# ph:ph_det=phrase_det=determination,ph_fun=phrase_function=function,ph_typ=phrase_typ=type-ph,ph_rela=phrase_rela=rela,ph_arela=phrase_atom_rela=rela_a,ph_an=phrase_atom_number=phrase_a#,ph_n=phrase_number=phrase# cl:cl_txt=clause_txt=txt,cl_typ=clause_typ=type-cl,cl_rela=clause_rela=rela,cl_tab=clause_atom_tab=tab,cl_par=clause_atom_pargr=par,cl_code=clause_atom_code=code,cl_an=clause_atom_number=clause_a#,cl_n=clause_number=clause# sn:sn_an=sentence_atom_number=sentence_a#,sn_n=sentence_number=sentence# \"\"\" ) . strip () . split () ) featureLines = [] for item in featureFieldSpec : ( line , fieldSpec ) = item . split ( \":\" ) fields = [ x . split ( \"=\" ) for x in fieldSpec . split ( \",\" )] featureLines . append (( line , tuple ( fields ))) itemStyle = dict ( q = dict ( prop = \"background-color\" , default = \"grey\" , off = \"white\" , subtract = 250 , T = \"Q\" , t = \"q\" , Tag = \"Query\" , tag = \"query\" , Tags = \"Queries\" , tags = \"queries\" , ), w = dict ( prop = \"color\" , default = \"gray\" , off = \"black\" , subtract = 250 , T = \"W\" , t = \"w\" , Tag = \"Word\" , tag = \"word\" , Tags = \"Words\" , tags = \"words\" , ), n = dict ( subtract = 250 , T = \"N\" , t = \"n\" , Tag = \"Note\" , tag = \"note\" , Tags = \"Notes\" , tags = \"notes\" , ), m = dict ( subtract = 250 , T = \"I\" , t = \"i\" , Tag = \"Item\" , tag = \"item\" , Tags = \"Items\" , tags = \"items\" , ), ) txtTbs = \",\" . join ( f \"txt { t } \" for t in range ( 1 , nTabViews + 1 )) trLabs = \",\" . join ( trLabels ) specs = dict ( material = ( \"\"\"version book chapter verse iid page mr qw tp tr lang\"\"\" , ( \"\"\"alnum:10 alnum:30 int:1-150 int:1-200 base64:1024 \"\"\" f \"\"\"int:1-1000000 enum:m,r enum:q,w,n enum:txtp, { txtTbs } ,txtd \"\"\" f \"\"\"enum: { trLabs } enum: { BK_NAMES } \"\"\" ), { \"\" : \"\"\"2021 Genesis 1 1 None 1 m x txtp hb en\"\"\" }, ), hebrewdata = ( dedent ( \"\"\" ht ht_ht ht_hk pt hl hl_hlv hl_hlc tt tl tl_tlv tl_tlc gl wd1 wd1_nmtp wd1_subpos wd1_pos wd1_pdp wd1_lang wd1_n wd2 wd2_gender wd2_gnumber wd2_person wd2_state wd2_tense wd2_stem wd3 wd3_nme wd3_pfm wd3_prs wd3_uvf wd3_vbe wd3_vbs wd4 wd4_statfl wd4_statrl wd4_statfo wd4_statro sp sp_rela sp_n ph ph_det ph_fun ph_typ ph_rela ph_arela ph_an ph_n cl cl_txt cl_typ cl_rela cl_tab cl_par cl_code cl_an cl_n sn sn_an sn_n \"\"\" ), dedent ( \"\"\" bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool bool \"\"\" ), { \"\" : dedent ( \"\"\" v v v v v v x v x x x v v v x v x x x v v v v v v v x x x v x v x v v v x x v v v v v v x x v v v v v v v v v v v v v v v \"\"\" ) }, ), highlights = ( \"\"\"get active sel_one pub\"\"\" , \"\"\"bool enum:hloff,hlone,hlcustom,hlmany enum:color bool\"\"\" , dict ( q = \"x hlcustom grey x\" , w = \"x hlcustom gray x\" , n = \"x hlcustom black v\" ), ), colormap = ( \"0\" , \"\"\"enum:color\"\"\" , dict ( q = \"white\" , w = \"black\" ), ), rest = ( \"\"\"pref lan letter extra\"\"\" , \"\"\"alnum:30 enum:hbo,arc int:1-100000 alnum:64\"\"\" , { \"\" : \"\"\"my hbo 1488 None\"\"\" }, ), ) self . nColorRows = nColorRows self . nColorCols = nColorCols self . nDefaultClrRows = nDefaultClrRows self . nDefaultClrCols = nDefaultClrCols self . colorsDefault = colorsDefault self . colorSpecCls = colorSpecCls self . colorNames = colorNames self . colors = colors self . nTabViews = nTabViews self . tabInfo = tabInfo self . tabLabels = tabLabels self . trInfo = trInfo self . trLabels = trLabels self . nextTp = nextTp self . nextTr = nextTr self . noteStatusCls = noteStatusCls self . noteStatusSym = noteStatusSym self . noteStatusNxt = noteStatusNxt self . featureFields = featureFields self . featureLines = featureLines self . itemStyle = itemStyle self . specs = specs self . setupValidation ()","title":"__init__()"},{"location":"server/bymodule/viewdefs/#viewdefs.Make.setupValidation","text":"Source code in modules/viewdefs.py def setupValidation ( self ): specs = self . specs settings = collections . defaultdict ( lambda : collections . defaultdict ( lambda : {})) validation = collections . defaultdict ( lambda : collections . defaultdict ( lambda : {}) ) for group in specs : ( flds , types , init ) = specs [ group ] flds = flds . strip () . split () types = types . strip () . split () valtype = [ self . compileValues ( tp ) for tp in types ] for qw in init : initK = init [ qw ] . strip () . split () for ( i , f ) in enumerate ( flds ): thisInitK = initK [ i ] if thisInitK == \"None\" : thisInitK = \"\" settings [ group ][ qw ][ f ] = thisInitK validation [ group ][ qw ][ f ] = valtype [ i ] self . settings = settings self . validation = validation","title":"setupValidation()"},{"location":"server/bymodule/viewdefs/#viewdefs.Make.compileValues","text":"Source code in modules/viewdefs.py def compileValues ( self , tp ): colors = self . colors if tp == \"bool\" : return lambda d , x : x if x in { \"x\" , \"v\" } else d ( t , v ) = tp . split ( \":\" ) if t == \"alnum\" : return ( lambda d , x : x if x is not None and len ( str ( x )) < int ( v ) and str ( x ) . replace ( \"_\" , \"\" ) . replace ( \" \" , \"\" ) . isalnum () else d ) elif t == \"base64\" : return ( lambda d , x : d if x is None else x if ( type ( x ) is str or type ( x ) is str ) and len ( x ) < int ( v ) and x . replace ( \"_\" , \"\" ) . isalnum () else d ) elif t == \"int\" : ( lowest , highest ) = v . split ( \"-\" ) return ( lambda d , x : int ( x ) if x is not None and str ( x ) . isdigit () and int ( x ) >= int ( lowest ) and int ( x ) <= int ( highest ) else int ( d ) if d is not None else d ) elif t == \"enum\" : vals = set ( colors . keys ()) if v == \"color\" else set ( v . split ( \",\" )) return lambda d , x : x if x is not None and x in vals else d","title":"compileValues()"},{"location":"server/bymodule/viewdefs/#viewdefs.Make.export","text":"Source code in modules/viewdefs.py def export ( self ): return { key : getattr ( self , key ) for key in dedent ( \"\"\" nColorRows nColorCols nDefaultClrRows nDefaultClrCols colorsDefault colorSpecCls colorNames colors nTabViews tabInfo tabLabels trInfo trLabels nextTp nextTr noteStatusCls noteStatusSym noteStatusNxt featureFields featureLines itemStyle specs settings validation \"\"\" ) . strip () . split () }","title":"export()"},{"location":"server/bymodule/viewdefs/#viewdefs.VIEWDEFS","text":"","title":"VIEWDEFS"},{"location":"server/bymodule/viewdefs/#viewdefs.VIEWDEFS.__init__","text":"Source code in modules/viewdefs.py def __init__ ( self ): Caching = current . Caching def make (): makeObj = Make () return makeObj . export () keyValues = Caching . get ( \"viewsettings_\" , make , ALWAYS ) for ( key , value ) in keyValues . items (): setattr ( self , key , value )","title":"__init__()"},{"location":"server/bymodule/viewdefs/#viewdefs.VIEWDEFS.colorPicker","text":"Source code in modules/viewdefs.py def colorPicker ( self , qw , iid , typ ): return f \" { self . selectColor ( qw , iid , typ ) }{ self . colorTable ( qw , iid ) } \\n \"","title":"colorPicker()"},{"location":"server/bymodule/viewdefs/#viewdefs.VIEWDEFS.makeColors","text":"Source code in modules/viewdefs.py def makeColors ( self ): colorSpecCls = self . colorSpecCls colorProtoCls = [ tuple ( spec . split ( \",\" )) for spec in colorSpecCls . strip () . split () ] colorsCls = [] lPrev = 0 for ( l , z ) in colorProtoCls : lNew = int ( l ) + 1 for i in range ( lPrev , lNew ): colorsCls . append ( z ) lPrev = lNew return colorsCls","title":"makeColors()"},{"location":"server/bymodule/viewdefs/#viewdefs.VIEWDEFS.colorTable","text":"Source code in modules/viewdefs.py def colorTable ( self , qw , iid ): nColorRows = self . nColorRows cs = \" \\n \" . join ( self . colorRow ( qw , iid , r ) for r in range ( nColorRows )) return f '<table class=\"picker\" id=\"picker_ { qw }{ iid } \"> \\n { cs } \\n </table> \\n '","title":"colorTable()"},{"location":"server/bymodule/viewdefs/#viewdefs.VIEWDEFS.colorRow","text":"Source code in modules/viewdefs.py def colorRow ( self , qw , iid , r ): nColorCols = self . nColorCols cells = \" \\n \" . join ( self . colorCell ( qw , iid , c ) for c in range ( r * nColorCols , ( r + 1 ) * nColorCols ) ) return f \" \\t <tr> \\n { cells } \\n\\t </tr>\"","title":"colorRow()"},{"location":"server/bymodule/viewdefs/#viewdefs.VIEWDEFS.colorCell","text":"Source code in modules/viewdefs.py def colorCell ( self , qw , iid , c ): colorNames = self . colorNames return ( f \"\"\" \\t\\t <td class=\"c { qw } { qw }{ iid } \"><a href=\"#\"> { colorNames [ c ] } </a></td>\"\"\" )","title":"colorCell()"},{"location":"server/bymodule/viewdefs/#viewdefs.VIEWDEFS.selectColor","text":"Source code in modules/viewdefs.py def selectColor ( self , qw , iid , typ ): content = \"&nbsp;\" if qw == \"q\" else \"w\" selCtl = ( \"\" if typ else f \"\"\"<span class=\"pickedc\" ><input type=\"checkbox\" id=\"select_ { qw }{ iid } \" name=\"select_ { qw }{ iid } \" /></span>&nbsp;\"\"\" ) sel = f \"\"\"<span class=\"picked colorselect_ { qw } \" id=\"sel_ { qw }{ iid } \" ><a href=\"#\"> { content } </a></span>\"\"\" return selCtl + sel","title":"selectColor()"},{"location":"server/bymodule/viewsettings/","text":"viewsettings \u00b6 VIEWSETTINGS \u00b6 Handles the settings that customize the look and feel on the page. In fact, all parameters that originate from the user are treated here. They are stored in local storage in the browser, to when a page is loaded, these stored settings will be merged with the incoming request variables, and the outcome of that will again be stored in LocalStorage. __init__ ( self , Books ) special \u00b6 Source code in modules/viewsettings.py def __init__ ( self , Books ): self . Books = Books Check = current . Check self . state = collections . defaultdict ( lambda : collections . defaultdict ( lambda : {}) ) self . pref = Check . field ( \"rest\" , \"\" , \"pref\" ) page ( self ) \u00b6 Determines all settings and writes them out to Javascript. This is the start of rendering a page. At the client, the Javascript picks up the data and uses it to customise the view. Client code: {viewstate} Source code in modules/viewsettings.py def page ( self ): \"\"\"Determines all settings and writes them out to Javascript. This is the start of rendering a page. At the client, the Javascript picks up the data and uses it to customise the view. Client code: [{viewstate}][viewstate] \"\"\" ViewDefs = current . ViewDefs pageConfig = self . writeConfig () return dict ( pageConfig = pageConfig , colorPicker = ViewDefs . colorPicker , legend = LEGEND , tabLabels = ViewDefs . tabLabels , trLabels = ViewDefs . trLabels , nTabViews = ViewDefs . nTabViews , trInfo = ViewDefs . trInfo , ) initState ( self ) \u00b6 Source code in modules/viewsettings.py def initState ( self ): Books = self . Books ViewDefs = current . ViewDefs Check = current . Check VERSIONS = current . VERSIONS settings = ViewDefs . settings validation = ViewDefs . validation requestVars = current . request . vars requestCookies = current . request . cookies responseCookies = current . response . cookies for ( group , groupSettings ) in settings . items (): self . state [ group ] = {} for qw in groupSettings : self . state [ group ][ qw ] = {} fromCookie = {} if ( self . pref + group + qw ) in requestCookies : if self . pref == \"my\" : try : fromCookie = json . loads ( urllib . parse . unquote ( requestCookies [ self . pref + group + qw ] . value ) ) except ValueError : pass if group == \"colormap\" : for fid in fromCookie : if len ( fid ) <= 32 and fid . replace ( \"_\" , \"\" ) . isalnum (): validationState = validation [ group ][ qw ][ \"0\" ]( None , fromCookie [ fid ] ) if validationState is not None : self . state [ group ][ qw ][ fid ] = validationState for f in requestVars : if not f . startswith ( f \"c_ { qw } \" ): continue fid = f [ 3 :] if len ( fid ) <= 32 and fid . replace ( \"_\" , \"\" ) . isalnum (): validationState = Check . field ( group , qw , fid , default = False ) if validationState is not None : fromCookie [ fid ] = validationState self . state [ group ][ qw ][ fid ] = validationState elif group != \"rest\" : for f in settings [ group ][ qw ]: init = settings [ group ][ qw ][ f ] validationState = validation [ group ][ qw ][ f ]( init , fromCookie . get ( f , None ) ) vstater = Check . field ( group , qw , f , default = False ) if vstater is not None : validationState = vstater fromCookie [ f ] = validationState self . state [ group ][ qw ][ f ] = validationState if group != \"rest\" : responseCookies [ self . pref + group + qw ] = urllib . parse . quote ( json . dumps ( fromCookie ) ) responseCookies [ self . pref + group + qw ][ \"expires\" ] = 30 * 24 * 3600 responseCookies [ self . pref + group + qw ][ \"path\" ] = \"/\" books = {} booksOrder = {} bookIds = {} bookName = {} self . books = books self . booksOrder = booksOrder self . bookIds = bookIds self . bookName = bookName for v in VERSIONS : ( books [ v ], booksOrder [ v ], bookIds [ v ], bookName [ v ]) = Books . get ( v ) currentVersion ( self ) \u00b6 Return the current version. This is the version as determined by the latest request. See \u2208 version . Source code in modules/viewsettings.py def currentVersion ( self ): \"\"\"Return the current version. This is the version as determined by the latest request. See [\u2208 version][elem-version]. \"\"\" return self . state [ \"material\" ][ \"\" ][ \"version\" ] writeConfig ( self ) \u00b6 Source code in modules/viewsettings.py def writeConfig ( self ): ViewDefs = current . ViewDefs URL = current . URL VERSIONS = current . VERSIONS return dedent ( f \"\"\" var Config = {{ bookLangs: { json . dumps ( BOOK_LANGS [ BIBLANG ]) } , bookLatin: { json . dumps ( BOOK_NAMES [ BIBLANG ][ \"la\" ]) } , bookOrder: { json . dumps ( self . booksOrder ) } , books: { json . dumps ( self . books ) } , bookTrans: { json . dumps ( BOOK_TRANS ) } , colorsDefault: { json . dumps ( ViewDefs . colorsDefault ) } , colorsCls: { json . dumps ( ViewDefs . makeColors ()) } , colors: { json . dumps ( ViewDefs . colors ) } , nDefaultClrCols: { ViewDefs . nDefaultClrCols } , nDefaultClrRows: { ViewDefs . nDefaultClrRows } , featureHost: \"https://etcbc.github.io/bhsa/features\", nextTp: { json . dumps ( ViewDefs . nextTp ) } , nextTr: { json . dumps ( ViewDefs . nextTr ) } , noteStatusCls: { json . dumps ( ViewDefs . noteStatusCls ) } , noteStatusNxt: { json . dumps ( ViewDefs . noteStatusNxt ) } , noteStatusSym: { json . dumps ( ViewDefs . noteStatusSym ) } , pref: \" { self . pref } \", itemStyle: { json . dumps ( ViewDefs . itemStyle ) } , nTabViews: { ViewDefs . nTabViews } , tabInfo: { json . dumps ( ViewDefs . tabInfo ) } , tabLabels: { json . dumps ( ViewDefs . tabLabels ) } , trInfo: { json . dumps ( ViewDefs . trInfo ) } , trLabels: { json . dumps ( ViewDefs . trLabels ) } , versions: { json . dumps ( list ( VERSIONS )) } , viewInit: { json . dumps ( self . state ) } , pageShareUrl: \" { URL ( \"hebrew\" , \"text\" , host = True ) } \", wordShareUrl: \" { URL ( \"hebrew\" , \"word\" , host = True ) } \", queryShareUrl: \" { URL ( \"hebrew\" , \"query\" , host = True ) } \", noteShareUrl: \" { URL ( \"hebrew\" , \"note\" , host = True ) } \", pageUrl: \" { URL ( \"hebrew\" , \"text\" ) } \", pageMaterialUrl: \" { URL ( \"hebrew\" , \"material\" ) } \", pageSidebarUrl: \" { URL ( \"hebrew\" , \"side\" ) } \", verseFeaturesUrl: \" { URL ( \"hebrew\" , \"verse\" ) } \", wordsPageUrl: \" { URL ( \"hebrew\" , \"words\" ) } \", queriesPageUrl: \" { URL ( \"hebrew\" , \"queries\" ) } \", notesPageUrl: \" { URL ( \"hebrew\" , \"notes\" ) } \", queryTreeJsonUrl: \" { URL ( \"hebrew\" , \"querytree.json\" ) } \", noteTreeJsonUrl: \" { URL ( \"hebrew\" , \"notetree.json\" ) } \", queriesRecentJsonUrl: \" { URL ( \"hebrew\" , \"queriesr.json\" ) } \", queryUpdateJsonUrl: \" { URL ( \"hebrew\" , \"queryupdate.json\" ) } \", querySharingJsonUrl: \" { URL ( \"hebrew\" , \"querysharing.json\" ) } \", getNotesVerseJsonUrl: \" { URL ( \"hebrew\" , \"getversenotes.json\" ) } \", putNotesVerseJsonUrl: \" { URL ( \"hebrew\" , \"putversenotes.json\" ) } \", noteUploadJsonUrl: \" { URL ( \"hebrew\" , \"noteupload.json\" ) } \", itemRecordJsonUrl: \" { URL ( \"hebrew\" , \"itemrecord.json\" ) } \", chartUrl: \" { URL ( \"hebrew\" , \"chart\" ) } \", itemCsvUrl: \" { URL ( \"hebrew\" , \"item.csv\" ) } \", bolUrl: \"http://bibleol.3bmoodle.dk/text/show_text\", pblUrl: \"https://parabible.com\", }} \"\"\" )","title":"Viewsettings"},{"location":"server/bymodule/viewsettings/#viewsettings","text":"","title":"viewsettings"},{"location":"server/bymodule/viewsettings/#viewsettings.VIEWSETTINGS","text":"Handles the settings that customize the look and feel on the page. In fact, all parameters that originate from the user are treated here. They are stored in local storage in the browser, to when a page is loaded, these stored settings will be merged with the incoming request variables, and the outcome of that will again be stored in LocalStorage.","title":"VIEWSETTINGS"},{"location":"server/bymodule/viewsettings/#viewsettings.VIEWSETTINGS.__init__","text":"Source code in modules/viewsettings.py def __init__ ( self , Books ): self . Books = Books Check = current . Check self . state = collections . defaultdict ( lambda : collections . defaultdict ( lambda : {}) ) self . pref = Check . field ( \"rest\" , \"\" , \"pref\" )","title":"__init__()"},{"location":"server/bymodule/viewsettings/#viewsettings.VIEWSETTINGS.page","text":"Determines all settings and writes them out to Javascript. This is the start of rendering a page. At the client, the Javascript picks up the data and uses it to customise the view. Client code: {viewstate} Source code in modules/viewsettings.py def page ( self ): \"\"\"Determines all settings and writes them out to Javascript. This is the start of rendering a page. At the client, the Javascript picks up the data and uses it to customise the view. Client code: [{viewstate}][viewstate] \"\"\" ViewDefs = current . ViewDefs pageConfig = self . writeConfig () return dict ( pageConfig = pageConfig , colorPicker = ViewDefs . colorPicker , legend = LEGEND , tabLabels = ViewDefs . tabLabels , trLabels = ViewDefs . trLabels , nTabViews = ViewDefs . nTabViews , trInfo = ViewDefs . trInfo , )","title":"page()"},{"location":"server/bymodule/viewsettings/#viewsettings.VIEWSETTINGS.initState","text":"Source code in modules/viewsettings.py def initState ( self ): Books = self . Books ViewDefs = current . ViewDefs Check = current . Check VERSIONS = current . VERSIONS settings = ViewDefs . settings validation = ViewDefs . validation requestVars = current . request . vars requestCookies = current . request . cookies responseCookies = current . response . cookies for ( group , groupSettings ) in settings . items (): self . state [ group ] = {} for qw in groupSettings : self . state [ group ][ qw ] = {} fromCookie = {} if ( self . pref + group + qw ) in requestCookies : if self . pref == \"my\" : try : fromCookie = json . loads ( urllib . parse . unquote ( requestCookies [ self . pref + group + qw ] . value ) ) except ValueError : pass if group == \"colormap\" : for fid in fromCookie : if len ( fid ) <= 32 and fid . replace ( \"_\" , \"\" ) . isalnum (): validationState = validation [ group ][ qw ][ \"0\" ]( None , fromCookie [ fid ] ) if validationState is not None : self . state [ group ][ qw ][ fid ] = validationState for f in requestVars : if not f . startswith ( f \"c_ { qw } \" ): continue fid = f [ 3 :] if len ( fid ) <= 32 and fid . replace ( \"_\" , \"\" ) . isalnum (): validationState = Check . field ( group , qw , fid , default = False ) if validationState is not None : fromCookie [ fid ] = validationState self . state [ group ][ qw ][ fid ] = validationState elif group != \"rest\" : for f in settings [ group ][ qw ]: init = settings [ group ][ qw ][ f ] validationState = validation [ group ][ qw ][ f ]( init , fromCookie . get ( f , None ) ) vstater = Check . field ( group , qw , f , default = False ) if vstater is not None : validationState = vstater fromCookie [ f ] = validationState self . state [ group ][ qw ][ f ] = validationState if group != \"rest\" : responseCookies [ self . pref + group + qw ] = urllib . parse . quote ( json . dumps ( fromCookie ) ) responseCookies [ self . pref + group + qw ][ \"expires\" ] = 30 * 24 * 3600 responseCookies [ self . pref + group + qw ][ \"path\" ] = \"/\" books = {} booksOrder = {} bookIds = {} bookName = {} self . books = books self . booksOrder = booksOrder self . bookIds = bookIds self . bookName = bookName for v in VERSIONS : ( books [ v ], booksOrder [ v ], bookIds [ v ], bookName [ v ]) = Books . get ( v )","title":"initState()"},{"location":"server/bymodule/viewsettings/#viewsettings.VIEWSETTINGS.currentVersion","text":"Return the current version. This is the version as determined by the latest request. See \u2208 version . Source code in modules/viewsettings.py def currentVersion ( self ): \"\"\"Return the current version. This is the version as determined by the latest request. See [\u2208 version][elem-version]. \"\"\" return self . state [ \"material\" ][ \"\" ][ \"version\" ]","title":"currentVersion()"},{"location":"server/bymodule/viewsettings/#viewsettings.VIEWSETTINGS.writeConfig","text":"Source code in modules/viewsettings.py def writeConfig ( self ): ViewDefs = current . ViewDefs URL = current . URL VERSIONS = current . VERSIONS return dedent ( f \"\"\" var Config = {{ bookLangs: { json . dumps ( BOOK_LANGS [ BIBLANG ]) } , bookLatin: { json . dumps ( BOOK_NAMES [ BIBLANG ][ \"la\" ]) } , bookOrder: { json . dumps ( self . booksOrder ) } , books: { json . dumps ( self . books ) } , bookTrans: { json . dumps ( BOOK_TRANS ) } , colorsDefault: { json . dumps ( ViewDefs . colorsDefault ) } , colorsCls: { json . dumps ( ViewDefs . makeColors ()) } , colors: { json . dumps ( ViewDefs . colors ) } , nDefaultClrCols: { ViewDefs . nDefaultClrCols } , nDefaultClrRows: { ViewDefs . nDefaultClrRows } , featureHost: \"https://etcbc.github.io/bhsa/features\", nextTp: { json . dumps ( ViewDefs . nextTp ) } , nextTr: { json . dumps ( ViewDefs . nextTr ) } , noteStatusCls: { json . dumps ( ViewDefs . noteStatusCls ) } , noteStatusNxt: { json . dumps ( ViewDefs . noteStatusNxt ) } , noteStatusSym: { json . dumps ( ViewDefs . noteStatusSym ) } , pref: \" { self . pref } \", itemStyle: { json . dumps ( ViewDefs . itemStyle ) } , nTabViews: { ViewDefs . nTabViews } , tabInfo: { json . dumps ( ViewDefs . tabInfo ) } , tabLabels: { json . dumps ( ViewDefs . tabLabels ) } , trInfo: { json . dumps ( ViewDefs . trInfo ) } , trLabels: { json . dumps ( ViewDefs . trLabels ) } , versions: { json . dumps ( list ( VERSIONS )) } , viewInit: { json . dumps ( self . state ) } , pageShareUrl: \" { URL ( \"hebrew\" , \"text\" , host = True ) } \", wordShareUrl: \" { URL ( \"hebrew\" , \"word\" , host = True ) } \", queryShareUrl: \" { URL ( \"hebrew\" , \"query\" , host = True ) } \", noteShareUrl: \" { URL ( \"hebrew\" , \"note\" , host = True ) } \", pageUrl: \" { URL ( \"hebrew\" , \"text\" ) } \", pageMaterialUrl: \" { URL ( \"hebrew\" , \"material\" ) } \", pageSidebarUrl: \" { URL ( \"hebrew\" , \"side\" ) } \", verseFeaturesUrl: \" { URL ( \"hebrew\" , \"verse\" ) } \", wordsPageUrl: \" { URL ( \"hebrew\" , \"words\" ) } \", queriesPageUrl: \" { URL ( \"hebrew\" , \"queries\" ) } \", notesPageUrl: \" { URL ( \"hebrew\" , \"notes\" ) } \", queryTreeJsonUrl: \" { URL ( \"hebrew\" , \"querytree.json\" ) } \", noteTreeJsonUrl: \" { URL ( \"hebrew\" , \"notetree.json\" ) } \", queriesRecentJsonUrl: \" { URL ( \"hebrew\" , \"queriesr.json\" ) } \", queryUpdateJsonUrl: \" { URL ( \"hebrew\" , \"queryupdate.json\" ) } \", querySharingJsonUrl: \" { URL ( \"hebrew\" , \"querysharing.json\" ) } \", getNotesVerseJsonUrl: \" { URL ( \"hebrew\" , \"getversenotes.json\" ) } \", putNotesVerseJsonUrl: \" { URL ( \"hebrew\" , \"putversenotes.json\" ) } \", noteUploadJsonUrl: \" { URL ( \"hebrew\" , \"noteupload.json\" ) } \", itemRecordJsonUrl: \" { URL ( \"hebrew\" , \"itemrecord.json\" ) } \", chartUrl: \" { URL ( \"hebrew\" , \"chart\" ) } \", itemCsvUrl: \" { URL ( \"hebrew\" , \"item.csv\" ) } \", bolUrl: \"http://bibleol.3bmoodle.dk/text/show_text\", pblUrl: \"https://parabible.com\", }} \"\"\" )","title":"writeConfig()"},{"location":"server/bymodule/word/","text":"word \u00b6 WORD \u00b6 __init__ ( self ) special \u00b6 Source code in modules/word.py def __init__ ( self ): pass authRead ( self , vr , lexicon_id ) \u00b6 Source code in modules/word.py def authRead ( self , vr , lexicon_id ): PASSAGE_DBS = current . PASSAGE_DBS authorized = None if not lexicon_id or vr not in PASSAGE_DBS : authorized = False else : wordRecord = self . getPlainInfo ( vr , lexicon_id ) if wordRecord : authorized = True msg = ( f \"No word with id { lexicon_id } \" if authorized is None else f \"No data version { vr } \" if vr not in PASSAGE_DBS else \"\" ) return ( authorized , msg ) page ( self , ViewSettings ) \u00b6 Source code in modules/word.py def page ( self , ViewSettings ): Check = current . Check Caching = current . Caching pageConfig = ViewSettings . writeConfig () vr = Check . field ( \"material\" , \"\" , \"version\" , default = False ) if not vr : vr = ViewSettings . currentVersion () lan = Check . field ( \"rest\" , \"\" , \"lan\" ) letter = Check . field ( \"rest\" , \"\" , \"letter\" ) return Caching . get ( f \"words_page_ { vr } _ { lan } _ { letter } _\" , lambda : self . page_c ( pageConfig , vr , lan = lan , letter = letter ), ALWAYS , ) page_c ( self , pageConfig , vr , lan = None , letter = None ) \u00b6 Source code in modules/word.py def page_c ( self , pageConfig , vr , lan = None , letter = None ): Caching = current . Caching ( letters , words ) = Caching . get ( f \"words_data_ { vr } _\" , lambda : self . getData ( vr ), ALWAYS ) return dict ( version = vr , pageConfig = pageConfig , lan = lan , letter = letter , letters = letters , words = words . get ( lan , {}) . get ( letter , []), ) body ( self ) \u00b6 Retrieves a query word based on parameters. Source code in modules/word.py def body ( self ): \"\"\"Retrieves a query word based on parameters. \"\"\" Check = current . Check vr = Check . field ( \"material\" , \"\" , \"version\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) ( iid , keywords ) = iDecode ( \"w\" , iidRep ) ( authorized , msg ) = self . authRead ( vr , iid ) msgs = [] if not authorized : msgs . append (( \"error\" , msg )) return dict ( wordRecord = dict (), word = json . dumps ( dict ()), msgs = json . dumps ( msgs ), ) wordRecord = self . getInfo ( iid , vr , msgs ) return dict ( vr = vr , wordRecord = wordRecord , word = json . dumps ( wordRecord ), msgs = json . dumps ( msgs ), ) getItems ( self , vr , chapter ) \u00b6 Source code in modules/word.py def getItems ( self , vr , chapter ): PASSAGE_DBS = current . PASSAGE_DBS if vr not in PASSAGE_DBS : return [] occurrences = PASSAGE_DBS [ vr ] . executesql ( dedent ( f \"\"\" select anchor, lexicon_id from word_verse where anchor BETWEEN { chapter [ \"first_m\" ] } AND { chapter [ \"last_m\" ] } ; \"\"\" ) ) lexemes = collections . defaultdict ( lambda : []) for ( slot , lexicon_id ) in occurrences : lexemes [ lexicon_id ] . append ( slot ) r = [] if len ( lexemes ): lexiconIdsRep = \",\" . join ( f \"' { lexicon_id } '\" for lexicon_id in lexemes ) wordSql = dedent ( f \"\"\" select * from lexicon where id in ( { lexiconIdsRep } ) ; \"\"\" ) wordRecords = sorted ( PASSAGE_DBS [ vr ] . executesql ( wordSql , as_dict = True ), key = lambda x : hebKey ( x [ \"entryid_heb\" ]), ) for w in wordRecords : r . append ({ \"item\" : w , \"slots\" : json . dumps ( lexemes [ w [ \"id\" ]])}) return r read ( self , vr , lexicon_id ) \u00b6 Source code in modules/word.py def read ( self , vr , lexicon_id ): PASSAGE_DBS = current . PASSAGE_DBS rows = ( PASSAGE_DBS [ vr ] . executesql ( dedent ( f \"\"\" select anchor from word_verse where lexicon_id = ' { lexicon_id } ' order by anchor ; \"\"\" ) ) if vr in PASSAGE_DBS else [] ) return collapseToRanges ( row [ 0 ] for row in rows ) getPlainInfo ( self , vr , lexicon_id ) \u00b6 Source code in modules/word.py def getPlainInfo ( self , vr , lexicon_id ): PASSAGE_DBS = current . PASSAGE_DBS if vr not in PASSAGE_DBS : return {} records = PASSAGE_DBS [ vr ] . executesql ( dedent ( f \"\"\" select * from lexicon where id = ' { lexicon_id } ' ; \"\"\" ), as_dict = True , ) return records [ 0 ] if records else {} getInfo ( self , iid , vr , msgs ) \u00b6 Source code in modules/word.py def getInfo ( self , iid , vr , msgs ): PASSAGE_DBS = current . PASSAGE_DBS VERSIONS = current . VERSIONS sql = dedent ( f \"\"\" select * from lexicon where id = ' { iid } ' ; \"\"\" ) wordRecord = dict ( id = iid , versions = {}) for v in VERSIONS : records = PASSAGE_DBS [ v ] . executesql ( sql , as_dict = True ) if records is None : msgs . append ( ( \"error\" , f \"Cannot lookup word with id { iid } in version { v } \" ) ) elif len ( records ) == 0 : msgs . append (( \"warning\" , f \"No word with id { iid } in version { v } \" )) else : wordRecord [ \"versions\" ][ v ] = records [ 0 ] return wordRecord getData ( self , vr ) \u00b6 Source code in modules/word.py def getData ( self , vr ): PASSAGE_DBS = current . PASSAGE_DBS if vr not in PASSAGE_DBS : return ({}, {}) hebrewData = sorted ( PASSAGE_DBS [ vr ] . executesql ( dedent ( \"\"\" select id, entry_heb, entryid_heb, lan, gloss from lexicon ; \"\"\" ) ), key = lambda x : ( x [ 3 ], hebKey ( x [ 2 ])), ) letters = dict ( arc = [], hbo = []) words = dict ( arc = {}, hbo = {}) for ( wid , e , eid , lan , gloss ) in hebrewData : letter = ord ( e [ 0 ]) if letter not in words [ lan ]: letters [ lan ] . append ( letter ) words [ lan ][ letter ] = [] words [ lan ][ letter ] . append (( e , wid , eid , gloss )) return ( letters , words )","title":"Word"},{"location":"server/bymodule/word/#word","text":"","title":"word"},{"location":"server/bymodule/word/#word.WORD","text":"","title":"WORD"},{"location":"server/bymodule/word/#word.WORD.__init__","text":"Source code in modules/word.py def __init__ ( self ): pass","title":"__init__()"},{"location":"server/bymodule/word/#word.WORD.authRead","text":"Source code in modules/word.py def authRead ( self , vr , lexicon_id ): PASSAGE_DBS = current . PASSAGE_DBS authorized = None if not lexicon_id or vr not in PASSAGE_DBS : authorized = False else : wordRecord = self . getPlainInfo ( vr , lexicon_id ) if wordRecord : authorized = True msg = ( f \"No word with id { lexicon_id } \" if authorized is None else f \"No data version { vr } \" if vr not in PASSAGE_DBS else \"\" ) return ( authorized , msg )","title":"authRead()"},{"location":"server/bymodule/word/#word.WORD.page","text":"Source code in modules/word.py def page ( self , ViewSettings ): Check = current . Check Caching = current . Caching pageConfig = ViewSettings . writeConfig () vr = Check . field ( \"material\" , \"\" , \"version\" , default = False ) if not vr : vr = ViewSettings . currentVersion () lan = Check . field ( \"rest\" , \"\" , \"lan\" ) letter = Check . field ( \"rest\" , \"\" , \"letter\" ) return Caching . get ( f \"words_page_ { vr } _ { lan } _ { letter } _\" , lambda : self . page_c ( pageConfig , vr , lan = lan , letter = letter ), ALWAYS , )","title":"page()"},{"location":"server/bymodule/word/#word.WORD.page_c","text":"Source code in modules/word.py def page_c ( self , pageConfig , vr , lan = None , letter = None ): Caching = current . Caching ( letters , words ) = Caching . get ( f \"words_data_ { vr } _\" , lambda : self . getData ( vr ), ALWAYS ) return dict ( version = vr , pageConfig = pageConfig , lan = lan , letter = letter , letters = letters , words = words . get ( lan , {}) . get ( letter , []), )","title":"page_c()"},{"location":"server/bymodule/word/#word.WORD.body","text":"Retrieves a query word based on parameters. Source code in modules/word.py def body ( self ): \"\"\"Retrieves a query word based on parameters. \"\"\" Check = current . Check vr = Check . field ( \"material\" , \"\" , \"version\" ) iidRep = Check . field ( \"material\" , \"\" , \"iid\" ) ( iid , keywords ) = iDecode ( \"w\" , iidRep ) ( authorized , msg ) = self . authRead ( vr , iid ) msgs = [] if not authorized : msgs . append (( \"error\" , msg )) return dict ( wordRecord = dict (), word = json . dumps ( dict ()), msgs = json . dumps ( msgs ), ) wordRecord = self . getInfo ( iid , vr , msgs ) return dict ( vr = vr , wordRecord = wordRecord , word = json . dumps ( wordRecord ), msgs = json . dumps ( msgs ), )","title":"body()"},{"location":"server/bymodule/word/#word.WORD.getItems","text":"Source code in modules/word.py def getItems ( self , vr , chapter ): PASSAGE_DBS = current . PASSAGE_DBS if vr not in PASSAGE_DBS : return [] occurrences = PASSAGE_DBS [ vr ] . executesql ( dedent ( f \"\"\" select anchor, lexicon_id from word_verse where anchor BETWEEN { chapter [ \"first_m\" ] } AND { chapter [ \"last_m\" ] } ; \"\"\" ) ) lexemes = collections . defaultdict ( lambda : []) for ( slot , lexicon_id ) in occurrences : lexemes [ lexicon_id ] . append ( slot ) r = [] if len ( lexemes ): lexiconIdsRep = \",\" . join ( f \"' { lexicon_id } '\" for lexicon_id in lexemes ) wordSql = dedent ( f \"\"\" select * from lexicon where id in ( { lexiconIdsRep } ) ; \"\"\" ) wordRecords = sorted ( PASSAGE_DBS [ vr ] . executesql ( wordSql , as_dict = True ), key = lambda x : hebKey ( x [ \"entryid_heb\" ]), ) for w in wordRecords : r . append ({ \"item\" : w , \"slots\" : json . dumps ( lexemes [ w [ \"id\" ]])}) return r","title":"getItems()"},{"location":"server/bymodule/word/#word.WORD.read","text":"Source code in modules/word.py def read ( self , vr , lexicon_id ): PASSAGE_DBS = current . PASSAGE_DBS rows = ( PASSAGE_DBS [ vr ] . executesql ( dedent ( f \"\"\" select anchor from word_verse where lexicon_id = ' { lexicon_id } ' order by anchor ; \"\"\" ) ) if vr in PASSAGE_DBS else [] ) return collapseToRanges ( row [ 0 ] for row in rows )","title":"read()"},{"location":"server/bymodule/word/#word.WORD.getPlainInfo","text":"Source code in modules/word.py def getPlainInfo ( self , vr , lexicon_id ): PASSAGE_DBS = current . PASSAGE_DBS if vr not in PASSAGE_DBS : return {} records = PASSAGE_DBS [ vr ] . executesql ( dedent ( f \"\"\" select * from lexicon where id = ' { lexicon_id } ' ; \"\"\" ), as_dict = True , ) return records [ 0 ] if records else {}","title":"getPlainInfo()"},{"location":"server/bymodule/word/#word.WORD.getInfo","text":"Source code in modules/word.py def getInfo ( self , iid , vr , msgs ): PASSAGE_DBS = current . PASSAGE_DBS VERSIONS = current . VERSIONS sql = dedent ( f \"\"\" select * from lexicon where id = ' { iid } ' ; \"\"\" ) wordRecord = dict ( id = iid , versions = {}) for v in VERSIONS : records = PASSAGE_DBS [ v ] . executesql ( sql , as_dict = True ) if records is None : msgs . append ( ( \"error\" , f \"Cannot lookup word with id { iid } in version { v } \" ) ) elif len ( records ) == 0 : msgs . append (( \"warning\" , f \"No word with id { iid } in version { v } \" )) else : wordRecord [ \"versions\" ][ v ] = records [ 0 ] return wordRecord","title":"getInfo()"},{"location":"server/bymodule/word/#word.WORD.getData","text":"Source code in modules/word.py def getData ( self , vr ): PASSAGE_DBS = current . PASSAGE_DBS if vr not in PASSAGE_DBS : return ({}, {}) hebrewData = sorted ( PASSAGE_DBS [ vr ] . executesql ( dedent ( \"\"\" select id, entry_heb, entryid_heb, lan, gloss from lexicon ; \"\"\" ) ), key = lambda x : ( x [ 3 ], hebKey ( x [ 2 ])), ) letters = dict ( arc = [], hbo = []) words = dict ( arc = {}, hbo = {}) for ( wid , e , eid , lan , gloss ) in hebrewData : letter = ord ( e [ 0 ]) if letter not in words [ lan ]: letters [ lan ] . append ( letter ) words [ lan ][ letter ] = [] words [ lan ][ letter ] . append (( e , wid , eid , gloss )) return ( letters , words )","title":"getData()"},{"location":"solutions/bottlenecks/","text":"Bottlenecks \u00b6 The query-chapter index \u00b6 The problem is that in order to present the list of queries that have results in a specific chapter, an expensive SQL statement must be executed. Our work around that is to maintain an index between queries and chapters. That works, the sidebar generation is now crisp. But there are disadvantages: it takes time to compute the index, roughly 30 seconds. It has to be done after every restart. This makes every update of the SHEBANQ code into a disturbance. the index is stored in the cache, the most global place there is. Still, it is local to the current process. So you cannot configure SHEBANQ with more than 1 process. So far, multiple threads compensate for that, but this limitation is not ideal. Idea: store the index in the database as a simple corss-table between queries and chapters, more precisely: queries, versions and chapters. It will overcome both disadvantages. In order to make it work, we need to update the cross table whenever query results change. So we must make sure that saving query results and updating this table happens in one transaction. Also, this will change the datamodel of the shebanq_web database. That means that it will be difficult to restore older backups. We can accomodate that by making new backups immediately.","title":"Bottlenecks"},{"location":"solutions/bottlenecks/#bottlenecks","text":"","title":"Bottlenecks"},{"location":"solutions/bottlenecks/#the-query-chapter-index","text":"The problem is that in order to present the list of queries that have results in a specific chapter, an expensive SQL statement must be executed. Our work around that is to maintain an index between queries and chapters. That works, the sidebar generation is now crisp. But there are disadvantages: it takes time to compute the index, roughly 30 seconds. It has to be done after every restart. This makes every update of the SHEBANQ code into a disturbance. the index is stored in the cache, the most global place there is. Still, it is local to the current process. So you cannot configure SHEBANQ with more than 1 process. So far, multiple threads compensate for that, but this limitation is not ideal. Idea: store the index in the database as a simple corss-table between queries and chapters, more precisely: queries, versions and chapters. It will overcome both disadvantages. In order to make it work, we need to update the cross table whenever query results change. So we must make sure that saving query results and updating this table happens in one transaction. Also, this will change the datamodel of the shebanq_web database. That means that it will be difficult to restore older backups. We can accomodate that by making new backups immediately.","title":"The query-chapter index"},{"location":"solutions/caching/","text":"Caching \u00b6 We use caching to store material that is either frequently used or expensive to compute. We use web2py caching . We do not deliberately manage browser caching. We use the lower-level mechanisms of web2py: cache.ram , and refrain from decorating controllers with @cache or @cache.action , because we have to be selective on which request vars are important for keying the cached items. All caching is triggered via the Model: CACHING object. We cahce in RAM only, but there is a switch by which we could also cache on disk, if we want to keep the cache between restarts of the server. Here is a list of what we cache: the numbers of chapters in each book M: BOOKS.get heatmaps (charts) M: CHART.get and M: CHART.getBlocks chapter records M: MATERIAL.getPassage verse content (the content of verses that occur on a page) M: MATERIAL.get single verse content in specific (re)presentation M: VERSE.get and M: VERSE.getJson verse boundaries for a given set of slots, so that the pagination of result pages can be computed M: MATERIAL.getPagination notes occurrences M: NOTE.read clause atoms per verse M: NOTE.getClauseAtoms M: NOTE.getClauseAtomFirstSlot chapters per query and queries per chapter M: QUERYCHAPTER.makeQCindex and M: QUERYCHAPTER.updateQCindex side material of pages M: SIDE.get definitions of view settings M: VIEWDEFS word pages M: WORD.page We do not cache rendered views, because the views implement tweaks that are dependent on the browser. Note that what the user sees, is the effect of the javascript on the html produced by rendered view. So the cached data only has to be indexed by those request vars that select content: mr, qw, book, chapter, item id (iid) and (result) page. I think this strikes a nice balance: * these chunks of html are equal for all users that visit such a page, regardless of their view settings * these chunks of html are relatively small, only the material of one page. It is tempting to cache the SQL queries, but they fetch large amounts of data, of which only a tiny portion shows up. So it uses a lot of space. If a user examines a query with 1000 pages of results, it is unlikely that (s)he will visit all of them, so it is not worthwhile to keep the results of the one big query in cache all the time. On the other hand, many users look at the first page of query results, and by caching individual pages, the number of times that the big query is exececuted is reduced significantly. There is one exception: looking up the queries that have results in a given chapter is quite expensive. We alleviate that by making an index of queries by chapter and store that in the cache. Time consuming and priority This is time consuming and it has to happen before the website is visited. If pages are served before this index is finished, sidebars maybe incomplete, and yet they will be cached, so they remain incomplete. The update script of SHEBANQ will make a first visit right after the update to counter this. Updating the index When a query gets executed, it should be removed from the index and then added again. Therefore we need to know which chapters are affected. For that we also hold an index from queries to chapters in the cache.","title":"Caching"},{"location":"solutions/caching/#caching","text":"We use caching to store material that is either frequently used or expensive to compute. We use web2py caching . We do not deliberately manage browser caching. We use the lower-level mechanisms of web2py: cache.ram , and refrain from decorating controllers with @cache or @cache.action , because we have to be selective on which request vars are important for keying the cached items. All caching is triggered via the Model: CACHING object. We cahce in RAM only, but there is a switch by which we could also cache on disk, if we want to keep the cache between restarts of the server. Here is a list of what we cache: the numbers of chapters in each book M: BOOKS.get heatmaps (charts) M: CHART.get and M: CHART.getBlocks chapter records M: MATERIAL.getPassage verse content (the content of verses that occur on a page) M: MATERIAL.get single verse content in specific (re)presentation M: VERSE.get and M: VERSE.getJson verse boundaries for a given set of slots, so that the pagination of result pages can be computed M: MATERIAL.getPagination notes occurrences M: NOTE.read clause atoms per verse M: NOTE.getClauseAtoms M: NOTE.getClauseAtomFirstSlot chapters per query and queries per chapter M: QUERYCHAPTER.makeQCindex and M: QUERYCHAPTER.updateQCindex side material of pages M: SIDE.get definitions of view settings M: VIEWDEFS word pages M: WORD.page We do not cache rendered views, because the views implement tweaks that are dependent on the browser. Note that what the user sees, is the effect of the javascript on the html produced by rendered view. So the cached data only has to be indexed by those request vars that select content: mr, qw, book, chapter, item id (iid) and (result) page. I think this strikes a nice balance: * these chunks of html are equal for all users that visit such a page, regardless of their view settings * these chunks of html are relatively small, only the material of one page. It is tempting to cache the SQL queries, but they fetch large amounts of data, of which only a tiny portion shows up. So it uses a lot of space. If a user examines a query with 1000 pages of results, it is unlikely that (s)he will visit all of them, so it is not worthwhile to keep the results of the one big query in cache all the time. On the other hand, many users look at the first page of query results, and by caching individual pages, the number of times that the big query is exececuted is reduced significantly. There is one exception: looking up the queries that have results in a given chapter is quite expensive. We alleviate that by making an index of queries by chapter and store that in the cache. Time consuming and priority This is time consuming and it has to happen before the website is visited. If pages are served before this index is finished, sidebars maybe incomplete, and yet they will be cached, so they remain incomplete. The update script of SHEBANQ will make a first visit right after the update to counter this. Updating the index When a query gets executed, it should be removed from the index and then added again. Therefore we need to know which chapters are affected. For that we also hold an index from queries to chapters in the cache.","title":"Caching"},{"location":"solutions/todo/","text":"Todo \u00b6 Highlighting \u00b6 When you switch on a sidebar on a material page, the highlighting defined by that sidebar is applied to the page. But later, when you switch the same sidebar off, the highlighting is not removed. !!! \"Workaround\" Refresh the page The solution is to clear the highlighting when a sidebar is switched off. But only the highlighting that corresponds with that sidebar.","title":"Todo"},{"location":"solutions/todo/#todo","text":"","title":"Todo"},{"location":"solutions/todo/#highlighting","text":"When you switch on a sidebar on a material page, the highlighting defined by that sidebar is applied to the page. But later, when you switch the same sidebar off, the highlighting is not removed. !!! \"Workaround\" Refresh the page The solution is to clear the highlighting when a sidebar is switched off. But only the highlighting that corresponds with that sidebar.","title":"Highlighting"},{"location":"tests/","text":"Tests \u00b6 We use functional testing to test SHEBANQ. We do not have set up unit testing (yet). A good candidate for unit testing would be the python files in the modules directory, because nearly all the business logic on the server is located there. The controllers are very lean, and delegate all their work to them. However, such unit-testing leaves out many things that are needed for a proper working SHEBANQ: database layer views translation from URL to functions as defined by the framework mechanics of the browser javascript code A few of these could be covered by integration tests , but if we really want to test the proper functioning of the website, we need functional tests. SHEBANQ has been working well from 2013 till 2021, but the update in autumn 2021 involves a massive refactoring. So far, we did not use any testing framework. Still, at the module level, everything seems to work well, even after the refactoring. We have observed that by intensely visiting the website and verifying that every interaction with it works as expected. The biggest gains lie in the automation of visiting the website, and this is exactly functional testing. There is a framework for that, Selenium , which works with the concept of a browser driver . It has a Python interface, and it can work with Safari out of the box, without installing something extra. In order to organize a massive amount of tests, we use the popular test framework PyTest ) There is documentation on individual tests, see individual test scripts . If you have followed the hint in operation you can run tests by shb test arguments which will resolve to cd ~/github/etcbc/shebanq python3 build.py tests arguments This will in turn resolve to cd ~/github/etcbc/shebanq pytest ftests arguments where arguments are options to feed to pytest (do pytest --help to see which options you've got).","title":"Tests"},{"location":"tests/#tests","text":"We use functional testing to test SHEBANQ. We do not have set up unit testing (yet). A good candidate for unit testing would be the python files in the modules directory, because nearly all the business logic on the server is located there. The controllers are very lean, and delegate all their work to them. However, such unit-testing leaves out many things that are needed for a proper working SHEBANQ: database layer views translation from URL to functions as defined by the framework mechanics of the browser javascript code A few of these could be covered by integration tests , but if we really want to test the proper functioning of the website, we need functional tests. SHEBANQ has been working well from 2013 till 2021, but the update in autumn 2021 involves a massive refactoring. So far, we did not use any testing framework. Still, at the module level, everything seems to work well, even after the refactoring. We have observed that by intensely visiting the website and verifying that every interaction with it works as expected. The biggest gains lie in the automation of visiting the website, and this is exactly functional testing. There is a framework for that, Selenium , which works with the concept of a browser driver . It has a Python interface, and it can work with Safari out of the box, without installing something extra. In order to organize a massive amount of tests, we use the popular test framework PyTest ) There is documentation on individual tests, see individual test scripts . If you have followed the hint in operation you can run tests by shb test arguments which will resolve to cd ~/github/etcbc/shebanq python3 build.py tests arguments This will in turn resolve to cd ~/github/etcbc/shebanq pytest ftests arguments where arguments are options to feed to pytest (do pytest --help to see which options you've got).","title":"Tests"},{"location":"tests/bymodule/","text":"About modules \u00b6 Test scripts perform dedicated functional tests. Use the navigation menu to jump to the individual scripts.","title":"About modules"},{"location":"tests/bymodule/#about-modules","text":"Test scripts perform dedicated functional tests. Use the navigation menu to jump to the individual scripts.","title":"About modules"},{"location":"tests/bymodule/__init__/","text":"ftests.__init__ special \u00b6","title":"  init  "},{"location":"tests/bymodule/__init__/#ftests.__init__","text":"","title":"__init__"},{"location":"tests/bymodule/conftest/","text":"ftests.conftest \u00b6 Set up testing the SHEBANQ site Here we set up the scene. By means of fixtures we define the web-app objects to be tested and the web clients to exercise functions in those objects. We use selenium to drive the web-browser. BASE_URL \u00b6 browser () \u00b6 The browser driver We launch the SHEBANQ site in preparation of doing many tests. We do not only deliver a driver, but also a wait object. Source code in ftests/conftest.py @pytest . fixture ( scope = \"session\" ) def browser (): \"\"\"The browser driver We launch the SHEBANQ site in preparation of doing many tests. We do not only deliver a driver, but also a wait object. \"\"\" with Safari () as driver : yield driver print ( \"Closing test browser\" ) wordsPage ( browser , request ) \u00b6 The words page, loaded in the browser. We parametrize it with the ETCBC data versions 2017 and 2021. That means, we have separate fixtures for the words page in these two versions. We also compose the waits dictionary, from which the test functions can derive methods for getting elements with proper waiting built into them. And we return the version. Source code in ftests/conftest.py @pytest . fixture ( scope = \"module\" , params = [ \"2017\" , \"2021\" ]) def wordsPage ( browser , request ): \"\"\"The words page, loaded in the browser. We parametrize it with the ETCBC data versions 2017 and 2021. That means, we have separate fixtures for the words page in these two versions. We also compose the `waits` dictionary, from which the test functions can derive methods for getting elements with proper waiting built into them. And we return the version. \"\"\" waits = getWaits ( browser ) getElem = waits [ \"elem\" ] theUrl = f \" { BASE_URL } /hebrew/words?version= { request . param } \" testId = \"letters\" browser . get ( theUrl ) getElem ( By . ID , testId ) return ( browser , waits , request . param ) queriesPage ( browser , request ) \u00b6 The queries page, loaded in the browser. We parametrize it with the ETCBC data versions 2017 and 2021. That means, we have separate fixtures for the words page in these two versions. We also compose the waits dictionary, from which the test functions can derive methods for getting elements with proper waiting built into them. And we return the version. Source code in ftests/conftest.py @pytest . fixture ( scope = \"module\" ) def queriesPage ( browser , request ): \"\"\"The queries page, loaded in the browser. We parametrize it with the ETCBC data versions 2017 and 2021. That means, we have separate fixtures for the words page in these two versions. We also compose the `waits` dictionary, from which the test functions can derive methods for getting elements with proper waiting built into them. And we return the version. \"\"\" waits = getWaits ( browser ) getElem = waits [ \"elem\" ] theUrl = f \" { BASE_URL } /hebrew/queries\" testId = \"recentq\" browser . get ( theUrl ) getElem ( By . ID , testId ) return ( browser , waits )","title":"Conftest"},{"location":"tests/bymodule/conftest/#ftests.conftest","text":"Set up testing the SHEBANQ site Here we set up the scene. By means of fixtures we define the web-app objects to be tested and the web clients to exercise functions in those objects. We use selenium to drive the web-browser.","title":"conftest"},{"location":"tests/bymodule/conftest/#ftests.conftest.BASE_URL","text":"","title":"BASE_URL"},{"location":"tests/bymodule/conftest/#ftests.conftest.browser","text":"The browser driver We launch the SHEBANQ site in preparation of doing many tests. We do not only deliver a driver, but also a wait object. Source code in ftests/conftest.py @pytest . fixture ( scope = \"session\" ) def browser (): \"\"\"The browser driver We launch the SHEBANQ site in preparation of doing many tests. We do not only deliver a driver, but also a wait object. \"\"\" with Safari () as driver : yield driver print ( \"Closing test browser\" )","title":"browser()"},{"location":"tests/bymodule/conftest/#ftests.conftest.wordsPage","text":"The words page, loaded in the browser. We parametrize it with the ETCBC data versions 2017 and 2021. That means, we have separate fixtures for the words page in these two versions. We also compose the waits dictionary, from which the test functions can derive methods for getting elements with proper waiting built into them. And we return the version. Source code in ftests/conftest.py @pytest . fixture ( scope = \"module\" , params = [ \"2017\" , \"2021\" ]) def wordsPage ( browser , request ): \"\"\"The words page, loaded in the browser. We parametrize it with the ETCBC data versions 2017 and 2021. That means, we have separate fixtures for the words page in these two versions. We also compose the `waits` dictionary, from which the test functions can derive methods for getting elements with proper waiting built into them. And we return the version. \"\"\" waits = getWaits ( browser ) getElem = waits [ \"elem\" ] theUrl = f \" { BASE_URL } /hebrew/words?version= { request . param } \" testId = \"letters\" browser . get ( theUrl ) getElem ( By . ID , testId ) return ( browser , waits , request . param )","title":"wordsPage()"},{"location":"tests/bymodule/conftest/#ftests.conftest.queriesPage","text":"The queries page, loaded in the browser. We parametrize it with the ETCBC data versions 2017 and 2021. That means, we have separate fixtures for the words page in these two versions. We also compose the waits dictionary, from which the test functions can derive methods for getting elements with proper waiting built into them. And we return the version. Source code in ftests/conftest.py @pytest . fixture ( scope = \"module\" ) def queriesPage ( browser , request ): \"\"\"The queries page, loaded in the browser. We parametrize it with the ETCBC data versions 2017 and 2021. That means, we have separate fixtures for the words page in these two versions. We also compose the `waits` dictionary, from which the test functions can derive methods for getting elements with proper waiting built into them. And we return the version. \"\"\" waits = getWaits ( browser ) getElem = waits [ \"elem\" ] theUrl = f \" { BASE_URL } /hebrew/queries\" testId = \"recentq\" browser . get ( theUrl ) getElem ( By . ID , testId ) return ( browser , waits )","title":"queriesPage()"},{"location":"tests/bymodule/helpers/","text":"ftests.helpers \u00b6 getWaits ( driver ) \u00b6 Inspection methods that need a wait We define methods to get an element and to verify the window title. They will be invoked on a wait object, so that they execute when the conditions under which they can run have been met. Parameters: Name Type Description Default driver None A driver object. required Returns: Type Description waits A dictionary keyed by a short name of the method, and valued by functions bound to the wait object, that find something on the page. Source code in ftests/helpers.py def getWaits ( driver ): \"\"\"Inspection methods that need a wait We define methods to get an element and to verify the window title. They will be invoked on a `wait` object, so that they execute when the conditions under which they can run have been met. Parameters ---------- driver A driver object. Returns ------- waits A dictionary keyed by a short name of the method, and valued by functions bound to the wait object, that find something on the page. \"\"\" def getElem ( method , address , maxWait = 1 ): wait = WebDriverWait ( driver , timeout = maxWait ) return wait . until ( presence_of_element_located (( method , address ))) def getTitle ( title , maxWait = 1 ): wait = WebDriverWait ( driver , timeout = maxWait ) return wait . until ( title_is ( title )) return dict ( elem = getElem , title = getTitle )","title":"Helpers"},{"location":"tests/bymodule/helpers/#ftests.helpers","text":"","title":"helpers"},{"location":"tests/bymodule/helpers/#ftests.helpers.getWaits","text":"Inspection methods that need a wait We define methods to get an element and to verify the window title. They will be invoked on a wait object, so that they execute when the conditions under which they can run have been met. Parameters: Name Type Description Default driver None A driver object. required Returns: Type Description waits A dictionary keyed by a short name of the method, and valued by functions bound to the wait object, that find something on the page. Source code in ftests/helpers.py def getWaits ( driver ): \"\"\"Inspection methods that need a wait We define methods to get an element and to verify the window title. They will be invoked on a `wait` object, so that they execute when the conditions under which they can run have been met. Parameters ---------- driver A driver object. Returns ------- waits A dictionary keyed by a short name of the method, and valued by functions bound to the wait object, that find something on the page. \"\"\" def getElem ( method , address , maxWait = 1 ): wait = WebDriverWait ( driver , timeout = maxWait ) return wait . until ( presence_of_element_located (( method , address ))) def getTitle ( title , maxWait = 1 ): wait = WebDriverWait ( driver , timeout = maxWait ) return wait . until ( title_is ( title )) return dict ( elem = getElem , title = getTitle )","title":"getWaits()"},{"location":"tests/bymodule/test_queries/","text":"ftests.test_queries \u00b6 test_queries ( queriesPage ) \u00b6 Tests the word page check the page title change to advanced mode check the number of queries Source code in ftests/test_queries.py def test_queries ( queriesPage ): \"\"\"Tests the word page * check the page title * change to advanced mode * check the number of queries \"\"\" ( browser , waits ) = queriesPage getElem = waits [ \"elem\" ] getTitle = waits [ \"title\" ] assert getTitle ( \"Queries\" ) exampleQuery = getElem ( By . CSS_SELECTOR , \"\"\"[query_id=\"968\"]\"\"\" , maxWait = 10 ) assert exampleQuery . get_attribute ( \"textContent\" ) == \"D Roorda: Qamets Qatan\" advancedElem = getElem ( By . ID , \"c_view_advanced\" ) advancedElem . click () totalElem = getElem ( By . CSS_SELECTOR , \".total\" , maxWait = 10 ) assert totalElem . get_attribute ( \"textContent\" ) == \"1203\"","title":"Test queries"},{"location":"tests/bymodule/test_queries/#ftests.test_queries","text":"","title":"test_queries"},{"location":"tests/bymodule/test_queries/#ftests.test_queries.test_queries","text":"Tests the word page check the page title change to advanced mode check the number of queries Source code in ftests/test_queries.py def test_queries ( queriesPage ): \"\"\"Tests the word page * check the page title * change to advanced mode * check the number of queries \"\"\" ( browser , waits ) = queriesPage getElem = waits [ \"elem\" ] getTitle = waits [ \"title\" ] assert getTitle ( \"Queries\" ) exampleQuery = getElem ( By . CSS_SELECTOR , \"\"\"[query_id=\"968\"]\"\"\" , maxWait = 10 ) assert exampleQuery . get_attribute ( \"textContent\" ) == \"D Roorda: Qamets Qatan\" advancedElem = getElem ( By . ID , \"c_view_advanced\" ) advancedElem . click () totalElem = getElem ( By . CSS_SELECTOR , \".total\" , maxWait = 10 ) assert totalElem . get_attribute ( \"textContent\" ) == \"1203\"","title":"test_queries()"},{"location":"tests/bymodule/test_words/","text":"ftests.test_words \u00b6 test_words ( wordsPage ) \u00b6 Tests the word page check the page title check the number of words starting with alef check the big alef Source code in ftests/test_words.py def test_words ( wordsPage ): \"\"\"Tests the word page * check the page title * check the number of words starting with alef * check the big alef \"\"\" ( browser , waits , version ) = wordsPage getElem = waits [ \"elem\" ] getTitle = waits [ \"title\" ] assert getTitle ( \"Words\" ) numberElem = getElem ( By . ID , \"nwords\" ) expNumber = 833 if version == \"2017\" else 831 if version == \"2021\" else 0 assert numberElem . get_attribute ( \"textContent\" ) == f \" { expNumber } words\" firstResult = getElem ( By . CSS_SELECTOR , \"h1.dletterh\" ) assert firstResult . get_attribute ( \"textContent\" ) == \"\u05d0\" test_word ( wordsPage ) \u00b6 Tests an individual word from the list. We pick the first word in the list and do this check the gloss and the text of the entry in the two separate forms (with and without trailing / ) check which one of the two forms is displayed switch to the other display by clicking on the gloss check again which one of the two forms is displayed navigate to the record page of the word by clicking on the word find the link to navigate back to the overview page click that link go to the selected word on the overview page and check that the gloss is \"father\" Source code in ftests/test_words.py def test_word ( wordsPage ): \"\"\"Tests an individual word from the list. We pick the first word in the list and do this * check the gloss and the text of the entry in the two separate forms (with and without trailing `/`) * check which one of the two forms is displayed * switch to the other display by clicking on the gloss * check again which one of the two forms is displayed * navigate to the record page of the word by clicking on the word * find the link to navigate back to the overview page * click that link * go to the selected word on the overview page and check that the gloss is \"father\" \"\"\" ( browser , waits , version ) = wordsPage getElem = waits [ \"elem\" ] infoElems = {} for ( att , expected ) in ( ( \"gi\" , \"father\" ), ( \"wi\" , \"\u05d0\u05d1\" ), ( \"wii\" , \"\u05d0\u05d1/\" ), ): wordElem = getElem ( By . CSS_SELECTOR , f \"\"\"a[ { att } =\"1ABn\"]\"\"\" ) assert wordElem . get_attribute ( \"textContent\" ) == expected infoElems [ att ] = wordElem for att in [ \"wi\" , \"wii\" ]: wordElem = infoElems [ att ] assert ( wordElem . value_of_css_property ( \"display\" ) == \"inline\" if att == \"wi\" else \"none\" ) infoElems [ \"gi\" ] . click () for att in [ \"wi\" , \"wii\" ]: wordElem = infoElems [ att ] assert ( wordElem . value_of_css_property ( \"display\" ) == \"none\" if att == \"wi\" else \"inline\" ) linkElem = infoElems [ \"wii\" ] linkElem . click () gobackElem = getElem ( By . ID , \"gobackw\" ) gobackElem . click () selectedElem = getElem ( By . CSS_SELECTOR , \".d.selecthlw\" ) infoElem = selectedElem . find_element ( By . CSS_SELECTOR , \"[gi]\" ) assert infoElem . get_attribute ( \"textContent\" ) == \"father\"","title":"Test words"},{"location":"tests/bymodule/test_words/#ftests.test_words","text":"","title":"test_words"},{"location":"tests/bymodule/test_words/#ftests.test_words.test_words","text":"Tests the word page check the page title check the number of words starting with alef check the big alef Source code in ftests/test_words.py def test_words ( wordsPage ): \"\"\"Tests the word page * check the page title * check the number of words starting with alef * check the big alef \"\"\" ( browser , waits , version ) = wordsPage getElem = waits [ \"elem\" ] getTitle = waits [ \"title\" ] assert getTitle ( \"Words\" ) numberElem = getElem ( By . ID , \"nwords\" ) expNumber = 833 if version == \"2017\" else 831 if version == \"2021\" else 0 assert numberElem . get_attribute ( \"textContent\" ) == f \" { expNumber } words\" firstResult = getElem ( By . CSS_SELECTOR , \"h1.dletterh\" ) assert firstResult . get_attribute ( \"textContent\" ) == \"\u05d0\"","title":"test_words()"},{"location":"tests/bymodule/test_words/#ftests.test_words.test_word","text":"Tests an individual word from the list. We pick the first word in the list and do this check the gloss and the text of the entry in the two separate forms (with and without trailing / ) check which one of the two forms is displayed switch to the other display by clicking on the gloss check again which one of the two forms is displayed navigate to the record page of the word by clicking on the word find the link to navigate back to the overview page click that link go to the selected word on the overview page and check that the gloss is \"father\" Source code in ftests/test_words.py def test_word ( wordsPage ): \"\"\"Tests an individual word from the list. We pick the first word in the list and do this * check the gloss and the text of the entry in the two separate forms (with and without trailing `/`) * check which one of the two forms is displayed * switch to the other display by clicking on the gloss * check again which one of the two forms is displayed * navigate to the record page of the word by clicking on the word * find the link to navigate back to the overview page * click that link * go to the selected word on the overview page and check that the gloss is \"father\" \"\"\" ( browser , waits , version ) = wordsPage getElem = waits [ \"elem\" ] infoElems = {} for ( att , expected ) in ( ( \"gi\" , \"father\" ), ( \"wi\" , \"\u05d0\u05d1\" ), ( \"wii\" , \"\u05d0\u05d1/\" ), ): wordElem = getElem ( By . CSS_SELECTOR , f \"\"\"a[ { att } =\"1ABn\"]\"\"\" ) assert wordElem . get_attribute ( \"textContent\" ) == expected infoElems [ att ] = wordElem for att in [ \"wi\" , \"wii\" ]: wordElem = infoElems [ att ] assert ( wordElem . value_of_css_property ( \"display\" ) == \"inline\" if att == \"wi\" else \"none\" ) infoElems [ \"gi\" ] . click () for att in [ \"wi\" , \"wii\" ]: wordElem = infoElems [ att ] assert ( wordElem . value_of_css_property ( \"display\" ) == \"none\" if att == \"wi\" else \"inline\" ) linkElem = infoElems [ \"wii\" ] linkElem . click () gobackElem = getElem ( By . ID , \"gobackw\" ) gobackElem . click () selectedElem = getElem ( By . CSS_SELECTOR , \".d.selecthlw\" ) infoElem = selectedElem . find_element ( By . CSS_SELECTOR , \"[gi]\" ) assert infoElem . get_attribute ( \"textContent\" ) == \"father\"","title":"test_word()"}]}